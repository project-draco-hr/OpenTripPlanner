{
  AccumulativeMetric<WTWD> accMetric=new AccumulativeMetric<WTWD>(){
    @Override public WTWD cumulateSample(    Coordinate C0,    Coordinate Cs,    double z,    WTWD zS){
      double t=z;
      double d=distanceLibrary.fastDistance(C0,Cs,cosLat);
      double dt=d / v0;
      double w=1 / ((d + d0) * (d + d0));
      if (zS == null) {
        zS=new WTWD();
        zS.d=Double.MAX_VALUE;
      }
      zS.w=zS.w + w;
      zS.tw=zS.tw + w * (t + dt);
      if (d < zS.d)       zS.d=d;
      return zS;
    }
    @Override public WTWD closeSample(    WTWD zUp,    WTWD zDown,    WTWD zRight,    WTWD zLeft){
      double dMin=Double.MAX_VALUE;
      for (      WTWD z : new WTWD[]{zUp,zDown,zRight,zLeft}) {
        if (z == null)         continue;
        if (z.d < dMin)         dMin=z.d;
      }
      WTWD z=new WTWD();
      z.w=1.0;
      z.tw=Double.POSITIVE_INFINITY;
      z.d=dMin + gridSizeMeters;
      return z;
    }
  }
;
  final AccumulativeGridSampler<WTWD> gridSampler=new AccumulativeGridSampler<WTWD>(sampleGrid,accMetric);
  SPTWalker johnny=new SPTWalker(spt);
  johnny.walk(new SPTVisitor(){
    @Override public final boolean accept(    Edge e){
      return e instanceof StreetEdge;
    }
    @Override public final void visit(    Coordinate c,    State s0,    State s1,    double d0,    double d1){
      double wd0=s0.getWalkDistance() + d0;
      double wd1=s0.getWalkDistance() + d1;
      double t0=wd0 > maxWalkDistance ? Double.POSITIVE_INFINITY : s0.getActiveTime() + d0 / v0;
      double t1=wd1 > maxWalkDistance ? Double.POSITIVE_INFINITY : s1.getActiveTime() + d1 / v0;
      if (!Double.isInfinite(t0) || !Double.isInfinite(t1))       gridSampler.addSamplingPoint(c,t0 < t1 ? t0 : t1);
    }
  }
,d0);
  gridSampler.close();
}
