{
  final double D0=isoChroneRequest.getPrecisionMeters() * 0.8;
  final double V0=1.00;
  long t0=System.currentTimeMillis();
  long tOvershot=(long)(2 * D0 / V0);
  sptRequest.setWorstTime(sptRequest.dateTime + (sptRequest.arriveBy ? -isoChroneRequest.getMaxCutoffSec() - tOvershot : isoChroneRequest.getMaxCutoffSec() + tOvershot));
  sptRequest.setBatch(true);
  sptRequest.setRoutingContext(graphService.getGraph(sptRequest.getRouterId()));
  final ShortestPathTree spt=sptService.getShortestPathTree(sptRequest);
  long t1=System.currentTimeMillis();
  Coordinate center=sptRequest.getFrom().getCoordinate();
  final double gridSizeMeters=isoChroneRequest.getPrecisionMeters();
  final double cosLat=FastMath.cos(toRadians(center.y));
  double dY=Math.toDegrees(gridSizeMeters / SphericalDistanceLibrary.RADIUS_OF_EARTH_IN_M);
  double dX=dY / cosLat;
  ZSampleGrid<WTWD> sampleGrid=new SparseMatrixZSampleGrid<WTWD>(16,spt.getVertexCount(),dX,dY,center);
  sampleSPT(spt,sampleGrid,gridSizeMeters * 0.7,gridSizeMeters,V0,sptRequest.getMaxWalkDistance(),cosLat);
  sptRequest.cleanup();
  ZMetric<WTWD> zMetric=new ZMetric<WTWD>(){
    @Override public int cut(    WTWD zA,    WTWD zB,    WTWD z0){
      double t0=z0.tw / z0.w;
      double tA=zA.d > z0.d ? Double.POSITIVE_INFINITY : zA.tw / zA.w;
      double tB=zB.d > z0.d ? Double.POSITIVE_INFINITY : zB.tw / zB.w;
      if (tA < t0 && t0 <= tB)       return 1;
      if (tB < t0 && t0 <= tA)       return -1;
      return 0;
    }
    @Override public double interpolate(    WTWD zA,    WTWD zB,    WTWD z0){
      if (zA.d > z0.d || zB.d > z0.d) {
        if (zA.d > z0.d && zB.d > z0.d)         throw new AssertionError("dA > d0 && dB > d0");
        double k=zA.d == zB.d ? 0.5 : (z0.d - zA.d) / (zB.d - zA.d);
        return k;
      }
 else {
        double tA=zA.tw / zA.w;
        double tB=zB.tw / zB.w;
        double t0=z0.tw / z0.w;
        double k=tA == tB ? 0.5 : (t0 - tA) / (tB - tA);
        return k;
      }
    }
  }
;
  SampleGridIsolineBuilder<WTWD> isolineBuilder=new SampleGridIsolineBuilder<WTWD>(sampleGrid,zMetric);
  isolineBuilder.setDebug(isoChroneRequest.isIncludeDebugGeometry());
  long t2=System.currentTimeMillis();
  List<IsochroneData> isochrones=new ArrayList<IsochroneData>();
  for (  Integer cutoffSec : isoChroneRequest.getCutoffSecList()) {
    WTWD z0=new WTWD();
    z0.w=1.0;
    z0.tw=cutoffSec;
    z0.d=D0;
    IsochroneData isochrone=new IsochroneData(cutoffSec,isolineBuilder.computeIsoline(z0));
    if (isoChroneRequest.isIncludeDebugGeometry())     isochrone.setDebugGeometry(isolineBuilder.getDebugGeometry());
    isochrones.add(isochrone);
  }
  long t3=System.currentTimeMillis();
  LOG.info("Computed SPT in {}msec, {} isochrones in {}msec ({}msec for sampling)",(int)(t1 - t0),isochrones.size(),(int)(t3 - t1),(int)(t2 - t1));
  return isochrones;
}
