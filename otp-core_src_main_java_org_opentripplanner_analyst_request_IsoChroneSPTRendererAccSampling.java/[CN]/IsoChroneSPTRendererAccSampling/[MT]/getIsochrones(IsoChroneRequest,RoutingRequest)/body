{
  final double D0=isoChroneRequest.getPrecisionMeters() * 0.8;
  final double V0=1.00;
  long t0=System.currentTimeMillis();
  long tOvershot=(long)(2 * D0 / V0);
  sptRequest.setWorstTime(sptRequest.dateTime + (sptRequest.arriveBy ? -isoChroneRequest.getMaxCutoffSec() - tOvershot : isoChroneRequest.getMaxCutoffSec() + tOvershot));
  sptRequest.setBatch(true);
  sptRequest.setRoutingContext(graphService.getGraph(sptRequest.getRouterId()));
  final ShortestPathTree spt=sptService.getShortestPathTree(sptRequest);
  long t1=System.currentTimeMillis();
  Coordinate center=sptRequest.getFrom().getCoordinate();
  final double gridSizeMeters=isoChroneRequest.getPrecisionMeters();
  final double cosLat=FastMath.cos(toRadians(center.y));
  double dY=Math.toDegrees(gridSizeMeters / SphericalDistanceLibrary.RADIUS_OF_EARTH_IN_M);
  double dX=dY / cosLat;
  ZFunc<WTWD> zFunc=new ZFunc<WTWD>(){
    @Override public WTWD cumulateSample(    Coordinate C0,    Coordinate Cs,    double z,    WTWD zS){
      double t=z;
      double d=distanceLibrary.fastDistance(C0,Cs,cosLat);
      double dt=d / V0;
      double w=1 / (d + D0) * (d + D0);
      if (zS == null) {
        zS=new WTWD();
        zS.d=Double.MAX_VALUE;
      }
      zS.w=zS.w + w;
      zS.tw=zS.tw + w * (t + dt);
      if (d < zS.d)       zS.d=d;
      return zS;
    }
    @Override public WTWD closeSample(    WTWD zUp,    WTWD zDown,    WTWD zRight,    WTWD zLeft){
      double dMin=Double.MAX_VALUE;
      for (      WTWD z : new WTWD[]{zUp,zDown,zRight,zLeft}) {
        if (z == null)         continue;
        double d=z.d / z.w;
        if (d < dMin)         dMin=d;
      }
      WTWD z=new WTWD();
      z.w=1.0;
      z.tw=Double.POSITIVE_INFINITY;
      z.d=dMin + gridSizeMeters;
      return z;
    }
    @Override public int cut(    WTWD zA,    WTWD zB,    WTWD z0){
      double t0=z0.tw / z0.w;
      double tA=zA.d > z0.d ? Double.POSITIVE_INFINITY : zA.tw / zA.w;
      double tB=zB.d > z0.d ? Double.POSITIVE_INFINITY : zB.tw / zB.w;
      if (tA < t0 && t0 <= tB)       return 1;
      if (tB < t0 && t0 <= tA)       return -1;
      return 0;
    }
    @Override public double interpolate(    WTWD zA,    WTWD zB,    WTWD z0){
      if (zA.d > z0.d || zB.d > z0.d) {
        if (zA.d > z0.d && zB.d > z0.d)         throw new AssertionError("dA > d0 && dB > d0");
        double k=zA.d == zB.d ? 0.5 : (z0.d - zA.d) / (zB.d - zA.d);
        return k;
      }
 else {
        double tA=zA.tw / zA.w;
        double tB=zB.tw / zB.w;
        double t0=z0.tw / z0.w;
        double k=tA == tB ? 0.5 : (t0 - tA) / (tB - tA);
        return k;
      }
    }
  }
;
  AccSamplingGridIsolineBuilder<WTWD> isolineBuilder=new AccSamplingGridIsolineBuilder<WTWD>(dX,dY,center,zFunc,spt.getVertexCount());
  isolineBuilder.setDebug(isoChroneRequest.isIncludeDebugGeometry());
  computeInitialPoints(spt,isolineBuilder,gridSizeMeters * 0.7,V0,sptRequest.getMaxWalkDistance());
  sptRequest.cleanup();
  long t2=System.currentTimeMillis();
  List<IsochroneData> isochrones=new ArrayList<IsochroneData>();
  for (  Integer cutoffSec : isoChroneRequest.getCutoffSecList()) {
    WTWD z0=new WTWD();
    z0.w=1.0;
    z0.tw=cutoffSec;
    z0.d=D0;
    IsochroneData isochrone=new IsochroneData(cutoffSec,isolineBuilder.computeIsoline(z0));
    if (isoChroneRequest.isIncludeDebugGeometry())     isochrone.setDebugGeometry(isolineBuilder.getDebugGeometry());
    isochrones.add(isochrone);
  }
  long t3=System.currentTimeMillis();
  LOG.info("Computed SPT in {}msec, {} isochrones in {}msec ({}msec for sampling)",(int)(t1 - t0),isochrones.size(),(int)(t3 - t1),(int)(t2 - t1));
  return isochrones;
}
