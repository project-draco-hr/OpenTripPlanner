{
  final double D0=isoChroneRequest.getPrecisionMeters() * 0.8;
  final double V0=1.00;
  long t0=System.currentTimeMillis();
  long tOvershot=(long)(2 * D0 / V0);
  sptRequest.setWorstTime(sptRequest.dateTime + (sptRequest.arriveBy ? -isoChroneRequest.getMaxCutoffSec() - tOvershot : isoChroneRequest.getMaxCutoffSec() + tOvershot));
  sptRequest.setBatch(true);
  sptRequest.setRoutingContext(graphService.getGraph(sptRequest.getRouterId()));
  final ShortestPathTree spt=sptService.getShortestPathTree(sptRequest);
  long t1=System.currentTimeMillis();
  Coordinate center=sptRequest.getFrom().getCoordinate();
  final double gridSizeMeters=isoChroneRequest.getPrecisionMeters();
  final double cosLat=FastMath.cos(toRadians(center.y));
  double dY=Math.toDegrees(gridSizeMeters / SphericalDistanceLibrary.RADIUS_OF_EARTH_IN_M);
  double dX=dY / cosLat;
  ZFunc zFunc=new ZFunc(){
    @Override public double[] cumulateSample(    Coordinate C0,    Coordinate Cs,    double z,    double[] zzS){
      double t=z;
      double d=distanceLibrary.fastDistance(C0,Cs,cosLat);
      double dt=d / V0;
      double w=1 / (d + D0) * (d + D0);
      if (zzS == null) {
        zzS=new double[3];
        zzS[2]=Double.MAX_VALUE;
      }
      zzS[0]=zzS[0] + w;
      zzS[1]=zzS[1] + w * (t + dt);
      if (d < zzS[2])       zzS[2]=d;
      return zzS;
    }
    @Override public double[] closeSample(    double[] zzUp,    double[] zzDown,    double[] zzRight,    double[] zzLeft){
      double dMin=Double.MAX_VALUE;
      for (      double[] zz : new double[][]{zzUp,zzDown,zzRight,zzLeft}) {
        if (zz == null)         continue;
        double d=zz[2] / zz[0];
        if (d < dMin)         dMin=d;
      }
      double[] zz=new double[3];
      zz[0]=1.0;
      zz[1]=Double.POSITIVE_INFINITY;
      zz[2]=dMin + gridSizeMeters;
      return zz;
    }
    @Override public int cut(    double[] zzA,    double[] zzB,    double[] zz0){
      double dA=zzA[2];
      double dB=zzB[2];
      double t0=zz0[0];
      double d0=zz0[1];
      double tA=dA > d0 ? Double.POSITIVE_INFINITY : zzA[1] / zzA[0];
      double tB=dB > d0 ? Double.POSITIVE_INFINITY : zzB[1] / zzB[0];
      if (tA < t0 && t0 <= tB)       return 1;
      if (tB < t0 && t0 <= tA)       return -1;
      return 0;
    }
    @Override public double interpolate(    double[] zzA,    double[] zzB,    double[] zz0){
      double dA=zzA[2];
      double dB=zzB[2];
      double t0=zz0[0];
      double d0=zz0[1];
      if (dA > d0 || dB > d0) {
        if (dA > d0 && dB > d0)         throw new AssertionError("dA > d0 && dB > d0");
        double k=dA == dB ? 0.5 : (d0 - dA) / (dB - dA);
        return k;
      }
 else {
        double tA=zzA[1] / zzA[0];
        double tB=zzB[1] / zzB[0];
        double k=tA == tB ? 0.5 : (t0 - tA) / (tB - tA);
        return k;
      }
    }
  }
;
  AccSamplingGridIsolineBuilder isolineBuilder=new AccSamplingGridIsolineBuilder(dX,dY,center,zFunc,spt.getVertexCount());
  isolineBuilder.setDebug(isoChroneRequest.isIncludeDebugGeometry());
  computeInitialPoints(spt,isolineBuilder,gridSizeMeters * 0.7,V0,sptRequest.getMaxWalkDistance());
  sptRequest.cleanup();
  long t2=System.currentTimeMillis();
  List<IsochroneData> isochrones=new ArrayList<IsochroneData>();
  for (  Integer cutoffSec : isoChroneRequest.getCutoffSecList()) {
    IsochroneData isochrone=new IsochroneData(cutoffSec,isolineBuilder.computeIsoline(new double[]{cutoffSec,D0}));
    if (isoChroneRequest.isIncludeDebugGeometry())     isochrone.setDebugGeometry(isolineBuilder.getDebugGeometry());
    isochrones.add(isochrone);
  }
  long t3=System.currentTimeMillis();
  LOG.info("Computed SPT in {}msec, {} isochrones in {}msec ({}msec for sampling)",(int)(t1 - t0),isochrones.size(),(int)(t3 - t1),(int)(t2 - t1));
  return isochrones;
}
