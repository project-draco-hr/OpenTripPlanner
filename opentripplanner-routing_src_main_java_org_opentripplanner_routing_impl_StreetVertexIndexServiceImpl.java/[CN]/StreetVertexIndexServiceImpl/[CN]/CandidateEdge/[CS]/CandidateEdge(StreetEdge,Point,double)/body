{
  edge=e;
  Geometry edgeGeom=edge.getGeometry();
  op=new DistanceOp(p,edgeGeom);
  distance=op.distance();
  GeometryLocation edgeLocation=op.nearestLocations()[1];
  nearestPointOnEdge=edgeLocation.getCoordinate();
  Coordinate[] edgeCoords=edgeGeom.getCoordinates();
  if (nearestPointOnEdge.equals(edgeCoords[0]))   endwiseVertex=edge.getFromVertex();
 else   if (nearestPointOnEdge.equals(edgeCoords[edgeCoords.length - 1]))   endwiseVertex=edge.getToVertex();
 else   endwiseVertex=null;
  score=distance;
  if (endwise()) {
    score*=1.5;
  }
  score/=preference;
  if ((e.getStreetClass() & StreetEdge.CLASS_PLATFORM) != 0) {
    score/=PLATFORM_PREFERENCE;
  }
  if (e.getName().contains("sidewalk")) {
    score/=SIDEWALK_PREFERENCE;
  }
  if (e.getPermission().allows(StreetTraversalPermission.CAR)) {
    score-=CAR_PREFERENCE;
  }
  score+=edge.getLength() / 1000000;
  double xd=nearestPointOnEdge.x - p.getX();
  double yd=nearestPointOnEdge.y - p.getY();
  directionToEdge=Math.atan2(yd,xd);
  int edgeSegmentIndex=edgeLocation.getSegmentIndex();
  Coordinate c0=edgeCoords[edgeSegmentIndex];
  Coordinate c1=edgeCoords[edgeSegmentIndex + 1];
  xd=c1.x - c1.y;
  yd=c1.y - c0.y;
  directionOfEdge=Math.atan2(yd,xd);
  double absDiff=Math.abs(directionToEdge - directionOfEdge);
  directionDifference=Math.min(2 * Math.PI - absDiff,absDiff);
  if (Double.isNaN(directionToEdge) || Double.isNaN(directionOfEdge) || Double.isNaN(directionDifference)) {
    _log.warn("direction to/of edge is NaN (0 length?): {}",edge);
  }
}
