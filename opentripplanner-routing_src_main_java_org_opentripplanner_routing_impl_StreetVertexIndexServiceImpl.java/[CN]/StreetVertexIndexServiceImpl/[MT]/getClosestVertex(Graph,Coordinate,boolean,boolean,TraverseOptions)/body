{
  Envelope envelope=new Envelope(c);
  List<Edge> nearby=new LinkedList<Edge>();
  int i=0;
  double envelopeGrowthRate=0.0018;
  GeometryFactory factory=new GeometryFactory();
  Point p=factory.createPoint(c);
  while (nearby.size() < 1 && i < 10) {
    ++i;
    envelope.expandBy(envelopeGrowthRate);
    envelopeGrowthRate*=2;
    if (includeTransitStops) {
      double bestDistance=Double.MAX_VALUE;
      List<Vertex> nearbyTransitStops=transitStopTree.query(envelope);
      Vertex bestStop=null;
      for (      Vertex v : nearbyTransitStops) {
        Coordinate sc=v.getCoordinate();
        double distance=sc.distance(c);
        if (distance < bestDistance) {
          bestDistance=distance;
          bestStop=v;
        }
      }
      if (bestDistance <= MAX_SNAP_DISTANCE) {
        return bestStop;
      }
    }
    double bestDistance=Double.MAX_VALUE;
    nearby=edgeTree.query(envelope);
    if (nearby != null) {
      Edge bestStreet=null;
      for (      Edge e : nearby) {
        if (e == null)         continue;
        Geometry g=e.getGeometry();
        if (g != null) {
          double distance=g.distance(p);
          if (distance < bestDistance) {
            bestStreet=e;
            bestDistance=distance;
          }
        }
      }
      if (bestDistance <= MAX_DISTANCE_FROM_STREET) {
        Geometry g=bestStreet.getGeometry();
        LocationIndexedLine l=new LocationIndexedLine(g);
        LinearLocation location=l.project(c);
        Vertex fromv=bestStreet.getFromVertex();
        Vertex tov=bestStreet.getToVertex();
        Coordinate start=fromv.getCoordinate();
        Coordinate end=tov.getCoordinate();
        Coordinate nearestPoint=location.getCoordinate(g);
        if (allowSnappingToIntersections) {
          if (nearestPoint.distance(start) < MAX_SNAP_DISTANCE) {
            return fromv;
          }
 else           if (nearestPoint.distance(end) < MAX_SNAP_DISTANCE) {
            return tov;
          }
        }
        TreeMap<Double,Edge> parallel=new TreeMap<Double,Edge>();
        for (        Edge e : nearby) {
          if (e == null) {
            continue;
          }
          if (options != null && e instanceof StreetEdge) {
            if (!((StreetEdge)e).canTraverse(options)) {
              continue;
            }
          }
          Geometry eg=e.getGeometry();
          if (eg != null) {
            double distance=eg.distance(p);
            if (distance <= bestDistance + DISTANCE_ERROR) {
              parallel.put(distance,e);
            }
          }
        }
        return StreetLocation.createStreetLocation(graph,bestStreet.getName() + "_" + c.toString(),bestStreet.getName(),parallel.values(),nearestPoint);
      }
    }
  }
  return null;
}
