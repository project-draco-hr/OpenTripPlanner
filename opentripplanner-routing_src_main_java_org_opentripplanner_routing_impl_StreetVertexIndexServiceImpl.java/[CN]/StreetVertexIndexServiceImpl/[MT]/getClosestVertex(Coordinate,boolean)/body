{
  Envelope envelope=new Envelope(c);
  List<Street> nearby=new LinkedList<Street>();
  int i=0;
  double envelopeGrowthRate=0.0018;
  GeometryFactory factory=new GeometryFactory();
  Point p=factory.createPoint(c);
  while (nearby.size() < 1 && i < 4) {
    ++i;
    envelope.expandBy(envelopeGrowthRate);
    envelopeGrowthRate*=2;
    if (includeTransitStops) {
      double bestDistance=Double.MAX_VALUE;
      List<Vertex> nearbyTransitStops=transitStopTree.query(envelope);
      Vertex bestStop=null;
      for (      Vertex v : nearbyTransitStops) {
        Coordinate sc=v.getCoordinate();
        double distance=sc.distance(c);
        if (distance < bestDistance) {
          bestDistance=distance;
          bestStop=v;
        }
      }
      if (bestDistance <= MAX_SNAP_DISTANCE) {
        return bestStop;
      }
    }
    double bestDistance=Double.MAX_VALUE;
    nearby=edgeTree.query(envelope);
    if (nearby != null) {
      for (      Street e : nearby) {
        if (e == null)         continue;
        Geometry g=e.getGeometry();
        if (g != null) {
          double distance=g.distance(p);
          if (distance < bestDistance) {
            bestDistance=distance;
          }
        }
      }
      List<Street> parallel=new LinkedList<Street>();
      Street bestStreet=null;
      for (      Street e : nearby) {
        if (e == null)         continue;
        Geometry g=e.getGeometry();
        if (g != null) {
          double distance=g.distance(p);
          if (distance <= bestDistance + DISTANCE_ERROR && (bestStreet == null || ((bestStreet.getFromVertex() == e.getFromVertex() && bestStreet.getToVertex() == e.getToVertex()) || (bestStreet.getToVertex() == e.getFromVertex() && bestStreet.getFromVertex() == e.getToVertex())))) {
            if (bestStreet == null)             bestStreet=e;
            parallel.add(e);
          }
        }
      }
      if (bestDistance <= MAX_DISTANCE_FROM_STREET) {
        bestStreet=parallel.get(0);
        Geometry g=bestStreet.getGeometry();
        LocationIndexedLine l=new LocationIndexedLine(g);
        LinearLocation location=l.project(c);
        Coordinate start=bestStreet.getFromVertex().getCoordinate();
        Coordinate end=bestStreet.getToVertex().getCoordinate();
        Coordinate nearestPoint=location.getCoordinate(g);
        if (nearestPoint.distance(start) < MAX_SNAP_DISTANCE) {
          return bestStreet.getFromVertex();
        }
 else         if (nearestPoint.distance(end) < MAX_SNAP_DISTANCE) {
          return bestStreet.getToVertex();
        }
        return StreetLocation.createStreetLocation(bestStreet.getName() + "_" + c.toString(),bestStreet.getName(),parallel,nearestPoint);
      }
    }
  }
  return null;
}
