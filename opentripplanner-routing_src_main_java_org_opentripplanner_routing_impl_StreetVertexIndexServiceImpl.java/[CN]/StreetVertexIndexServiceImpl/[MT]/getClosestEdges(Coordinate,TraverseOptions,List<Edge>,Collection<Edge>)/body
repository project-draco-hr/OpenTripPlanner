{
  ArrayList<StreetEdge> extraStreets=new ArrayList<StreetEdge>();
  if (extraEdges != null)   for (  StreetEdge se : IterableLibrary.filter(extraEdges,StreetEdge.class))   extraStreets.add(se);
  Envelope envelope=new Envelope(coordinate);
  GeometryFactory factory=new GeometryFactory();
  Point p=factory.createPoint(coordinate);
  TraverseOptions walkingOptions=null;
  if (options != null) {
    walkingOptions=options.getWalkingOptions();
  }
  double envelopeGrowthAmount=0.002;
  CandidateEdgeBundle candidateEdges=new CandidateEdgeBundle();
  while (candidateEdges.size() == 0) {
    if (envelope.getWidth() > MAX_DISTANCE_FROM_STREET * 2)     return candidateEdges;
    envelope.expandBy(envelopeGrowthAmount);
    envelopeGrowthAmount*=2;
    List<StreetEdge> nearbyEdges=edgeTree.query(envelope);
    if (extraEdges != null && nearbyEdges != null) {
      nearbyEdges=new JoinedList<StreetEdge>(nearbyEdges,extraStreets);
    }
    for (    StreetEdge e : nearbyEdges) {
      if (e == null || e instanceof OutEdge)       continue;
      if (options != null && (!(e.canTraverse(options) || e.canTraverse(walkingOptions))))       continue;
      double preferrence=1;
      if (routeEdges != null && routeEdges.contains(e)) {
        preferrence=3.0;
      }
      CandidateEdge ce=new CandidateEdge(e,p,preferrence);
      if (ce.distance < MAX_DISTANCE_FROM_STREET)       candidateEdges.add(ce);
    }
  }
  Collection<CandidateEdgeBundle> bundles=candidateEdges.binByDistanceAndAngle();
  CandidateEdgeBundle best=null;
  for (  CandidateEdgeBundle bundle : bundles) {
    if (best == null || bundle.best.score < best.best.score)     best=bundle;
  }
  return best;
}
