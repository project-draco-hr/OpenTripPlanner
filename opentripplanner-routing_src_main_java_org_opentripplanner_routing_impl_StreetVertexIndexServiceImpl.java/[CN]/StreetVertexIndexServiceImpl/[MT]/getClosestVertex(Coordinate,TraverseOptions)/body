{
  List<Vertex> vertices=getIntersectionAt(coordinate);
  if (vertices != null && !vertices.isEmpty()) {
    StreetLocation closest=new StreetLocation("corner " + Math.random(),coordinate,"");
    for (    Vertex v : vertices) {
      FreeEdge e=new FreeEdge(closest,v);
      closest.getExtra().add(e);
      e=new FreeEdge(v,closest);
      closest.getExtra().add(e);
    }
    return closest;
  }
  double closest_stop_distance=Double.POSITIVE_INFINITY;
  Vertex closest_stop=null;
  if (options != null && options.getModes().getTransit()) {
    for (    Vertex v : getLocalTransitStops(coordinate,400)) {
      double d=v.distance(coordinate);
      _log.debug("stop " + v + " distance "+ d);
      if (d < closest_stop_distance) {
        closest_stop_distance=d;
        closest_stop=v;
      }
    }
  }
  _log.debug("best stop: " + closest_stop + " distance "+ closest_stop_distance);
  StreetLocation closest_street=null;
  Collection<StreetEdge> edges=getClosestEdges(coordinate,options);
  if (edges != null) {
    StreetEdge bestStreet=edges.iterator().next();
    Geometry g=bestStreet.getGeometry();
    LocationIndexedLine l=new LocationIndexedLine(g);
    LinearLocation location=l.project(coordinate);
    Coordinate nearestPoint=location.getCoordinate(g);
    _log.debug("best street: " + bestStreet.toString() + DistanceLibrary.distance(coordinate,nearestPoint));
    _log.debug("returning split street");
    closest_street=StreetLocation.createStreetLocation(bestStreet.getName() + "_" + coordinate.toString(),bestStreet.getName(),edges,nearestPoint);
  }
  _log.debug("returning transit stop (closer than street)");
  if (closest_street == null) {
    return closest_stop;
  }
 else {
    if (closest_stop != null) {
      closest_street.addExtraEdgeTo(closest_stop);
    }
    return closest_street;
  }
}
