{
  _log.debug("Looking for/making a vertex near {}",coordinate);
  StreetVertex intersection=getIntersectionAt(coordinate,MAX_CORNER_DISTANCE);
  if (intersection != null) {
    if (name == null) {
      Set<String> uniqueNameSet=new HashSet<String>();
      for (      Edge e : intersection.getOutgoing()) {
        if (e instanceof StreetEdge) {
          uniqueNameSet.add(e.getName());
        }
      }
      List<String> uniqueNames=new ArrayList<String>(uniqueNameSet);
      Locale locale;
      if (options == null) {
        locale=new Locale("en");
      }
 else {
        locale=options.getLocale();
      }
      ResourceBundle resources=ResourceBundle.getBundle("internals",locale);
      String fmt=resources.getString("corner");
      if (uniqueNames.size() > 1) {
        name=String.format(fmt,uniqueNames.get(0),uniqueNames.get(1));
      }
 else       if (uniqueNames.size() == 1) {
        name=uniqueNames.get(0);
      }
 else {
        name=resources.getString("unnamedStreet");
      }
    }
    StreetLocation closest=new StreetLocation(graph,"corner " + Math.random(),coordinate,name);
    FreeEdge e=new FreeEdge(closest,intersection);
    closest.getExtra().add(e);
    e=new FreeEdge(intersection,closest);
    closest.getExtra().add(e);
    return closest;
  }
  double closest_stop_distance=Double.POSITIVE_INFINITY;
  Vertex closest_stop=null;
  if (options != null && options.getModes().isTransit()) {
    for (    Vertex v : getLocalTransitStops(coordinate,1000)) {
      double d=distanceLibrary.distance(v.getCoordinate(),coordinate);
      if (d < closest_stop_distance) {
        closest_stop_distance=d;
        closest_stop=v;
      }
    }
  }
  _log.debug(" best stop: {} distance: {}",closest_stop,closest_stop_distance);
  StreetLocation closestStreet=null;
  CandidateEdgeBundle bundle=getClosestEdges(coordinate,options,extraEdges,null,false);
  CandidateEdge candidate=bundle.best;
  double closestStreetDistance=Double.POSITIVE_INFINITY;
  if (candidate != null) {
    StreetEdge bestStreet=candidate.edge;
    Coordinate nearestPoint=candidate.nearestPointOnEdge;
    closestStreetDistance=candidate.getDistance();
    _log.debug("best street: {} dist: {}",bestStreet.toString(),closestStreetDistance);
    if (name == null) {
      name=bestStreet.getName();
    }
    String closestName=String.format("%s_%s",bestStreet.getName(),coordinate.toString());
    closestStreet=StreetLocation.createStreetLocation(graph,closestName,name,bundle.toEdgeList(),nearestPoint,coordinate);
  }
  if (closestStreet == null) {
    _log.debug("returning only transit stop (no street found)");
    return closest_stop;
  }
 else {
    if (closest_stop != null) {
      double relativeStopDistance=closest_stop_distance / closestStreetDistance;
      if (relativeStopDistance < 1.5) {
        _log.debug("linking transit stop to street (distances are comparable)");
        closestStreet.addExtraEdgeTo(closest_stop);
      }
    }
    _log.debug("returning split street");
    return closestStreet;
  }
}
