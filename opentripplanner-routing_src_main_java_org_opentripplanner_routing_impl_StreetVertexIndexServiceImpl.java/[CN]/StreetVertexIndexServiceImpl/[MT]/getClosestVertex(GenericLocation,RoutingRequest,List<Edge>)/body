{
  LOG.debug("Looking for/making a vertex near {}",location);
  Coordinate coord=location.getCoordinate();
  StreetVertex intersection=getIntersectionAt(coord,MAX_CORNER_DISTANCE);
  String calculatedName=location.getName();
  if (intersection != null) {
    if (!location.hasName()) {
      LOG.debug("found intersection {}. not splitting.",intersection);
      Set<String> uniqueNameSet=new HashSet<String>();
      for (      Edge e : intersection.getOutgoing()) {
        if (e instanceof StreetEdge) {
          uniqueNameSet.add(e.getName());
        }
      }
      List<String> uniqueNames=new ArrayList<String>(uniqueNameSet);
      Locale locale;
      if (options == null) {
        locale=new Locale("en");
      }
 else {
        locale=options.getLocale();
      }
      ResourceBundle resources=ResourceBundle.getBundle("internals",locale);
      String fmt=resources.getString("corner");
      if (uniqueNames.size() > 1) {
        calculatedName=String.format(fmt,uniqueNames.get(0),uniqueNames.get(1));
      }
 else       if (uniqueNames.size() == 1) {
        calculatedName=uniqueNames.get(0);
      }
 else {
        calculatedName=resources.getString("unnamedStreet");
      }
    }
    StreetLocation closest=new StreetLocation(graph,"corner " + Math.random(),coord,calculatedName);
    FreeEdge e=new FreeEdge(closest,intersection);
    closest.getExtra().add(e);
    e=new FreeEdge(intersection,closest);
    closest.getExtra().add(e);
    return closest;
  }
  double closestStopDistance=Double.POSITIVE_INFINITY;
  Vertex closestStop=null;
  if (options != null && options.getModes().isTransit()) {
    for (    Vertex v : getLocalTransitStops(coord,1000)) {
      double d=distanceLibrary.distance(v.getCoordinate(),coord);
      if (d < closestStopDistance) {
        closestStopDistance=d;
        closestStop=v;
      }
    }
  }
  LOG.debug(" best stop: {} distance: {}",closestStop,closestStopDistance);
  StreetLocation closestStreet=null;
  CandidateEdgeBundle bundle=getClosestEdges(location,options,extraEdges,null,false);
  CandidateEdge candidate=bundle.best;
  double closestStreetDistance=Double.POSITIVE_INFINITY;
  if (candidate != null) {
    StreetEdge bestStreet=candidate.edge;
    Coordinate nearestPoint=candidate.nearestPointOnEdge;
    closestStreetDistance=distanceLibrary.distance(coord,nearestPoint);
    LOG.debug("best street: {} dist: {}",bestStreet.toString(),closestStreetDistance);
    if (calculatedName == null || "".equals(calculatedName)) {
      calculatedName=bestStreet.getName();
    }
    String closestName=String.format("%s_%s",bestStreet.getName(),location.toString());
    closestStreet=StreetLocation.createStreetLocation(graph,closestName,calculatedName,bundle.toEdgeList(),nearestPoint,coord);
  }
  if (closestStreet == null) {
    LOG.debug("returning only transit stop (no street found)");
    return closestStop;
  }
 else {
    if (closestStop != null) {
      double relativeStopDistance=closestStopDistance / closestStreetDistance;
      if (relativeStopDistance < 1.5) {
        LOG.debug("linking transit stop to street (distances are comparable)");
        closestStreet.addExtraEdgeTo(closestStop);
      }
    }
    LOG.debug("returning split street");
    return closestStreet;
  }
}
