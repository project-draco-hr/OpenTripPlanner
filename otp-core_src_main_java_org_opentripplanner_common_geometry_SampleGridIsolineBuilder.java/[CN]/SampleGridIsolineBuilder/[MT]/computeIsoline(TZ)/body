{
  Queue<ZSamplePoint<TZ>> processQ=new ArrayDeque<ZSamplePoint<TZ>>(sampleGrid.size());
  for (  ZSamplePoint<TZ> A : sampleGrid) {
    IsoLineUserData iud=(IsoLineUserData)A.getUserData();
    if (iud == null) {
      iud=new IsoLineUserData();
      A.setUserData(iud);
    }
    iud.hProcessed=false;
    iud.vProcessed=false;
    processQ.add(A);
  }
  if (debug)   generateDebugGeometry(z0);
  List<LinearRing> rings=new ArrayList<LinearRing>();
  while (!processQ.isEmpty()) {
    ZSamplePoint<TZ> A=processQ.remove();
    IsoLineUserData uA=(IsoLineUserData)A.getUserData();
    if (uA.hProcessed && uA.vProcessed)     continue;
    boolean horizontal=!uA.hProcessed;
    if (horizontal) {
      uA.hProcessed=true;
    }
 else {
      uA.vProcessed=true;
    }
    if (!(uA.vProcessed && uA.hProcessed)) {
      processQ.add(A);
    }
    ZSamplePoint<TZ> B=horizontal ? A.right() : A.up();
    boolean ok=B != null;
    int cut=0;
    if (ok) {
      cut=zMetric.cut(A.getZ(),B.getZ(),z0);
      ok=(cut != 0);
    }
    if (!ok) {
      continue;
    }
    List<Coordinate> polyPoints=new ArrayList<Coordinate>();
    Direction direction=horizontal ? (cut > 0 ? Direction.UP : Direction.DOWN) : (cut > 0 ? Direction.LEFT : Direction.RIGHT);
    while (true) {
      Coordinate cA=sampleGrid.getCoordinates(A);
      Coordinate cB=sampleGrid.getCoordinates(B);
      double k=zMetric.interpolate(A.getZ(),B.getZ(),z0);
      Coordinate cC=new Coordinate(cA.x * (1.0 - k) + cB.x * k,cA.y * (1.0 - k) + cB.y * k);
      polyPoints.add(cC);
      horizontal=direction == Direction.UP || direction == Direction.DOWN;
      if (horizontal) {
        ((IsoLineUserData)A.getUserData()).hProcessed=true;
      }
 else {
        ((IsoLineUserData)A.getUserData()).vProcessed=true;
      }
      ZSamplePoint<TZ> C, D;
      Direction d1, d2;
      boolean invertAB;
switch (direction) {
default :
case UP:
        d1=Direction.LEFT;
      d2=Direction.RIGHT;
    B=A.right();
  C=B.up();
D=A.up();
invertAB=false;
break;
case DOWN:
d1=Direction.LEFT;
d2=Direction.RIGHT;
B=A.right();
C=B.down();
D=A.down();
invertAB=true;
break;
case LEFT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up();
C=B.left();
D=A.left();
invertAB=true;
break;
case RIGHT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up();
C=B.right();
D=A.right();
invertAB=false;
break;
}
boolean ok1=D != null && zMetric.cut(A.getZ(),D.getZ(),z0) != 0 && (horizontal ? (invertAB ? !((IsoLineUserData)D.getUserData()).vProcessed : !((IsoLineUserData)A.getUserData()).vProcessed) : (invertAB ? !((IsoLineUserData)D.getUserData()).hProcessed : !((IsoLineUserData)A.getUserData()).hProcessed));
boolean ok2=C != null && zMetric.cut(B.getZ(),C.getZ(),z0) != 0 && (horizontal ? (invertAB ? !((IsoLineUserData)C.getUserData()).vProcessed : !((IsoLineUserData)B.getUserData()).vProcessed) : (invertAB ? !((IsoLineUserData)C.getUserData()).hProcessed : !((IsoLineUserData)B.getUserData()).hProcessed));
boolean ok3=C != null && D != null && zMetric.cut(C.getZ(),D.getZ(),z0) != 0 && (horizontal ? !((IsoLineUserData)D.getUserData()).hProcessed : !((IsoLineUserData)D.getUserData()).vProcessed);
if (ok1 && ok2) {
double dA=Math.max(Math.abs(cA.x - cC.x),Math.abs(cA.y - cC.y));
double dB=Math.max(Math.abs(cB.x - cC.x),Math.abs(cB.y - cC.y));
if (dA <= dB) {
ZSamplePoint<TZ> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
}
 else if (ok1) {
ZSamplePoint<TZ> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else if (ok2) {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
 else if (ok3) {
A=D;
B=C;
}
 else {
break;
}
}
polyPoints.add(polyPoints.get(0));
if (polyPoints.size() > 5) {
LinearRing ring=geometryFactory.createLinearRing(polyPoints.toArray(new Coordinate[polyPoints.size()]));
rings.add(ring);
}
}
List<Polygon> retval=punchHoles(rings);
return geometryFactory.createGeometryCollection(retval.toArray(new Geometry[retval.size()]));
}
