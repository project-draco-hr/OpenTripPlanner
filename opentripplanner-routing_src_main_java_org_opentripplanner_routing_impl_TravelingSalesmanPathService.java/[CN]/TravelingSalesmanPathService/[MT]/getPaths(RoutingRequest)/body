{
  if (options.getIntermediatePlaces() == null || options.getIntermediatePlaces().size() == 0) {
    return chainedPathService.getPaths(options);
  }
  Graph graph=graphService.getGraph(options.getRouterId());
  long time=options.dateTime;
  options.setRoutingContext(graph);
  options.rctx.pathParsers=new PathParser[1];
  options.rctx.pathParsers[0]=new BasicPathParser();
  List<Vertex> vertices=options.rctx.intermediateVertices;
  vertices.add(options.rctx.toVertex);
  options.intermediatePlaces.clear();
  if (options.intermediatePlacesOrdered) {
    List<GraphPath> paths=new ArrayList<GraphPath>();
    Vertex previousVertex=options.rctx.fromVertex;
    for (    Vertex v : vertices) {
      options.dateTime=time;
      options.setRoutingContext(graph,previousVertex,v);
      List<GraphPath> partialPaths=chainedPathService.getPaths(options);
      if (partialPaths == null || partialPaths.size() == 0)       return null;
      GraphPath path=partialPaths.get(0);
      paths.add(path);
      previousVertex=v;
      time=path.getEndTime();
    }
    return Arrays.asList(joinPaths(paths));
  }
  Map<Vertex,HashMap<Vertex,GraphPath>> paths=new HashMap<Vertex,HashMap<Vertex,GraphPath>>();
  HashMap<Vertex,GraphPath> firstLegPaths=new HashMap<Vertex,GraphPath>();
  paths.put(options.rctx.fromVertex,firstLegPaths);
  for (  Vertex v : options.rctx.intermediateVertices) {
    options.dateTime=time;
    options.setRoutingContext(graph,options.rctx.fromVertex,v);
    List<GraphPath> partialPaths=chainedPathService.getPaths(options);
    if (partialPaths == null || partialPaths.size() == 0)     return null;
    firstLegPaths.put(v,partialPaths.get(0));
    HashMap<Vertex,GraphPath> outPaths=new HashMap<Vertex,GraphPath>();
    paths.put(v,outPaths);
    for (    Vertex tv : options.rctx.intermediateVertices) {
      if (v == tv)       continue;
      options.setRoutingContext(graph,options.rctx.fromVertex,tv);
      List<GraphPath> morePaths=chainedPathService.getPaths(options);
      if (!morePaths.isEmpty()) {
        outPaths.put(tv,morePaths.get(0));
      }
    }
    options.setRoutingContext(graph,v,options.rctx.toVertex);
    List<GraphPath> lastPaths=chainedPathService.getPaths(options);
    if (!lastPaths.isEmpty())     outPaths.put(options.rctx.toVertex,lastPaths.get(0));
  }
  HashSet<Vertex> verticesCopy=new HashSet<Vertex>();
  verticesCopy.addAll(options.rctx.intermediateVertices);
  return Arrays.asList(TSPPathFinder.findShortestPath(options.rctx.toVertex,options.rctx.fromVertex,paths,verticesCopy,time,options));
}
