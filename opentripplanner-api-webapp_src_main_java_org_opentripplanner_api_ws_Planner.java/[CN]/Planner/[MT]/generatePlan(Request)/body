{
  TraverseModeSet modeSet=request.getModeSet();
  assert(modeSet.isValid());
  TraverseOptions options=new TraverseOptions(modeSet);
  options.optimizeFor=request.getOptimize();
  options.back=request.isArriveBy();
  options.wheelchairAccessible=request.getWheelchair();
  List<GraphPath> paths=null;
  try {
    List<String> intermediates=request.getIntermediatePlaces();
    if (intermediates.size() == 0) {
      paths=pathservice.plan(request.getFrom(),request.getTo(),request.getDateTime(),options);
      if (paths == null) {
        paths=pathservice.plan(request.getFrom(),request.getTo(),request.getDateTime(),options);
      }
    }
 else {
      paths=pathservice.plan(request.getFrom(),request.getTo(),intermediates,request.getDateTime(),options);
    }
  }
 catch (  VertexNotFoundException e) {
    LOGGER.log(Level.INFO,"Vertex not found: " + request.getFrom() + " : "+ request.getTo(),e);
    Response response=new Response(request,null);
    response.error=new PlannerError(e.getMissing());
    return response;
  }
  if (paths == null || paths.size() == 0) {
    LOGGER.log(Level.INFO,"Path not found: " + request.getFrom() + " : "+ request.getTo());
    Response response=new Response(request,null);
    response.error=new PlannerError();
    return response;
  }
  Vector<SPTVertex> vertices=paths.get(0).vertices;
  SPTVertex tripStartVertex=vertices.firstElement();
  SPTVertex tripEndVertex=vertices.lastElement();
  Place from=new Place(tripStartVertex.getX(),tripStartVertex.getY(),request.getFrom());
  Place to=new Place(tripEndVertex.getX(),tripEndVertex.getY(),request.getTo());
  TripPlan plan=new TripPlan(from,to,request.getDateTime());
  for (  GraphPath path : paths) {
    Itinerary itinerary=new Itinerary();
    plan.addItinerary(itinerary);
    SPTVertex startVertex=path.vertices.firstElement();
    State startState=startVertex.state;
    SPTVertex endVertex=path.vertices.lastElement();
    State endState=endVertex.state;
    itinerary.startTime=new Date(startState.getTime());
    itinerary.endTime=new Date(endState.getTime());
    itinerary.duration=endState.getTime() - startState.getTime();
    itinerary.fare=new Fare();
    itinerary.fare.addFare(Fare.FareType.regular,Currency.getInstance("USD"),225);
    itinerary.transfers=-1;
    Leg leg=null;
    TraverseMode mode=null;
    Geometry geometry=null;
    String name=null;
    int startWalk=-1;
    int i=-1;
    SPTEdge lastEdge=null;
    for (    SPTEdge edge : path.edges) {
      i++;
      Edge graphEdge=edge.payload;
      if (graphEdge instanceof Turn) {
        continue;
      }
      lastEdge=edge;
      TraverseMode edgeMode=graphEdge.getMode();
      double edgeTime=edge.tov.state.getTime() - edge.fromv.state.getTime();
      if (!edgeMode.isTransit() && edgeMode != TraverseMode.ALIGHTING) {
        if (edgeMode != mode || (!mode.isOnStreetNonTransit() && graphEdge.getName() != name)) {
          name=graphEdge.getName();
          if (leg != null) {
            if (startWalk != -1) {
              leg.walkSteps=getWalkSteps(path.edges.subList(startWalk,i));
            }
            Vertex fromv=graphEdge.getFromVertex();
            Coordinate endCoord=fromv.getCoordinate();
            leg.to=new Place(endCoord.x,endCoord.y,fromv.getName());
            leg.to.stopId=fromv.getStopId();
            leg.endTime=new Date(edge.tov.state.getTime());
            leg.legGeometry=PolylineEncoder.createEncodings(geometry);
            leg.duration=edge.tov.state.getTime() - leg.startTime.getTime();
            leg=null;
            geometry=null;
          }
          leg=new Leg();
          itinerary.addLeg(leg);
          leg.startTime=new Date(edge.fromv.state.getTime());
          leg.route=graphEdge.getName();
          mode=graphEdge.getMode();
          leg.mode=mode.toString();
          if (mode == TraverseMode.WALK) {
            startWalk=i;
          }
 else {
            startWalk=-1;
          }
          leg.distance=edge.getDistance();
          Vertex fromv=graphEdge.getFromVertex();
          Coordinate endCoord=fromv.getCoordinate();
          leg.from=new Place(endCoord.x,endCoord.y,fromv.getName());
          leg.from.stopId=fromv.getStopId();
        }
      }
      Geometry edgeGeometry=graphEdge.getGeometry();
      if (geometry == null) {
        geometry=edgeGeometry;
      }
 else {
        if (edgeGeometry != null) {
          geometry=geometry.union(edgeGeometry);
        }
      }
      if (edgeMode == TraverseMode.TRANSFER) {
        itinerary.walkTime+=edgeTime;
        itinerary.walkDistance+=graphEdge.getDistance();
        continue;
      }
      if (edgeMode == TraverseMode.BOARDING) {
        itinerary.transfers++;
        itinerary.waitingTime+=edgeTime;
        continue;
      }
      if (edgeMode == TraverseMode.WALK) {
        itinerary.walkTime+=edgeTime;
        itinerary.walkDistance+=graphEdge.getDistance();
      }
      if (edgeMode.isTransit()) {
        itinerary.transitTime+=edgeTime;
        mode=graphEdge.getMode();
        leg.mode=mode.toString();
        leg.route=graphEdge.getName();
      }
    }
    Edge graphEdge=lastEdge.payload;
    if (leg != null) {
      Vertex tov=graphEdge.getToVertex();
      Coordinate endCoord=tov.getCoordinate();
      leg.to=new Place(endCoord.x,endCoord.y,tov.getName());
      leg.to.stopId=tov.getStopId();
      leg.endTime=new Date(lastEdge.tov.state.getTime());
      leg.legGeometry=PolylineEncoder.createEncodings(geometry);
      leg.duration=lastEdge.tov.state.getTime() - leg.startTime.getTime();
      if (startWalk != -1) {
        leg.walkSteps=getWalkSteps(path.edges.subList(startWalk,i + 1));
      }
      leg=null;
    }
    if (itinerary.transfers == -1) {
      itinerary.transfers=0;
    }
  }
  Response response=new Response(request,plan);
  return response;
}
