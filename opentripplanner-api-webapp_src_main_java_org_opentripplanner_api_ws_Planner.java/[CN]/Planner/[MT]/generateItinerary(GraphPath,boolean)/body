{
  Itinerary itinerary=makeEmptyItinerary(path);
  Leg leg=null;
  Edge edge=null;
  EdgeNarrative edgeNarrative=null;
  TraverseMode mode=null;
  TraverseMode previousMode=null;
  SPTEdge previousSptEdge=null;
  CoordinateArrayListSequence coordinates=new CoordinateArrayListSequence();
  SPTEdge finalSptEdge=path.edges.lastElement();
  double previousElevation=Double.MAX_VALUE;
  double edgeElapsedTime;
  GeometryFactory geometryFactory=new GeometryFactory();
  int startWalk=-1;
  int i=-1;
  for (  SPTEdge sptEdge : path.edges) {
    i++;
    edge=sptEdge.payload;
    edgeNarrative=sptEdge.narrative;
    if (edge instanceof FreeEdge && sptEdge != finalSptEdge) {
      continue;
    }
    mode=edgeNarrative.getMode();
    edgeElapsedTime=sptEdge.tov.state.getTime() - sptEdge.fromv.state.getTime();
    if (mode != previousMode) {
      previousMode=mode;
      if (mode == TraverseMode.TRANSFER) {
        itinerary.walkTime+=edgeElapsedTime;
        itinerary.walkDistance+=edgeNarrative.getDistance();
        continue;
      }
 else       if (mode == TraverseMode.BOARDING) {
        itinerary.transfers++;
        itinerary.waitingTime+=edgeElapsedTime;
        continue;
      }
 else       if (mode == TraverseMode.ALIGHTING) {
        itinerary.waitingTime+=edgeElapsedTime;
        continue;
      }
 else {
        if (leg != null) {
          if (startWalk != -1) {
            leg.walkSteps=getWalkSteps(path.edges.subList(startWalk,i));
          }
          leg.to=makePlace(edgeNarrative.getFromVertex());
          leg.endTime=new Date(previousSptEdge.tov.state.getTime());
          Geometry geometry=geometryFactory.createLineString(coordinates);
          leg.legGeometry=PolylineEncoder.createEncodings(geometry);
          coordinates=new CoordinateArrayListSequence();
        }
        leg=makeLeg(sptEdge);
        leg.mode=mode.toString();
        if (mode.isOnStreetNonTransit()) {
          startWalk=i;
        }
 else {
          startWalk=-1;
          leg.route=edgeNarrative.getName();
        }
        itinerary.addLeg(leg);
      }
    }
    leg.distance+=sptEdge.getDistance();
    Geometry edgeGeometry=edgeNarrative.getGeometry();
    if (edgeGeometry != null) {
      Coordinate[] edgeCoordinates=edgeGeometry.getCoordinates();
      if (coordinates.size() > 0 && coordinates.getCoordinate(coordinates.size() - 1).equals(edgeCoordinates[0])) {
        coordinates.extend(edgeCoordinates,1);
      }
 else {
        coordinates.extend(edgeCoordinates);
      }
    }
    if (mode.isOnStreetNonTransit()) {
      itinerary.walkTime+=edgeElapsedTime;
      itinerary.walkDistance+=edgeNarrative.getDistance();
      if (edge instanceof EdgeWithElevation) {
        PackedCoordinateSequence profile=((EdgeWithElevation)edge).getElevationProfile();
        previousElevation=applyElevation(profile,itinerary,previousElevation);
      }
    }
 else     if (mode.isTransit()) {
      itinerary.transitTime+=edgeElapsedTime;
      if (showIntermediateStops) {
        if (leg.stop == null) {
          leg.stop=new ArrayList<Place>();
        }
 else {
          Place stop=makePlace(sptEdge.fromv.mirror);
          leg.stop.add(stop);
        }
      }
    }
    previousSptEdge=sptEdge;
  }
  if (leg != null) {
    leg.to=makePlace(edgeNarrative.getToVertex());
    leg.endTime=new Date(previousSptEdge.tov.state.getTime());
    Geometry geometry=geometryFactory.createLineString(coordinates);
    leg.legGeometry=PolylineEncoder.createEncodings(geometry);
    if (startWalk != -1) {
      leg.walkSteps=getWalkSteps(path.edges.subList(startWalk,i + 1));
    }
  }
  if (itinerary.transfers == -1) {
    itinerary.transfers=0;
  }
  itinerary.removeBogusLegs();
  return itinerary;
}
