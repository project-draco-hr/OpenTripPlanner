{
  PathOptions opts=new PathOptions();
  opts.setNum_paths(1);
  opts.setReturn_detailed_path(true);
  TripParameters trip=new TripParameters();
  trip.addToAllowed_modes(TravelMode.CAR);
  P2<Location> pair=pickOriginAndDest();
  trip.setOrigin(pair.getFirst());
  trip.setDestination(pair.getSecond());
  FindPathsRequest req=new FindPathsRequest();
  req.setOptions(opts);
  req.setTrip(trip);
  req.validate();
  FindPathsResponse res=serviceImpl.FindPaths(req);
  TripPaths paths=res.getPaths();
  while (paths.getPaths().isEmpty()) {
    pair=pickOriginAndDest();
    trip.setOrigin(pair.getFirst());
    trip.setDestination(pair.getSecond());
    res=serviceImpl.FindPaths(req);
    paths=res.getPaths();
  }
  assertEquals(1,paths.getPathsSize());
  Path p=paths.getPaths().get(0);
  checkPath(p);
  int expectedTotalDuration=p.getDuration();
  int subPathDurations=0;
  for (int i=1; i < p.getStatesSize(); ++i) {
    TravelState firstState=p.getStates().get(i - 1);
    TravelState secondState=p.getStates().get(i);
    Location startLoc=getLocationForTravelState(firstState);
    Location endLoc=getLocationForTravelState(secondState);
    trip.setOrigin(startLoc);
    trip.setDestination(endLoc);
    req=new FindPathsRequest();
    req.setOptions(opts);
    req.setTrip(trip);
    req.validate();
    res=serviceImpl.FindPaths(req);
    paths=res.getPaths();
    assertEquals(1,paths.getPathsSize());
    Path subPath=paths.getPaths().get(0);
    checkPath(subPath);
    subPathDurations+=subPath.getDuration();
  }
  assertTrue(subPathDurations <= expectedTotalDuration);
}
