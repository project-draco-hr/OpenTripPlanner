{
  long currentTime=state0.getTime();
  Date serviceDate=getServiceDate(currentTime,wo.calendar);
  Date serviceDateYesterday=getServiceDate(currentTime - MILLI_IN_DAY,wo.calendar);
  int secondsSinceMidnight=(int)((currentTime - serviceDate.getTime()) / 1000);
  int wait=-1;
  int patternIndex=-1;
  AgencyAndId service=pattern.exemplar.getServiceId();
  if (wo.serviceOn(service,serviceDate)) {
    patternIndex=pattern.getNextPattern(stopIndex,secondsSinceMidnight);
    if (patternIndex >= 0) {
      wait=pattern.getDepartureTime(stopIndex,patternIndex) - secondsSinceMidnight;
    }
  }
  if (wo.serviceOn(service,serviceDateYesterday)) {
    int yesterdayPatternIndex=pattern.getNextPattern(stopIndex,secondsSinceMidnight - SEC_IN_DAY);
    if (yesterdayPatternIndex >= 0) {
      int waitYesterday=pattern.getDepartureTime(stopIndex,yesterdayPatternIndex) - (secondsSinceMidnight - SEC_IN_DAY);
      if (wait < 0 || waitYesterday < wait) {
        wait=waitYesterday;
        patternIndex=yesterdayPatternIndex;
      }
    }
  }
  if (wait < 0) {
    return null;
  }
  State state1=state0.clone();
  state1.setPattern(patternIndex);
  state1.incrementTimeInSeconds(back ? -wait : wait);
  return new TraverseResult(wait,state1);
}
