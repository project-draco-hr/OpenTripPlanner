{
  Set<RaptorStop> visitedLastRound=cur.visitedLastRound;
  Set<RaptorRoute> routesToVisit=new HashSet<RaptorRoute>();
  for (  RaptorStop stop : visitedLastRound) {
    for (    RaptorRoute route : routesForStop[stop.index]) {
      routesToVisit.add(route);
    }
  }
  cur.visitedLastRound=new HashSet<RaptorStop>();
  List<RaptorState>[] statesByStop=cur.getStates();
  List<RaptorState> createdStates=new ArrayList<RaptorState>();
  System.out.println("Round " + nBoardings);
  for (  RaptorRoute route : routesToVisit) {
    List<RaptorState> boardStates=new ArrayList<RaptorState>();
    boolean started=false;
    for (int stopNo=0; stopNo < route.getNStops(); ++stopNo) {
      RaptorStop stop=route.stops[stopNo];
      if (!started && !visitedLastRound.contains(stop))       continue;
      started=true;
      List<RaptorState> states=statesByStop[stop.index];
      List<RaptorState> newStates=new ArrayList<RaptorState>();
      if (states == null) {
        states=new ArrayList<RaptorState>();
        statesByStop[stop.index]=states;
      }
      CONTINUE:       for (      RaptorState boardState : boardStates) {
        RaptorState newState=new RaptorState();
        ServiceDay sd=boardState.serviceDay;
        int alightTime=route.getAlightTime(boardState.patternIndex,boardState.tripIndex,stopNo);
        newState.arrivalTime=(int)sd.time(alightTime);
        newState.boardStop=boardState.boardStop;
        newState.boardStopSequence=boardState.boardStopSequence;
        newState.route=route;
        newState.patternIndex=boardState.patternIndex;
        newState.tripIndex=boardState.tripIndex;
        newState.nBoardings=boardState.nBoardings;
        newState.walkDistance=boardState.walkDistance;
        newState.parent=boardState.parent;
        newState.stop=stop;
        for (        RaptorState oldState : states) {
          if (eDominates(oldState,newState)) {
            continue CONTINUE;
          }
        }
        for (        RaptorState oldState : newStates) {
          if (oldState != newState && eDominates(oldState,newState)) {
            continue CONTINUE;
          }
        }
        cur.visitedLastRound.add(stop);
        cur.visitedEver.add(stop);
        newStates.add(newState);
      }
      if (newStates.size() > 10) {
      }
      if (stopNo < route.getNStops() - 1) {
        TRYBOARD:         for (        RaptorState oldState : states) {
          if (oldState.nBoardings != nBoardings - 1)           continue;
          if (oldState.route == route)           continue;
          RaptorBoardSpec boardSpec=route.getTripIndex(options,oldState.arrivalTime,stopNo);
          if (boardSpec == null)           continue;
          RaptorState boardState=new RaptorState();
          boardState.nBoardings=nBoardings;
          boardState.boardStop=stop;
          boardState.boardStopSequence=stopNo;
          boardState.arrivalTime=boardSpec.departureTime;
          boardState.patternIndex=boardSpec.patternIndex;
          boardState.tripIndex=boardSpec.tripIndex;
          boardState.parent=oldState;
          boardState.serviceDay=boardSpec.serviceDay;
          boardState.route=route;
          boardState.walkDistance=oldState.walkDistance;
          for (          RaptorState state : newStates) {
            if (eDominates(state,boardState)) {
              continue TRYBOARD;
            }
          }
          for (          RaptorState state : states) {
            if (state != oldState && eDominates(state,boardState)) {
              continue TRYBOARD;
            }
          }
          boardStates.add(boardState);
        }
      }
      createdStates.addAll(newStates);
      states.addAll(newStates);
    }
  }
  ShortestPathTree spt;
  GenericDijkstra dijkstra=new GenericDijkstra(walkOptions);
  if (nBoardings == 0) {
    State start=new MaxWalkState(options.rctx.origin,walkOptions);
    spt=dijkstra.getShortestPathTree(start);
    final List<? extends State> targetStates=spt.getStates(walkOptions.rctx.target);
    if (targetStates != null) {
      for (      State targetState : targetStates) {
        RaptorState state=new RaptorState();
        RaptorState parent=(RaptorState)targetState.getExtension("raptorParent");
        state.parent=parent;
        state.walkDistance=targetState.getWalkDistance();
        state.arrivalTime=(int)targetState.getTime();
        if (parent != null) {
          state.nBoardings=parent.nBoardings;
          state.waitingTime=parent.waitingTime;
        }
        state.walkPath=targetState;
        cur.addTargetState(state);
        System.out.println("TARGET: " + state);
      }
    }
    SPTSTATE:     for (    State state : spt.getAllStates()) {
      final Vertex vertex=state.getVertex();
      if (!(vertex instanceof TransitStop))       continue;
      RaptorStop stop=raptorStopsForStopId.get(((TransitStop)vertex).getStopId());
      if (stop == null) {
        continue;
      }
      cur.visitedLastRound.add(stop);
      cur.visitedEver.add(stop);
      List<RaptorState> states=statesByStop[stop.index];
      if (states == null) {
        states=new ArrayList<RaptorState>();
        statesByStop[stop.index]=states;
      }
      RaptorState baseState=(RaptorState)state.getExtension("raptorParent");
      RaptorState newState=new RaptorState();
      if (baseState != null) {
        newState.nBoardings=baseState.nBoardings;
      }
      newState.walkDistance=state.getWalkDistance();
      newState.arrivalTime=(int)state.getTime();
      newState.walkPath=state;
      newState.parent=baseState;
      newState.stop=stop;
      for (      RaptorState oldState : states) {
        if (eDominates(oldState,newState)) {
          continue SPTSTATE;
        }
      }
      Vertex dest=options.rctx.target;
      double minWalk=dest.getDistanceToNearestTransitStop();
      double minWalkTime=minWalk / options.getSpeedUpperBound();
      if (newState.walkDistance + minWalk > options.getMaxWalkDistance())       continue SPTSTATE;
      for (      RaptorState oldState : cur.getTargetStates()) {
        if (oldState.arrivalTime <= newState.arrivalTime + minWalkTime && oldState.walkDistance <= newState.walkDistance + minWalk)         continue SPTSTATE;
      }
      states.add(newState);
    }
  }
 else {
    TransitLocalStreetService service=options.rctx.graph.getService(TransitLocalStreetService.class);
    HashMap<Vertex,HashMap<Vertex,T2<Double,Integer>>> costs=service.getCosts();
    for (    RaptorState state : createdStates) {
      Vertex fromv=state.stop.stopVertex;
      HashMap<Vertex,T2<Double,Integer>> costsForVertex=costs.get(fromv);
      WALKEDTO:       for (      Map.Entry<Vertex,T2<Double,Integer>> entry : costsForVertex.entrySet()) {
        T2<Double,Integer> costsForWalk=entry.getValue();
        double walk=costsForWalk.getFirst() + state.walkDistance;
        if (walk > options.getMaxWalkDistance())         continue;
        int time=costsForWalk.getSecond() + state.arrivalTime;
        RaptorState newState=new RaptorState();
        newState.walkDistance=walk;
        newState.nBoardings=state.nBoardings;
        newState.arrivalTime=time;
        TransitStop tov=(TransitStop)entry.getKey();
        RaptorStop dest=raptorStopsForStopId.get(tov.getStopId());
        if (dest == null) {
          continue;
        }
        List<RaptorState> states=statesByStop[dest.index];
        if (states == null) {
          states=new ArrayList<RaptorState>();
        }
        for (        RaptorState oldState : states) {
          if (eDominates(oldState,state)) {
            continue WALKEDTO;
          }
        }
        newState.parent=state;
        state.stop=dest;
        state.tripIndex=-2;
        cur.visitedLastRound.add(dest);
        cur.visitedEver.add(dest);
      }
    }
  }
  for (int stop=0; stop < statesByStop.length; ++stop) {
    cur.setStates(stop,statesByStop[stop]);
  }
}
