{
  if (!canTraverse(options)) {
    if (options.getModes().contains(TraverseMode.BICYCLE)) {
      return doTraverse(s0,options.getWalkingOptions());
    }
    return null;
  }
  double time=length / options.speed;
  double weight;
  if (options.wheelchairAccessible) {
    weight=getSlopeSpeedEffectiveLength() / options.speed;
  }
 else   if (options.getModes().contains(TraverseMode.BICYCLE)) {
switch (options.optimizeFor) {
case SAFE:
      weight=bicycleSafetyEffectiveLength / options.speed;
    break;
case GREENWAYS:
  weight=bicycleSafetyEffectiveLength / options.speed;
if (bicycleSafetyEffectiveLength / length <= StreetVertex.GREENWAY_SAFETY_FACTOR) {
  weight*=0.66;
}
break;
case FLAT:
weight=length / options.speed + slopeWorkCost;
break;
case QUICK:
weight=slopeSpeedEffectiveLength / options.speed;
break;
case TRIANGLE:
double quick=slopeSpeedEffectiveLength / options.speed;
double safety=bicycleSafetyEffectiveLength / options.speed;
double slope=slopeWorkCost;
weight=quick * options.triangleTimeFactor + slope * options.triangleSlopeFactor + safety * options.triangleSafetyFactor;
break;
default :
weight=length / options.speed;
}
}
 else {
weight=time;
}
weight*=options.walkReluctance;
EdgeNarrative en=new FixedModeEdge(this,options.getModes().getNonTransitMode());
StateEditor s1=s0.edit(this,en);
switch (s0.getNoThruTrafficState()) {
case INIT:
if (isNoThruTraffic()) {
s1.setNoThruTrafficState(NoThruTrafficState.IN_INITIAL_ISLAND);
}
 else {
s1.setNoThruTrafficState(NoThruTrafficState.BETWEEN_ISLANDS);
}
break;
case IN_INITIAL_ISLAND:
if (!isNoThruTraffic()) {
s1.setNoThruTrafficState(NoThruTrafficState.BETWEEN_ISLANDS);
}
break;
case BETWEEN_ISLANDS:
if (isNoThruTraffic()) {
s1.setNoThruTrafficState(NoThruTrafficState.IN_FINAL_ISLAND);
}
break;
case IN_FINAL_ISLAND:
if (!isNoThruTraffic()) {
return null;
}
break;
}
s1.incrementWalkDistance(length);
s1.incrementTimeInSeconds((int)Math.ceil(time));
s1.incrementWeight(weight);
if (s1.weHaveWalkedTooFar(options)) return null;
return s1.makeState();
}
