{
  Edge backEdge=s0.getBackEdge();
  if (backEdge != null && (options.arriveBy ? (backEdge.getToVertex() == fromv) : (backEdge.getFromVertex() == tov))) {
    return null;
  }
  if (!canTraverse(options,traverseMode)) {
    if (traverseMode == TraverseMode.BICYCLE) {
      return doTraverse(s0,options.getWalkingOptions(),TraverseMode.WALK);
    }
    return null;
  }
  double speed;
  if (traverseMode == TraverseMode.CAR)   speed=this.calculateCarSpeed(options);
 else   speed=options.getSpeed(traverseMode);
  double time=length / speed;
  double weight;
  if (options.wheelchairAccessible) {
    weight=elevationProfileSegment.getSlopeSpeedEffectiveLength() / speed;
  }
 else   if (traverseMode.equals(TraverseMode.BICYCLE)) {
    time=elevationProfileSegment.getSlopeSpeedEffectiveLength() / speed;
switch (options.optimize) {
case SAFE:
      weight=elevationProfileSegment.getBicycleSafetyEffectiveLength() / speed;
    break;
case GREENWAYS:
  weight=elevationProfileSegment.getBicycleSafetyEffectiveLength() / speed;
if (elevationProfileSegment.getBicycleSafetyEffectiveLength() / length <= GREENWAY_SAFETY_FACTOR) {
  weight*=0.66;
}
break;
case FLAT:
weight=length / speed + elevationProfileSegment.getSlopeWorkCost();
break;
case QUICK:
weight=elevationProfileSegment.getSlopeSpeedEffectiveLength() / speed;
break;
case TRIANGLE:
double quick=elevationProfileSegment.getSlopeSpeedEffectiveLength();
double safety=elevationProfileSegment.getBicycleSafetyEffectiveLength();
double slope=elevationProfileSegment.getSlopeWorkCost();
weight=quick * options.getTriangleTimeFactor() + slope * options.getTriangleSlopeFactor() + safety * options.getTriangleSafetyFactor();
weight/=speed;
break;
default :
weight=length / speed;
}
}
 else {
if (options.isWalkingBike()) {
time=elevationProfileSegment.getSlopeSpeedEffectiveLength() / speed;
}
weight=time;
}
if (isStairs()) {
weight*=options.stairsReluctance;
}
 else {
weight*=options.walkReluctance;
}
StateEditor s1=s0.edit(this);
s1.setBackMode(traverseMode);
if (wheelchairNotes != null && options.wheelchairAccessible) {
s1.addAlerts(wheelchairNotes);
}
PlainStreetEdge backPSE;
if (backEdge != null && backEdge instanceof PlainStreetEdge) {
backPSE=(PlainStreetEdge)backEdge;
float backSpeed=(float)(traverseMode == TraverseMode.CAR ? backPSE.getCarSpeed() : options.getSpeed(traverseMode));
final double realTurnCost;
if (options.arriveBy && tov instanceof IntersectionVertex) {
if (!canTurnOnto(backPSE,s0,traverseMode)) return null;
realTurnCost=((IntersectionVertex)tov).computeTraversalCost(this,backPSE,traverseMode,options,(float)speed,backSpeed);
}
 else if (fromv instanceof IntersectionVertex) {
if (!backPSE.canTurnOnto(this,s0,traverseMode)) return null;
realTurnCost=((IntersectionVertex)fromv).computeTraversalCost(backPSE,this,traverseMode,options,backSpeed,(float)speed);
}
 else {
realTurnCost=0;
}
if (traverseMode != TraverseMode.CAR) s1.incrementWalkDistance(realTurnCost / 100);
weight+=realTurnCost;
long turnTime=(long)realTurnCost;
if (turnTime != realTurnCost) {
turnTime++;
}
time+=turnTime;
}
s1.incrementWalkDistance(length);
int timeLong=(int)time;
if (timeLong != time) {
timeLong++;
}
s1.incrementTimeInSeconds(timeLong);
if (traverseMode != TraverseMode.CAR) s1.incrementWalkDistance(length);
s1.incrementWeight(weight);
if (s1.weHaveWalkedTooFar(options)) return null;
s1.addAlerts(notes);
if (this.toll && traverseMode == TraverseMode.CAR) s1.addAlert(Alert.createSimpleAlerts("Toll road"));
return s1.makeState();
}
