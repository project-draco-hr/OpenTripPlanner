{
  List<Coordinate> initialPoints=Lists.newArrayList();
  final Graph graph=server.graphService.getGraph(surf.routerId);
  for (  StreetVertex sv : Iterables.filter(graph.getVertices(),StreetVertex.class)) {
    if (surf.getTime(sv) != TimeSurface.UNREACHABLE)     initialPoints.add(sv.getCoordinate());
  }
  RecursiveGridIsolineBuilder.ZFunc timeFunc=new RecursiveGridIsolineBuilder.ZFunc(){
    @Override public long z(    Coordinate c){
      Sample sample=graph.getSampleFactory().getSample(c.x,c.y);
      if (sample == null)       return Long.MAX_VALUE;
      Long z=sample.eval(surf);
      return z;
    }
  }
;
  Coordinate center=new Coordinate(surf.lon,surf.lat);
  double gridSizeMeters=400;
  double dY=Math.toDegrees(gridSizeMeters / SphericalDistanceLibrary.RADIUS_OF_EARTH_IN_M);
  double dX=dY / Math.cos(Math.toRadians(center.x));
  RecursiveGridIsolineBuilder isolineBuilder=new RecursiveGridIsolineBuilder(dX,dY,center,timeFunc,initialPoints);
  List<IsochroneData> isochrones=new ArrayList<IsochroneData>();
  for (  int cutoff : cutoffs) {
    int cutoffSec=cutoff * 60;
    Geometry isoline=isolineBuilder.computeIsoline(cutoffSec);
    IsochroneData isochrone=new IsochroneData(cutoffSec,isoline);
    isochrones.add(isochrone);
  }
  return isochrones;
}
