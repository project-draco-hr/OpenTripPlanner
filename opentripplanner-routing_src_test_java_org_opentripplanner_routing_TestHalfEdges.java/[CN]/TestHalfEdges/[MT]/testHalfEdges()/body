{
  HashSet<Edge> turns=new HashSet<Edge>(graph.getOutgoing(left));
  turns.addAll(graph.getOutgoing(leftBack));
  StreetLocation start=StreetLocation.createStreetLocation("start","start",cast(turns,StreetEdge.class),new LinearLocation(0,0.4).getCoordinate(left.getGeometry()));
  HashSet<Edge> endTurns=new HashSet<Edge>(graph.getOutgoing(right));
  endTurns.addAll(graph.getOutgoing(rightBack));
  StreetLocation end=StreetLocation.createStreetLocation("end","end",cast(endTurns,StreetEdge.class),new LinearLocation(0,0.8).getCoordinate(right.getGeometry()));
  assertTrue(start.getX() < end.getX());
  assertTrue(start.getY() < end.getY());
  List<DirectEdge> extra=end.getExtra();
  assertEquals(12,extra.size());
  GregorianCalendar startTime=new GregorianCalendar(2009,11,1,12,34,25);
  ShortestPathTree spt1=AStar.getShortestPathTree(graph,brOut,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath pathBr=spt1.getPath(end);
  assertNotNull("There must be a path from br to end",pathBr);
  ShortestPathTree spt2=AStar.getShortestPathTree(graph,trOut,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath pathTr=spt2.getPath(end);
  assertNotNull("There must be a path from tr to end",pathTr);
  assertTrue("path from bottom to end must be longer than path from top to end",pathBr.vertices.lastElement().weightSum > pathTr.vertices.lastElement().weightSum);
  ShortestPathTree spt=AStar.getShortestPathTree(graph,start,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath path=spt.getPath(end);
  assertNotNull("There must be a path from start to end",path);
  for (  SPTVertex v : path.vertices) {
    assertNotSame(v.mirror,graph.getVertex("bottom"));
    assertNotSame(v.mirror,graph.getVertex("bottomBack"));
  }
  startTime=new GregorianCalendar(2009,11,1,12,34,25);
  TraverseOptions options=new TraverseOptions();
  options.setArriveBy(true);
  spt=AStar.getShortestPathTreeBack(graph,start,end,new State(startTime.getTimeInMillis()),options);
  path=spt.getPath(start);
  assertNotNull("There must be a path from start to end (looking back)",path);
  for (  SPTVertex v : path.vertices) {
    assertNotSame(v.mirror,graph.getVertex("bottom"));
    assertNotSame(v.mirror,graph.getVertex("bottomBack"));
  }
}
