{
  TraverseOptions options=new TraverseOptions();
  HashSet<Edge> turns=new HashSet<Edge>(graph.getOutgoing(left));
  turns.addAll(graph.getOutgoing(leftBack));
  StreetLocation start=StreetLocation.createStreetLocation("start","start",cast(turns,StreetEdge.class),new LinearLocation(0,0.4).getCoordinate(left.getGeometry()));
  HashSet<Edge> endTurns=new HashSet<Edge>(graph.getOutgoing(right));
  endTurns.addAll(graph.getOutgoing(rightBack));
  StreetLocation end=StreetLocation.createStreetLocation("end","end",cast(endTurns,StreetEdge.class),new LinearLocation(0,0.8).getCoordinate(right.getGeometry()));
  assertTrue(start.getX() < end.getX());
  assertTrue(start.getY() < end.getY());
  List<DirectEdge> extra=end.getExtra();
  assertEquals(12,extra.size());
  GregorianCalendar startTime=new GregorianCalendar(2009,11,1,12,34,25);
  ShortestPathTree spt1=AStar.getShortestPathTree(graph,brOut,end,TestUtils.toSeconds(startTime),options);
  GraphPath pathBr=spt1.getPath(end,false);
  assertNotNull("There must be a path from br to end",pathBr);
  ShortestPathTree spt2=AStar.getShortestPathTree(graph,trOut,end,TestUtils.toSeconds(startTime),options);
  GraphPath pathTr=spt2.getPath(end,false);
  assertNotNull("There must be a path from tr to end",pathTr);
  assertTrue("path from bottom to end must be longer than path from top to end",pathBr.getWeight() > pathTr.getWeight());
  ShortestPathTree spt=AStar.getShortestPathTree(graph,start,end,TestUtils.toSeconds(startTime),options);
  GraphPath path=spt.getPath(end,false);
  assertNotNull("There must be a path from start to end",path);
  for (  State s : path.states) {
    assertNotSame(s.getVertex(),graph.getVertex("bottom"));
    assertNotSame(s.getVertex(),graph.getVertex("bottomBack"));
  }
  startTime=new GregorianCalendar(2009,11,1,12,34,25);
  options.setArriveBy(true);
  spt=AStar.getShortestPathTree(graph,start,end,TestUtils.toSeconds(startTime),options);
  path=spt.getPath(start,false);
  assertNotNull("There must be a path from start to end (looking back)",path);
  for (  State s : path.states) {
    assertNotSame(s.getVertex(),graph.getVertex("bottom"));
    assertNotSame(s.getVertex(),graph.getVertex("bottomBack"));
  }
  options=new TraverseOptions(new TraverseModeSet(TraverseMode.BICYCLE));
  start=StreetLocation.createStreetLocation("start1","start1",cast(turns,StreetEdge.class),new LinearLocation(0,0.95).getCoordinate(top.getGeometry()));
  end=StreetLocation.createStreetLocation("end1","end1",cast(turns,StreetEdge.class),new LinearLocation(0,0.95).getCoordinate(bottom.getGeometry()));
  spt=AStar.getShortestPathTree(graph,start,end,TestUtils.toSeconds(startTime),options);
  path=spt.getPath(start,false);
  assertNotNull("There must be a path from top to bottom along the right",path);
  for (  State s : path.states) {
    assertNotSame(s.getVertex(),graph.getVertex("left"));
    assertNotSame(s.getVertex(),graph.getVertex("leftBack"));
  }
  start=StreetLocation.createStreetLocation("start2","start2",cast(turns,StreetEdge.class),new LinearLocation(0,0.55).getCoordinate(top.getGeometry()));
  end=StreetLocation.createStreetLocation("end2","end2",cast(turns,StreetEdge.class),new LinearLocation(0,0.55).getCoordinate(bottom.getGeometry()));
  spt=AStar.getShortestPathTree(graph,start,end,TestUtils.toSeconds(startTime),options);
  path=spt.getPath(start,false);
  assertNotNull("There must be a path from top to bottom",path);
  for (  State s : path.states) {
    assertNotSame(s.getVertex(),graph.getVertex("right"));
    assertNotSame(s.getVertex(),graph.getVertex("rightBack"));
  }
}
