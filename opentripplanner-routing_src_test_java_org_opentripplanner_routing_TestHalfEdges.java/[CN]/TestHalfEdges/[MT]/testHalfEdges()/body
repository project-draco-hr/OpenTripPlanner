{
  HashSet<Edge> turns=new HashSet<Edge>(graph.getOutgoing(left));
  turns.addAll(graph.getOutgoing(leftBack));
  StreetLocation start=StreetLocation.createStreetLocation(graph,"start","start",turns,new LinearLocation(0,0.4).getCoordinate(left.getGeometry()));
  HashSet<Edge> endTurns=new HashSet<Edge>(graph.getOutgoing(right));
  endTurns.addAll(graph.getOutgoing(rightBack));
  StreetLocation end=StreetLocation.createStreetLocation(graph,"end","end",endTurns,new LinearLocation(0,0.8).getCoordinate(right.getGeometry()));
  assertTrue(start.getX() < end.getX());
  assertTrue(start.getY() < end.getY());
  ArrayList<Edge> extra=new ArrayList<Edge>();
  for (  Edge e : end.getExtra()) {
    extra.add(e);
  }
  assertEquals(12,extra.size());
  GregorianCalendar startTime=new GregorianCalendar(2009,11,1,12,34,25);
  ShortestPathTree spt1=AStar.getShortestPathTree(graph,brOut,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath pathBr=spt1.getPath(end);
  assertNotNull("There must be a path from br to end",pathBr);
  ShortestPathTree spt2=AStar.getShortestPathTree(graph,trOut,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath pathTr=spt2.getPath(end);
  assertNotNull("There must be a path from tr to end",pathTr);
  assertTrue("path from bottom to end must be longer than path from top to end",pathBr.vertices.lastElement().weightSum > pathTr.vertices.lastElement().weightSum);
  ShortestPathTree spt=AStar.getShortestPathTree(graph,start,end,new State(startTime.getTimeInMillis()),new TraverseOptions());
  GraphPath path=spt.getPath(end);
  assertNotNull("There must be a path from start to end",path);
  for (  SPTVertex v : path.vertices) {
    assertNotSame(v.mirror,graph.getVertex("bottom"));
    assertNotSame(v.mirror,graph.getVertex("bottomBack"));
  }
  startTime=new GregorianCalendar(2009,11,1,12,34,25);
  TraverseOptions options=new TraverseOptions();
  options.back=true;
  spt=AStar.getShortestPathTreeBack(graph,start,end,new State(startTime.getTimeInMillis()),options);
  path=spt.getPath(start);
  assertNotNull("There must be a path from start to end (looking back)",path);
  for (  SPTVertex v : path.vertices) {
    assertNotSame(v.mirror,graph.getVertex("bottom"));
    assertNotSame(v.mirror,graph.getVertex("bottomBack"));
  }
}
