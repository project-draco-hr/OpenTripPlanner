{
  TraverseMode traverseMode=s0.getNonTransitMode(options);
  if (turnRestricted(traverseMode) && !options.getModes().contains(TraverseMode.WALK)) {
    return null;
  }
  if (!((TurnVertex)fromv).canTraverse(options,traverseMode)) {
    if (traverseMode == TraverseMode.BICYCLE) {
      return doTraverse(s0,options.getWalkingOptions());
    }
    return null;
  }
  StateEditor s1=s0.edit(this);
  s1.setBackMode(traverseMode);
  Set<Alert> wheelchairNotes=((TurnVertex)fromv).getWheelchairNotes();
  if (options.wheelchairAccessible) {
    s1.addAlerts(wheelchairNotes);
  }
switch (s0.getNoThruTrafficState()) {
case INIT:
    if (((TurnVertex)fromv).isNoThruTraffic()) {
      s1.setNoThruTrafficState(NoThruTrafficState.IN_INITIAL_ISLAND);
    }
 else {
      s1.setNoThruTrafficState(NoThruTrafficState.BETWEEN_ISLANDS);
    }
  break;
case IN_INITIAL_ISLAND:
if (!((TurnVertex)fromv).isNoThruTraffic()) {
  s1.setNoThruTrafficState(NoThruTrafficState.BETWEEN_ISLANDS);
}
break;
case BETWEEN_ISLANDS:
if (((TurnVertex)fromv).isNoThruTraffic()) {
s1.setNoThruTrafficState(NoThruTrafficState.IN_FINAL_ISLAND);
}
break;
case IN_FINAL_ISLAND:
if (!((TurnVertex)fromv).isNoThruTraffic()) {
return null;
}
break;
}
double speed=options.getSpeed(s0.getNonTransitMode(options));
double time=(((TurnVertex)fromv).getEffectiveLength(traverseMode) + turnCost / 20.0) / speed;
double weight=((TurnVertex)fromv).computeWeight(s0,options,time);
s1.incrementWalkDistance(((TurnVertex)fromv).getLength());
s1.incrementTimeInSeconds((int)Math.ceil(time));
s1.incrementWeight(weight);
if (s1.weHaveWalkedTooFar(options)) return null;
s1.addAlerts(((TurnVertex)fromv).getNotes());
return s1.makeState();
}
