{
  RoutingRequest originalOptions=options.clone();
  List<GraphPath> paths=null;
  boolean tooSloped=false;
  try {
    paths=pathService.getPaths(options);
    if (paths == null && options.isWheelchairAccessible()) {
      options.maxSlope=Double.MAX_VALUE;
      options.maxWalkDistance=originalOptions.maxWalkDistance;
      paths=pathService.getPaths(options);
      tooSloped=true;
    }
  }
 catch (  VertexNotFoundException e) {
    LOG.info("Vertex not found: " + options.getFrom() + " : "+ options.getTo(),e);
    throw e;
  }
  options.rctx.debugOutput.finishedCalculating();
  if (paths == null || paths.size() == 0) {
    LOG.info("Path not found: " + options.getFrom() + " : "+ options.getTo());
    throw new PathNotFoundException();
  }
  for (  GraphPath graphPath : paths) {
    if (originalOptions.isArriveBy()) {
      if (graphPath.states.getLast().getTimeSeconds() > originalOptions.dateTime) {
        LOG.error("A graph path arrives after the requested time. This implies a bug.");
      }
    }
 else {
      if (graphPath.states.getFirst().getTimeSeconds() < originalOptions.dateTime) {
        LOG.error("A graph path leaves before the requested time. This implies a bug.");
      }
    }
  }
  TripPlan plan=generatePlan(paths,originalOptions);
  if (plan != null) {
    for (    Itinerary i : plan.itinerary) {
      i.tooSloped=tooSloped;
      if (i.legs.size() == 0) {
        LOG.warn("itinerary has no legs");
        continue;
      }
      Leg firstLeg=i.legs.get(0);
      firstLeg.from.orig=plan.from.orig;
      Leg lastLeg=i.legs.get(i.legs.size() - 1);
      lastLeg.to.orig=plan.to.orig;
    }
  }
  options.rctx.debugOutput.finishedRendering();
  return plan;
}
