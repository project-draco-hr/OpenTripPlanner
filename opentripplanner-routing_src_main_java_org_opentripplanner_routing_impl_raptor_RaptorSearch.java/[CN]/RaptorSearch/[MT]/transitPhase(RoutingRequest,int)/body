{
  Collection<RaptorRoute> routesToVisit=new HashSet<RaptorRoute>();
  for (  RaptorStop stop : visitedLastRound) {
    for (    RaptorRoute route : data.routesForStop[stop.index]) {
      routesToVisit.add(route);
    }
  }
  HashSet<RaptorStop> visitedThisRound=new HashSet<RaptorStop>();
  List<RaptorState> createdStates=new ArrayList<RaptorState>();
  int boardSlack;
  if (options.isArriveBy()) {
    boardSlack=nBoardings == 1 ? options.getAlightSlack() : (options.getTransferSlack() - options.getBoardSlack());
  }
 else {
    boardSlack=nBoardings == 1 ? options.getBoardSlack() : (options.getTransferSlack() - options.getAlightSlack());
  }
  for (  RaptorRoute route : routesToVisit) {
    List<RaptorState> boardStates=new ArrayList<RaptorState>();
    boolean started=false;
    int firstStop, lastStop, direction, lastBoardStop;
    if (options.isArriveBy()) {
      firstStop=route.getNStops() - 1;
      lastStop=-1;
      direction=-1;
      lastBoardStop=0;
    }
 else {
      firstStop=0;
      lastStop=route.getNStops();
      direction=1;
      lastBoardStop=lastStop - 1;
    }
    for (int stopNo=firstStop; stopNo != lastStop; stopNo+=direction) {
      RaptorStop stop=route.stops[stopNo];
      if (!started && !visitedLastRound.contains(stop))       continue;
      started=true;
      List<RaptorState> states=statesByStop[stop.index];
      List<RaptorState> newStates=new ArrayList<RaptorState>();
      if (states == null) {
        states=new ArrayList<RaptorState>();
        statesByStop[stop.index]=states;
      }
      CONTINUE:       for (      RaptorState boardState : boardStates) {
        RaptorState newState=new RaptorState(options.arriveBy);
        ServiceDay sd=boardState.serviceDay;
        if (options.isArriveBy()) {
          if (!route.alights[0][boardState.patternIndex].getPattern().canBoard(stopNo))           continue;
          int boardTime=route.getBoardTime(boardState.tripTimes,stopNo);
          newState.arrivalTime=(int)sd.time(boardTime);
          newState.arrivalTime-=options.getBoardSlack();
        }
 else {
          if (!route.boards[0][boardState.patternIndex].getPattern().canAlight(stopNo))           continue;
          int alightTime=route.getAlightTime(boardState.tripTimes,stopNo);
          newState.arrivalTime=(int)sd.time(alightTime);
          newState.arrivalTime+=options.getAlightSlack();
        }
        newState.boardStop=boardState.boardStop;
        newState.boardStopSequence=boardState.boardStopSequence;
        newState.route=route;
        newState.patternIndex=boardState.patternIndex;
        newState.tripTimes=boardState.tripTimes;
        newState.nBoardings=boardState.nBoardings;
        newState.walkDistance=boardState.walkDistance;
        newState.parent=boardState.parent;
        newState.stop=stop;
        for (        RaptorState oldState : states) {
          if (oldState.eDominates(newState)) {
            continue CONTINUE;
          }
        }
        for (        RaptorState oldState : newStates) {
          if (oldState.eDominates(newState)) {
            continue CONTINUE;
          }
        }
        Iterator<RaptorState> it=states.iterator();
        while (it.hasNext()) {
          RaptorState oldState=it.next();
          if (newState.eDominates(oldState)) {
            it.remove();
          }
        }
        it=newStates.iterator();
        while (it.hasNext()) {
          RaptorState oldState=it.next();
          if (newState.eDominates(oldState)) {
            it.remove();
          }
        }
        visitedThisRound.add(stop);
        visitedEver.add(stop);
        newStates.add(newState);
      }
      if (stopNo != lastBoardStop) {
        if (stop.stopVertex.isLocal() && nBoardings > 1) {
          createdStates.addAll(newStates);
          states.addAll(newStates);
          continue;
        }
        TRYBOARD:         for (        RaptorState oldState : states) {
          if (oldState.nBoardings != nBoardings - 1)           continue;
          if (oldState.route == route)           continue;
          RaptorBoardSpec boardSpec;
          if (options.isArriveBy()) {
            boardSpec=route.getTripIndexReverse(options,oldState.arrivalTime - boardSlack,stopNo);
          }
 else {
            boardSpec=route.getTripIndex(options,oldState.arrivalTime + boardSlack,stopNo);
          }
          if (boardSpec == null)           continue;
          RaptorState boardState=new RaptorState(oldState);
          boardState.nBoardings=nBoardings;
          boardState.boardStop=stop;
          boardState.boardStopSequence=stopNo;
          boardState.arrivalTime=boardSpec.departureTime;
          boardState.patternIndex=boardSpec.patternIndex;
          boardState.tripTimes=boardSpec.tripTimes;
          boardState.serviceDay=boardSpec.serviceDay;
          boardState.route=route;
          boardState.walkDistance=oldState.walkDistance;
          for (          RaptorState state : newStates) {
            if (state.eDominates(boardState)) {
              continue TRYBOARD;
            }
          }
          boardStates.add(boardState);
        }
      }
      createdStates.addAll(newStates);
      states.addAll(newStates);
    }
  }
  visitedLastRound=visitedThisRound;
  return createdStates;
}
