{
  final double BOARD_COST=options.getBoardCostLowerBound();
  final double speed=s0.getOptions().getStreetSpeedUpperBound();
  Vertex v=s0.getVertex();
  if (weightCache.containsKey(v))   return weightCache.get(v);
  if (speed > wt.getMaxWalkSpeed()) {
    double w=defaultHeuristic.computeForwardWeight(s0,target);
    weightCache.put(s0.getVertex(),w);
    return w;
  }
  double w;
  if (wt.includes(v)) {
    double remainingWalk=options.getMaxWalkDistance() - s0.getWalkDistance();
    w=Double.POSITIVE_INFINITY;
    for (    NearbyStop ns : targetStops) {
      if (ns.distance > remainingWalk)       continue;
      double nw=wt.getWeight(v,ns.vertex) + ns.weight;
      if (nw < w)       w=nw;
    }
    if (!(v instanceof TransitStop))     w-=BOARD_COST;
  }
 else {
    w=defaultHeuristic.computeForwardWeight(s0,target);
  }
  weightCache.put(v,w);
  return w;
}
