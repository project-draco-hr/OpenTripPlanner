{
  if (target == this.target) {
    LOG.debug("Reusing target stop list.");
    return 0;
  }
  weightCache=new IdentityHashMap<Vertex,Double>(200000);
  this.target=target;
  targetStops=new ArrayList<NearbyStop>(50);
  Map<Vertex,List<Edge>> extraEdges=new HashMap<Vertex,List<Edge>>();
  options.extraEdgesStrategy.addIncomingEdgesForTarget(extraEdges,target);
  final double MAX_WEIGHT=60 * 15;
  BinHeap<Vertex> heap=new BinHeap<Vertex>(g.getVertices().size());
  HashSet<Vertex> closed=new HashSet<Vertex>();
  heap.insert(target,0);
  while (!heap.empty()) {
    double w=heap.peek_min_key();
    Vertex u=heap.extract_min();
    if (w > MAX_WEIGHT)     break;
    if (closed.contains(u))     continue;
    closed.add(u);
    weightCache.put(u,w);
    if (u instanceof TransitStop) {
      targetStops.add(new NearbyStop(u,w));
    }
    for (    Edge e : GraphLibrary.getIncomingEdges(g,u,extraEdges)) {
      if (e instanceof TurnEdge || e instanceof PlainStreetEdge || e instanceof StreetTransitLink|| e instanceof FreeEdge) {
        State s0=new State();
        TraverseResult tr=e.traverseBack(s0,options);
        if (tr == null)         continue;
        Vertex fromv=tr.getEdgeNarrative().getFromVertex();
        if (!closed.contains(fromv))         heap.insert(fromv,w + tr.weight);
      }
    }
  }
  LOG.debug("Found " + targetStops.size() + " stops near destination.");
  return defaultHeuristic.computeInitialWeight(origin,target,options);
}
