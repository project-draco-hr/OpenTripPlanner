{
  options=s0.getOptions();
  if (target == this.target) {
    LOG.debug("Reusing target stop list.");
    return 0;
  }
  weightCache=new IdentityHashMap<Vertex,Double>(5000);
  this.target=target;
  targetStops=new ArrayList<NearbyStop>(50);
  Map<Vertex,List<Edge>> extraEdges=new HashMap<Vertex,List<Edge>>();
  ShortestPathTree spt=new BasicShortestPathTree(options);
  BinHeap<State> heap=new BinHeap<State>(100);
  State targetState=new State(target,s0.getTimeSeconds(),s0.getOptions().reversedClone());
  spt.add(targetState);
  heap.insert(targetState,0);
  while (!heap.empty()) {
    State u=heap.extract_min();
    if (!spt.visit(u))     continue;
    Vertex uVertex=u.getVertex();
    weightCache.put(uVertex,u.getWeight());
    if (uVertex instanceof TransitStop) {
      targetStops.add(new NearbyStop(uVertex,u.getWalkDistance(),u.getWeight()));
      continue;
    }
    if (options.isArriveBy()) {
      for (      Edge e : GraphLibrary.getOutgoingEdges(g,uVertex,extraEdges)) {
        State v=e.traverse(u);
        if (v != null && spt.add(v))         heap.insert(v,v.getWeight());
      }
    }
 else {
      for (      Edge e : GraphLibrary.getIncomingEdges(g,uVertex,extraEdges)) {
        State v=e.traverse(u);
        if (v != null && spt.add(v))         heap.insert(v,v.getWeight());
      }
    }
  }
  LOG.debug("Found " + targetStops.size() + " stops near destination.");
  return defaultHeuristic.computeInitialWeight(s0,target);
}
