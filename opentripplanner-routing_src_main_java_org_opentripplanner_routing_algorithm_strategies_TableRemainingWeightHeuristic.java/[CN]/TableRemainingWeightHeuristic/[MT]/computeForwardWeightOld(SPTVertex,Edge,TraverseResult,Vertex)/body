{
  final double BOARD_COST=60 * 5;
  Vertex tov=traverseResult.getEdgeNarrative().getToVertex();
  State fromState=from.state;
  StateData fromData=fromState.getData();
  if (wt.includes(tov)) {
    double w=Double.POSITIVE_INFINITY;
    for (    NearbyStop ns : targetStops) {
      double nw=wt.getWeight(tov,ns.vertex) + ns.weight;
      if (nw < w)       w=nw;
    }
    if (tov instanceof TransitStop)     return w;
 else     return w - BOARD_COST;
  }
  double euclidianDistance=tov.distance(target);
  if (fromData.isAlightedLocal()) {
    return options.walkReluctance * euclidianDistance / options.speed;
  }
 else {
    int boardCost;
    if (edge instanceof OnBoardForwardEdge) {
      boardCost=0;
    }
 else {
      boardCost=options.boardCost;
    }
    if (euclidianDistance < target.getDistanceToNearestTransitStop()) {
      return options.walkReluctance * euclidianDistance / options.speed;
    }
 else {
      final double MAX_SPEED=10D;
      double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + tov.getDistanceToNearestTransitStop();
      double distance=(euclidianDistance - mandatoryWalkDistance) / MAX_SPEED + mandatoryWalkDistance * options.walkReluctance / options.speed + boardCost;
      return Math.min(distance,options.walkReluctance * euclidianDistance / options.speed);
    }
  }
}
