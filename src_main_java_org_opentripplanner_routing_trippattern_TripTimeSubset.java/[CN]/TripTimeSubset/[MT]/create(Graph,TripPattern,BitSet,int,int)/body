{
  List<TripTimes> tripTimes=Lists.newArrayList();
  for (  TripTimes tt : tp.scheduledTimetable.tripTimes) {
    if (!servicesRunning.get(tt.serviceCode))     continue;
    if (tt.scheduledArrivalTimes[0] + tt.timeShift <= endTime && tt.scheduledDepartureTimes[tt.scheduledDepartureTimes.length - 1] + tt.timeShift >= startTime)     tripTimes.add(tt);
  }
  if (tripTimes.isEmpty())   return null;
  Collections.sort(tripTimes,new Comparator<TripTimes>(){
    @Override public int compare(    TripTimes o1,    TripTimes o2){
      return (o1.scheduledArrivalTimes[0] + o1.timeShift) - (o2.scheduledArrivalTimes[0] + o2.timeShift);
    }
  }
);
  TripTimeSubset tts=new TripTimeSubset();
  tts.tripCount=tripTimes.size();
  tts.tripLength=tripTimes.get(0).scheduledArrivalTimes.length;
  tts.times=new int[tts.tripCount * tts.tripLength * 2];
  int tripIdx=0;
  for (  TripTimes tt : tripTimes) {
    for (int stopIdx=0; stopIdx < tts.tripLength; stopIdx++) {
      tts.times[(tripIdx * tts.tripLength + stopIdx) * 2]=tt.scheduledArrivalTimes[stopIdx] + tt.timeShift;
      tts.times[(tripIdx * tts.tripLength + stopIdx) * 2 + 1]=tt.scheduledDepartureTimes[stopIdx] + tt.timeShift;
      if (tripIdx >= 1) {
        if (tts.times[(tripIdx * tts.tripLength + stopIdx) * 2] <= tts.times[((tripIdx - 1) * tts.tripLength + stopIdx) * 2]) {
          LOG.warn("Overtaking/duplicate arrival times on trip pattern {}, trip {} at stop {}," + " trashing this pattern.",tp,tripIdx,stopIdx);
          return null;
        }
        if (tts.times[(tripIdx * tts.tripLength + stopIdx) * 2 + 1] <= tts.times[((tripIdx - 1) * tts.tripLength + stopIdx) * 2 + 1]) {
          LOG.warn("Overtaking/duplicate departure times on trip pattern {}, trip {} at stop {}," + " trashing this pattern.",tp,tripIdx,stopIdx);
          return null;
        }
        if (stopIdx > 0 && tts.times[(tripIdx * tts.tripLength + stopIdx) * 2] - tts.times[(tripIdx * tts.tripLength + stopIdx) * 2 - 1] < 0) {
          LOG.warn("Negative hop time on trip pattern {}, trip {} at stop {}, trashing pattern",tp,tripIdx,stopIdx);
          return null;
        }
        if (tts.times[(tripIdx * tts.tripLength + stopIdx) * 2 + 1] - tts.times[(tripIdx * tts.tripLength + stopIdx) * 2] < 0) {
          LOG.warn("Negative dwell time on trip pattern {}, trip {} at stop {}, trashing pattern",tp,tripIdx,stopIdx);
          return null;
        }
      }
    }
    tripIdx++;
  }
  return tts;
}
