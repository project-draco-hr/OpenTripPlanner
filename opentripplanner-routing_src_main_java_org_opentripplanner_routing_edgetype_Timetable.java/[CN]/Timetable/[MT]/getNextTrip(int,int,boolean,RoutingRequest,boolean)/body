{
  int mask=boarding ? TableTripPattern.MASK_PICKUP : MASK_DROPOFF;
  int shift=boarding ? SHIFT_PICKUP : SHIFT_DROPOFF;
  int stopOffset=boarding ? 0 : 1;
  if ((pattern.perStopFlags[stopIndex + stopOffset] & mask) >> shift == NO_PICKUP) {
    return null;
  }
  if (options.wheelchairAccessible && (pattern.perStopFlags[stopIndex + stopOffset] & FLAG_WHEELCHAIR_ACCESSIBLE) == 0) {
    return null;
  }
  TripTimes[][] tableIndex=boarding ? departuresIndex : arrivalsIndex;
  if (tableIndex != null) {
    TripTimes[] sorted;
    if (tableIndex.length == 1)     sorted=departuresIndex[0];
 else     sorted=tableIndex[stopIndex];
    int tripIndex;
    if (boarding)     tripIndex=TripTimes.binarySearchDepartures(sorted,stopIndex,time);
 else     tripIndex=TripTimes.binarySearchArrivals(sorted,stopIndex,time);
    int increment=boarding ? 1 : -1;
    int terminate=boarding ? sorted.length : -1;
    while (tripIndex != terminate) {
      TripTimes tt=sorted[tripIndex];
      Trip t=tt.getTrip();
      if (tripAcceptable(t,haveBicycle,options)) {
        return tt;
      }
      tripIndex+=increment;
    }
    return null;
  }
  TripTimes bestTrip=null;
  int bestTime=Integer.MAX_VALUE;
  if (!boarding)   time=-time;
  for (int i=0; i < tripTimes.size(); i++) {
    TripTimes currTrip=tripTimes.get(i);
    int currTime;
    if (boarding)     currTime=currTrip.getDepartureTime(stopIndex);
 else     currTime=-(currTrip.getArrivalTime(stopIndex));
    if (currTime >= time && currTime < bestTime && tripAcceptable(currTrip.getTrip(),haveBicycle,options)) {
      bestTrip=currTrip;
      bestTime=currTime;
    }
  }
  return bestTrip;
}
