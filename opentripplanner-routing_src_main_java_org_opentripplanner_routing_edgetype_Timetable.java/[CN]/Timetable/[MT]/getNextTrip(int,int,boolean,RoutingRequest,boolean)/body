{
  TripTimes bestTrip=null;
  int idxLo=-1, idxHi=Integer.MAX_VALUE;
  TripTimes[][] tableIndex=boarding ? departuresIndex : arrivalsIndex;
  List<TripTimes> ordered=tripTimes;
  if (tableIndex != null) {
    TripTimes[] sorted;
    if (tableIndex.length == 1)     sorted=tableIndex[0];
 else     sorted=tableIndex[stopIndex];
    if (boarding) {
      idxLo=idxHi=TripTimes.binarySearchDepartures(sorted,stopIndex,time);
      for (; idxHi < sorted.length; idxHi++) {
        TripTimes tt=sorted[idxHi];
        if (tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          break;
        }
      }
    }
 else {
      idxLo=idxHi=TripTimes.binarySearchArrivals(sorted,stopIndex,time);
      for (; idxLo >= 0; idxLo--) {
        TripTimes tt=sorted[idxLo];
        if (tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          break;
        }
      }
    }
    ordered=Arrays.asList(sorted);
  }
 else {
    int bestTime=boarding ? Integer.MAX_VALUE : Integer.MIN_VALUE;
    int idx=0;
    for (    TripTimes tt : tripTimes) {
      if (boarding) {
        int depTime=tt.getDepartureTime(stopIndex);
        if (depTime >= time && depTime < bestTime && tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          bestTime=depTime;
          idxLo=idxHi=idx;
        }
      }
 else {
        int arvTime=tt.getArrivalTime(stopIndex);
        if (arvTime <= time && arvTime > bestTime && tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          bestTime=arvTime;
          idxLo=idxHi=idx;
        }
      }
      ++idx;
    }
  }
  return bestTrip;
}
