{
  TripTimes bestTrip=null;
  int index;
  TripTimes[][] tableIndex=boarding ? departuresIndex : arrivalsIndex;
  int stopOffset=boarding ? 0 : 1;
  Stop currentStop=pattern.getStops().get(stopIndex + stopOffset);
  if (tableIndex != null) {
    TripTimes[] sorted;
    if (tableIndex.length == 1)     sorted=tableIndex[0];
 else     sorted=tableIndex[stopIndex];
    if (boarding) {
      index=TripTimes.binarySearchDepartures(sorted,stopIndex,time);
      while (index < sorted.length) {
        TripTimes tt=sorted[index++];
        if (tt.tripAcceptable(state0,currentStop,sd,haveBicycle,stopIndex,boarding)) {
          bestTrip=tt;
          break;
        }
      }
    }
 else {
      index=TripTimes.binarySearchArrivals(sorted,stopIndex,time);
      while (index >= 0) {
        TripTimes tt=sorted[index--];
        if (tt.tripAcceptable(state0,currentStop,sd,haveBicycle,stopIndex,boarding)) {
          bestTrip=tt;
          break;
        }
      }
    }
  }
 else {
    int bestTime=boarding ? Integer.MAX_VALUE : Integer.MIN_VALUE;
    for (    TripTimes tt : tripTimes) {
      if (boarding) {
        int depTime=tt.getDepartureTime(stopIndex);
        if (depTime >= time && depTime < bestTime && tt.tripAcceptable(state0,currentStop,sd,haveBicycle,stopIndex,boarding)) {
          bestTrip=tt;
          bestTime=depTime;
        }
      }
 else {
        int arvTime=tt.getArrivalTime(stopIndex);
        if (arvTime <= time && arvTime > bestTime && tt.tripAcceptable(state0,currentStop,sd,haveBicycle,stopIndex,boarding)) {
          bestTrip=tt;
          bestTime=arvTime;
        }
      }
    }
  }
  return bestTrip;
}
