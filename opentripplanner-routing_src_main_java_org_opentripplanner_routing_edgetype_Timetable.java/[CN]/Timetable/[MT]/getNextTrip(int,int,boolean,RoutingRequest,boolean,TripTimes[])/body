{
  TripTimes bestTrip=null;
  int idxLo=-1, idxHi=Integer.MAX_VALUE;
  TripTimes[][] tableIndex=boarding ? departuresIndex : arrivalsIndex;
  List<TripTimes> ordered=tripTimes;
  if (tableIndex != null) {
    TripTimes[] sorted;
    if (tableIndex.length == 1)     sorted=tableIndex[0];
 else     sorted=tableIndex[stopIndex];
    if (boarding) {
      idxLo=idxHi=TripTimes.binarySearchDepartures(sorted,stopIndex,time);
      for (; idxHi < sorted.length; idxHi++) {
        TripTimes tt=sorted[idxHi];
        if (tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          break;
        }
      }
    }
 else {
      idxLo=idxHi=TripTimes.binarySearchArrivals(sorted,stopIndex,time);
      for (; idxLo >= 0; idxLo--) {
        TripTimes tt=sorted[idxLo];
        if (tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          break;
        }
      }
    }
    ordered=Arrays.asList(sorted);
  }
 else {
    int bestTime=boarding ? Integer.MAX_VALUE : Integer.MIN_VALUE;
    int idx=0;
    for (    TripTimes tt : tripTimes) {
      if (boarding) {
        int depTime=tt.getDepartureTime(stopIndex);
        if (depTime >= time && depTime < bestTime && tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          bestTime=depTime;
          idxLo=idxHi=idx;
        }
      }
 else {
        int arvTime=tt.getArrivalTime(stopIndex);
        if (arvTime <= time && arvTime > bestTime && tt.tripAcceptable(options,haveBicycle)) {
          bestTrip=tt;
          bestTime=arvTime;
          idxLo=idxHi=idx;
        }
      }
      ++idx;
    }
  }
  if (adjacentTimes != null && adjacentTimes.length >= 1) {
    int nFound=0;
    if (bestTrip != null) {
      adjacentTimes[0]=bestTrip;
      nFound+=1;
      while (idxLo >= 0 || idxHi < ordered.size()) {
        idxHi+=1;
        if (idxHi < ordered.size()) {
          TripTimes tt=ordered.get(idxHi);
          if (tt.tripAcceptable(options,haveBicycle)) {
            adjacentTimes[nFound]=tt;
            nFound+=1;
            if (nFound == adjacentTimes.length) {
              break;
            }
          }
        }
        idxLo-=1;
        if (idxLo >= 0) {
          TripTimes tt=ordered.get(idxLo);
          if (tt.tripAcceptable(options,haveBicycle)) {
            adjacentTimes[nFound]=tt;
            nFound+=1;
            if (nFound == adjacentTimes.length) {
              break;
            }
          }
        }
      }
      for (; nFound < adjacentTimes.length; nFound++) {
        adjacentTimes[nFound]=null;
      }
    }
  }
  return bestTrip;
}
