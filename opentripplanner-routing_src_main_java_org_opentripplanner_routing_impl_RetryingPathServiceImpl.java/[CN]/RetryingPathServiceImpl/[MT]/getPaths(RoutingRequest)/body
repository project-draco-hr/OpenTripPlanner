{
  ArrayList<GraphPath> paths=new ArrayList<GraphPath>();
  options.setRoutingContext(graphService.getGraph(options.getRouterId()));
  options.rctx.pathParsers=new PathParser[1];
  options.rctx.pathParsers[0]=new BasicPathParser();
  long searchBeginTime=System.currentTimeMillis();
  Queue<RoutingRequest> optionQueue=new LinkedList<RoutingRequest>();
  optionQueue.add(options);
  if (options.getModes().getTrainish() && options.getModes().contains(TraverseMode.BUS)) {
    RoutingRequest busOnly=options.clone();
    busOnly.setModes(options.getModes().clone());
    busOnly.getModes().setTrainish(false);
  }
  double maxWeight=Double.MAX_VALUE;
  double maxWalk=options.getMaxWalkDistance();
  long maxTime=options.isArriveBy() ? 0 : Long.MAX_VALUE;
  RoutingRequest currOptions;
  while (paths.size() < options.numItineraries) {
    currOptions=optionQueue.poll();
    if (currOptions == null) {
      LOG.debug("Ran out of options to try.");
      break;
    }
    currOptions.setMaxWalkDistance(maxWalk);
    double timeout=paths.isEmpty() ? firstPathTimeout : multiPathTimeout;
    long subsearchBeginTime=System.currentTimeMillis();
    LOG.debug("BEGIN SUBSEARCH");
    ShortestPathTree spt=sptService.getShortestPathTree(currOptions,timeout);
    if (spt == null)     break;
    List<GraphPath> somePaths=spt.getPaths();
    LOG.debug("END SUBSEARCH ({} msec of {} msec total)",System.currentTimeMillis() - subsearchBeginTime,System.currentTimeMillis() - searchBeginTime);
    if (somePaths == null) {
      LOG.warn("Aborting search. {} paths found, elapsed time {} sec",paths.size(),(System.currentTimeMillis() - searchBeginTime) / 1000.0);
      break;
    }
    if (maxWeight == Double.MAX_VALUE) {
      if (somePaths.isEmpty()) {
        return null;
      }
      GraphPath path=somePaths.get(0);
      long duration=path.getDuration();
      LOG.debug("Setting max time and weight for subsequent searches.");
      LOG.debug("First path start time:  {}",path.getStartTime());
      maxTime=path.getStartTime() + MAX_TIME_FACTOR * (currOptions.isArriveBy() ? -duration : duration);
      LOG.debug("First path duration:  {}",duration);
      LOG.debug("Max time set to:  {}",maxTime);
      maxWeight=path.getWeight() * MAX_WEIGHT_FACTOR;
      LOG.debug("Max weight set to:  {}",maxWeight);
      if (path.getWalkDistance() > maxWalk) {
        maxWalk=path.getWalkDistance() * 1.25;
      }
    }
    if (somePaths.isEmpty()) {
      LOG.debug("No paths were found.");
      continue;
    }
    for (    GraphPath path : somePaths) {
      if (!paths.contains(path)) {
        if (path.getWalkDistance() > maxWalk) {
          maxWalk=path.getWalkDistance() * 1.25;
        }
        paths.add(path);
        LOG.debug("New trips: {}",path.getTrips());
        RoutingRequest newOptions=currOptions.clone();
        for (        AgencyAndId trip : path.getTrips()) {
          newOptions.bannedTrips.add(trip);
        }
        if (!optionQueue.contains(newOptions)) {
          optionQueue.add(newOptions);
        }
      }
    }
    LOG.debug("{} / {} itineraries",paths.size(),currOptions.numItineraries);
  }
  if (paths.size() == 0) {
    return null;
  }
  Collections.sort(paths,new PathComparator(options.isArriveBy()));
  return paths;
}
