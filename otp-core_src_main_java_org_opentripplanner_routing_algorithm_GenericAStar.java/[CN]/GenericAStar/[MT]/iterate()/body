{
  if (verbose) {
    double w=runState.pq.peek_min_key();
    System.out.println("pq min key = " + w);
  }
  runState.heuristic.doSomeWork();
  runState.u=runState.pq.extract_min();
  if (!runState.spt.visit(runState.u)) {
    return RunStatus.RUNNING;
  }
  if (traverseVisitor != null) {
    traverseVisitor.visitVertex(runState.u);
  }
  runState.u_vertex=runState.u.getVertex();
  if (verbose)   System.out.println("   vertex " + runState.u_vertex);
  if (runState.terminationStrategy != null) {
    if (!runState.terminationStrategy.shouldSearchContinue(runState.rctx.origin,runState.rctx.target,runState.u,runState.spt,runState.options))     return RunStatus.STOPPED;
  }
 else   if (!runState.options.batch && runState.u_vertex == runState.rctx.target && runState.u.isFinal() && runState.u.allPathParsersAccept()) {
    runState.targetAcceptedStates.add(runState.u);
    runState.options.rctx.debug.foundPath();
    if (runState.targetAcceptedStates.size() >= nPaths) {
      LOG.debug("total vertices visited {}",runState.nVisited);
      return RunStatus.STOPPED;
    }
 else {
      return RunStatus.RUNNING;
    }
  }
  runState.nVisited+=1;
  Collection<Edge> edges=runState.options.isArriveBy() ? runState.u_vertex.getIncoming() : runState.u_vertex.getOutgoing();
  for (  Edge edge : edges) {
    for (State v=edge.traverse(runState.u); v != null; v=v.getNextResult()) {
      if (traverseVisitor != null) {
        traverseVisitor.visitEdge(edge,v);
      }
      double remaining_w=computeRemainingWeight(runState.heuristic,v,runState.rctx.target,runState.options);
      if (remaining_w < 0 || Double.isInfinite(remaining_w)) {
        continue;
      }
      double estimate=v.getWeight() + remaining_w * runState.options.getHeuristicWeight();
      if (verbose) {
        System.out.println("      edge " + edge);
        System.out.println("      " + runState.u.getWeight() + " -> "+ v.getWeight()+ "(w) + "+ remaining_w+ "(heur) = "+ estimate+ " vert = "+ v.getVertex());
      }
      if (estimate > runState.options.maxWeight) {
        if (verbose)         System.out.println("         too expensive to reach, not enqueued. estimated weight = " + estimate);
        continue;
      }
      if (isWorstTimeExceeded(v,runState.options)) {
        if (verbose)         System.out.println("         too much time to reach, not enqueued. time = " + v.getTimeSeconds());
        continue;
      }
      if (runState.spt.add(v)) {
        if (traverseVisitor != null)         traverseVisitor.visitEnqueue(v);
        runState.pq.insert(v,estimate);
      }
    }
  }
  return RunStatus.RUNNING;
}
