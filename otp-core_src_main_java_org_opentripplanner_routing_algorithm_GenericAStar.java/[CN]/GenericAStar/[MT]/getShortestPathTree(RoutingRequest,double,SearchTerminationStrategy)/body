{
  long abortTime=DateUtils.absoluteTimeout(relTimeout);
  startSearch(options);
  while (!runState.pq.empty()) {
    if (abortTime < Long.MAX_VALUE && System.currentTimeMillis() > abortTime) {
      LOG.warn("Search timeout. origin={} target={}",runState.rctx.origin,runState.rctx.target);
      options.rctx.aborted=true;
      options.rctx.debug.timedOut=true;
      storeMemory();
      return runState.spt;
    }
    if (verbose) {
      double w=runState.pq.peek_min_key();
      System.out.println("pq min key = " + w);
    }
    runState.heuristic.doSomeWork();
    runState.u=runState.pq.extract_min();
    if (!runState.spt.visit(runState.u)) {
      continue;
    }
    if (traverseVisitor != null) {
      traverseVisitor.visitVertex(runState.u);
    }
    Vertex u_vertex=runState.u.getVertex();
    if (verbose)     System.out.println("   vertex " + u_vertex);
    if (terminationStrategy != null) {
      if (!terminationStrategy.shouldSearchContinue(runState.rctx.origin,runState.rctx.target,runState.u,runState.spt,options))       break;
    }
 else     if (!options.batch && u_vertex == runState.rctx.target && runState.u.isFinal() && runState.u.allPathParsersAccept()) {
      runState.targetAcceptedStates.add(runState.u);
      options.rctx.debug.foundPath();
      if (runState.targetAcceptedStates.size() >= nPaths) {
        LOG.debug("total vertices visited {}",runState.nVisited);
        storeMemory();
        return runState.spt;
      }
 else       continue;
    }
    runState.nVisited+=1;
    Collection<Edge> edges=options.isArriveBy() ? u_vertex.getIncoming() : u_vertex.getOutgoing();
    for (    Edge edge : edges) {
      for (State v=edge.traverse(runState.u); v != null; v=v.getNextResult()) {
        if (traverseVisitor != null) {
          traverseVisitor.visitEdge(edge,v);
        }
        double remaining_w=computeRemainingWeight(runState.heuristic,v,runState.rctx.target,options);
        if (remaining_w < 0 || Double.isInfinite(remaining_w)) {
          continue;
        }
        double estimate=v.getWeight() + remaining_w * options.getHeuristicWeight();
        if (verbose) {
          System.out.println("      edge " + edge);
          System.out.println("      " + runState.u.getWeight() + " -> "+ v.getWeight()+ "(w) + "+ remaining_w+ "(heur) = "+ estimate+ " vert = "+ v.getVertex());
        }
        if (estimate > options.maxWeight) {
          if (verbose)           System.out.println("         too expensive to reach, not enqueued. estimated weight = " + estimate);
          continue;
        }
        if (isWorstTimeExceeded(v,options)) {
          if (verbose)           System.out.println("         too much time to reach, not enqueued. time = " + v.getTimeSeconds());
          continue;
        }
        if (runState.spt.add(v)) {
          if (traverseVisitor != null)           traverseVisitor.visitEnqueue(v);
          runState.pq.insert(v,estimate);
        }
      }
    }
  }
  storeMemory();
  return runState.spt;
}
