{
  RoutingContext rctx=options.getRoutingContext();
  long abortTime=DateUtils.absoluteTimeout(relTimeout);
  ShortestPathTree spt=createShortestPathTree(options);
  final RemainingWeightHeuristic heuristic=options.batch ? new TrivialRemainingWeightHeuristic() : rctx.remainingWeightHeuristic;
  State initialState=new State(options);
  heuristic.initialize(initialState,rctx.target);
  spt.add(initialState);
  OTPPriorityQueueFactory qFactory=BinHeap.FACTORY;
  int initialSize=rctx.graph.getVertices().size();
  initialSize=(int)Math.ceil(2 * (Math.sqrt((double)initialSize + 1)));
  OTPPriorityQueue<State> pq=qFactory.create(initialSize);
  pq.insert(initialState,0);
  int nVisited=0;
  List<State> targetAcceptedStates=Lists.newArrayList();
  while (!pq.empty()) {
    if (_verbose) {
      double w=pq.peek_min_key();
      System.out.println("pq min key = " + w);
    }
    heuristic.doSomeWork();
    if (abortTime < Long.MAX_VALUE && System.currentTimeMillis() > abortTime) {
      LOG.warn("Search timeout. origin={} target={}",rctx.origin,rctx.target);
      options.rctx.aborted=true;
      options.rctx.debug.timedOut=true;
      storeMemory();
      return spt;
    }
    State u=pq.extract_min();
    if (!spt.visit(u)) {
      continue;
    }
    if (traverseVisitor != null) {
      traverseVisitor.visitVertex(u);
    }
    Vertex u_vertex=u.getVertex();
    if (_verbose)     System.out.println("   vertex " + u_vertex);
    if (terminationStrategy != null) {
      if (!terminationStrategy.shouldSearchContinue(rctx.origin,rctx.target,u,spt,options))       break;
    }
 else     if (!options.batch && u_vertex == rctx.target && u.isFinal() && u.allPathParsersAccept()) {
      targetAcceptedStates.add(u);
      options.rctx.debug.foundPath();
      if (targetAcceptedStates.size() >= nPaths) {
        LOG.debug("total vertices visited {}",nVisited);
        storeMemory();
        return spt;
      }
 else       continue;
    }
    Collection<Edge> edges=options.isArriveBy() ? u_vertex.getIncoming() : u_vertex.getOutgoing();
    nVisited+=1;
    for (    Edge edge : edges) {
      for (State v=edge.traverse(u); v != null; v=v.getNextResult()) {
        if (traverseVisitor != null) {
          traverseVisitor.visitEdge(edge,v);
        }
        if (_skipTraversalResultStrategy != null && _skipTraversalResultStrategy.shouldSkipTraversalResult(rctx.origin,rctx.target,u,v,spt,options)) {
          continue;
        }
        double remaining_w=computeRemainingWeight(heuristic,v,rctx.target,options);
        if (remaining_w < 0 || Double.isInfinite(remaining_w)) {
          continue;
        }
        double estimate=v.getWeight() + remaining_w * options.getHeuristicWeight();
        if (_verbose) {
          System.out.println("      edge " + edge);
          System.out.println("      " + u.getWeight() + " -> "+ v.getWeight()+ "(w) + "+ remaining_w+ "(heur) = "+ estimate+ " vert = "+ v.getVertex());
        }
        if (estimate > options.maxWeight) {
          if (_verbose)           System.out.println("         too expensive to reach, not enqueued. estimated weight = " + estimate);
        }
 else         if (isWorstTimeExceeded(v,options)) {
          if (_verbose)           System.out.println("         too much time to reach, not enqueued. time = " + v.getTimeSeconds());
        }
 else {
          if (spt.add(v)) {
            if (traverseVisitor != null)             traverseVisitor.visitEnqueue(v);
            pq.insert(v,estimate);
          }
        }
      }
    }
  }
  storeMemory();
  return spt;
}
