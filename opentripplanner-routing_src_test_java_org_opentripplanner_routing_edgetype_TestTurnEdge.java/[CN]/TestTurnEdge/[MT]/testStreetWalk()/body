{
  Graph gg=new Graph();
  double streetLength=100;
  TurnVertex start=new TurnVertex(gg,"start",GeometryUtils.makeLineString(-74.002,40.5,-74.004,40.5,-74.004,40.5,-74.006,41.0),"start",streetLength,false,null);
  TurnVertex end=new TurnVertex(gg,"end",GeometryUtils.makeLineString(-74.004,40.5,-74.006,41.0),"end",streetLength,false,null);
  TraverseOptions options=new TraverseOptions();
  options.setWalkSpeed(ConstantsForTests.WALKING_SPEED);
  TurnEdge ee=new TurnEdge(start,end);
  GregorianCalendar startTime=new GregorianCalendar(2009,9,21,13,0,0);
  GregorianCalendar endTime=(GregorianCalendar)startTime.clone();
  int expectedSecElapsed=(int)(streetLength / options.getSpeed(TraverseMode.WALK));
  endTime.add(GregorianCalendar.SECOND,expectedSecElapsed);
  State s0=new State(TestUtils.toSeconds(startTime),start,options);
  State s1=ee.traverse(s0);
  assertNotNull(s1);
  assertTrue(Math.abs(s1.getWeight() - options.walkReluctance * streetLength / options.getSpeed(TraverseMode.WALK)) < 10);
  assertTrue(Math.abs(s1.getTime() - endTime.getTimeInMillis() / 1000) < 10);
  options.setArriveBy(true);
  s0=new State(TestUtils.toSeconds(endTime),end,options);
  s1=ee.traverse(s0);
  assertNotNull(s1);
  assertTrue(Math.abs(s1.getWeight() - options.walkReluctance * streetLength / options.getSpeed(TraverseMode.WALK)) < 10);
  assertTrue(Math.abs(s1.getTime() - startTime.getTimeInMillis() / 1000) < 10);
}
