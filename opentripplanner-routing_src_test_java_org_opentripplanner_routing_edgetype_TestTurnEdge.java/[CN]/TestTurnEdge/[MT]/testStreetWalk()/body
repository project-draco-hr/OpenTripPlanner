{
  Graph gg=new Graph();
  double streetLength=100;
  StreetVertex start=new StreetVertex("start",GeometryUtils.makeLineString(-74.002,40.5,-74.004,40.5,-74.004,40.5,-74.006,41.0),"start",streetLength,false,null);
  StreetVertex end=new StreetVertex("end",GeometryUtils.makeLineString(-74.004,40.5,-74.006,41.0),"end",streetLength,false,null);
  gg.addVertex(start);
  gg.addVertex(end);
  TraverseOptions options=new TraverseOptions();
  options.speed=ConstantsForTests.WALKING_SPEED;
  TurnEdge ee=new TurnEdge(start,end);
  gg.addEdge(ee);
  GregorianCalendar startTime=new GregorianCalendar(2009,9,21,13,0,0);
  GregorianCalendar endTime=(GregorianCalendar)startTime.clone();
  int expectedSecElapsed=(int)(streetLength / options.speed);
  endTime.add(GregorianCalendar.SECOND,expectedSecElapsed);
  State s0=new State(startTime.getTimeInMillis(),start,options);
  State s1=ee.traverse(s0);
  assertNotNull(s1);
  assertTrue(Math.abs(s1.getWeight() - options.walkReluctance * streetLength / options.speed) < 10);
  assertTrue(Math.abs(s1.getTime() - endTime.getTimeInMillis()) < 10000);
  s0=new State(endTime.getTimeInMillis(),end,options);
  s1=ee.traverseBack(s0);
  assertNotNull(s1);
  assertTrue(Math.abs(s1.getWeight() - options.walkReluctance * streetLength / options.speed) < 10);
  assertTrue(Math.abs(s1.getTime() - startTime.getTimeInMillis()) < 10000);
}
