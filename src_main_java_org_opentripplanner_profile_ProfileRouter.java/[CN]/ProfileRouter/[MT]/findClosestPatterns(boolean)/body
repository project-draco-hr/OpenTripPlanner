{
  SimpleIsochrone.MinMap<TripPattern,StopAtDistance> closest=new SimpleIsochrone.MinMap<TripPattern,StopAtDistance>();
  for (  StopAtDistance stopDist : findClosestStops(back)) {
    for (    TripPattern pattern : graph.index.patternsForStop.get(stopDist.stop)) {
      closest.putMin(pattern,stopDist);
    }
  }
  if (closest.size() > 50) {
    LOG.info("Truncating the list to include only the closest patterns.");
    List<Integer> distances=Lists.newArrayList();
    for (    StopAtDistance sd : closest.values())     distances.add(sd.distance);
    Collections.sort(distances);
    int maxDist=distances.get(50);
    Iterator<Entry<TripPattern,StopAtDistance>> iter=closest.entrySet().iterator();
    while (iter.hasNext()) {
      Entry<TripPattern,StopAtDistance> entry=iter.next();
      if (entry.getValue().distance > maxDist)       iter.remove();
    }
  }
  return closest;
}
