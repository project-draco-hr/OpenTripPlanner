{
  RoutingRequest rr=new RoutingRequest(TraverseMode.WALK);
  rr.setRoutingContext(graph);
  rr.setBatch(true);
  rr.setWalkSpeed(request.walkSpeed);
  int worstElapsedTime=request.accessTime * 60;
  rr.setWorstTime(rr.dateTime + worstElapsedTime);
  GenericAStar astar=new GenericAStar();
  final int[] mins=new int[Vertex.getMaxIndex()];
  final int[] maxs=new int[Vertex.getMaxIndex()];
  Arrays.fill(mins,Integer.MAX_VALUE);
  Arrays.fill(maxs,Integer.MIN_VALUE);
  int minmin=Integer.MAX_VALUE;
  int minmax=Integer.MAX_VALUE;
  for (  Ride ride : rides) {
    int min=ride.durationLowerBound();
    int max=ride.durationUpperBound();
    if (min < minmin)     minmin=min;
    if (max < minmax)     minmax=max;
  }
  final int finalminmin=minmin;
  final int finalminmax=minmax;
  astar.setNPaths(1);
  astar.setTraverseVisitor(new TraverseVisitor(){
    @Override public void visitEdge(    Edge edge,    State state){
    }
    @Override public void visitEnqueue(    State state){
    }
    @Override public void visitVertex(    State state){
      int min=finalminmin + (int)state.getElapsedTimeSeconds();
      int max=finalminmax + (int)state.getElapsedTimeSeconds();
      Vertex vertex=state.getVertex();
      int index=vertex.getIndex();
      if (mins[index] > min)       mins[index]=min;
      if (maxs[index] < max)       maxs[index]=max;
    }
  }
);
  ShortestPathTree spt=astar.getShortestPathTree(rr,System.currentTimeMillis() + 5000);
  rr.rctx.destroy();
  return null;
}
