{
  if (graph.index.transfersFromStopCluster == null) {
    graph.index.initializeProfileTransfers();
  }
  if (request.analyst) {
    mins=new int[Vertex.getMaxIndex()];
    maxs=new int[Vertex.getMaxIndex()];
    Arrays.fill(mins,TimeSurface.UNREACHABLE);
    Arrays.fill(maxs,TimeSurface.UNREACHABLE);
  }
  LOG.info("modes: {}",request.modes);
  long searchBeginTime=System.currentTimeMillis();
  long abortTime=searchBeginTime + TIMEOUT * 1000;
  this.window=new TimeWindow(request.fromTime,request.toTime,graph.index.servicesRunning(request.date));
  LOG.info("Finding access/egress paths.");
  fromStopPaths=findClosestStops(false);
  fromStops=findClosestPatterns(fromStopPaths);
  if (!request.analyst) {
    toStopPaths=findClosestStops(true);
    toStops=findClosestPatterns(toStopPaths);
    for (    TraverseMode mode : ACCESS_MODES) {
      if (request.modes.contains(mode))       findStreetOption(mode);
    }
  }
  LOG.info("Done finding access/egress paths.");
  LOG.info("From patterns/stops: {}",fromStops);
  LOG.info("To patterns/stops: {}",toStops);
  Map<StopCluster,Ride> initialRides=Maps.newHashMap();
  for (  Entry<TripPattern,StopAtDistance> entry : fromStops.entrySet()) {
    TripPattern pattern=entry.getKey();
    StopAtDistance sd=entry.getValue();
    if (!request.modes.contains(pattern.mode))     continue;
    for (int i=0; i < pattern.getStops().size(); ++i) {
      if (sd.stop == graph.index.stopClusterForStop.get(pattern.getStops().get(i))) {
        Ride ride=initialRides.get(sd.stop);
        if (ride == null) {
          ride=new Ride(sd.stop,null);
          ride.accessTime=sd.etime;
          ride.accessDist=0;
          initialRides.put(sd.stop,ride);
        }
        ride.patternRides.add(new PatternRide(pattern,i));
      }
    }
  }
  for (  Ride ride : initialRides.values()) {
    queue.insert(ride,0);
  }
  while (!queue.empty()) {
    Ride ride=queue.extract_min();
    if (ride.to != null)     throw new AssertionError("Ride should be unfinished.");
    Map<StopCluster,Ride> rides=Maps.newHashMap();
    PR:     for (    PatternRide pr : ride.patternRides) {
      List<Stop> stops=pr.pattern.getStops();
      for (int s=pr.fromIndex + 1; s < stops.size(); ++s) {
        StopCluster cluster=graph.index.stopClusterForStop.get(stops.get(s));
        PatternRide pr2=pr.extendToIndex(s,window);
        if (pr2 == null)         continue PR;
        Ride ride2=rides.get(cluster);
        if (ride2 == null) {
          ride2=ride.extendTo(cluster);
          rides.put(cluster,ride2);
        }
        ride2.patternRides.add(pr2);
      }
    }
    Map<StopCluster,Ride> xferRides=Maps.newHashMap();
    for (    Ride r1 : rides.values()) {
      r1.calcStats(window,request.walkSpeed);
      if (r1.waitStats == null) {
        continue;
      }
      if (!addIfNondominated(r1))       continue;
      if (request.analyst) {
        TransitStop tstop=graph.index.stopVertexForStop.get(r1.to);
        int tsidx=tstop.getIndex();
        int lb=r1.durationLowerBound();
        int ub=r1.durationUpperBound();
        if (mins[tsidx] == TimeSurface.UNREACHABLE || mins[tsidx] > lb)         mins[tsidx]=lb;
        if (maxs[tsidx] == TimeSurface.UNREACHABLE || maxs[tsidx] > ub)         maxs[tsidx]=ub;
      }
      int nRides=r1.pathLength();
      if (nRides >= MAX_RIDES)       continue;
      boolean penultimateRide=(nRides == MAX_RIDES - 1);
      for (      ProfileTransfer tr : graph.index.transfersFromStopCluster.get(r1.to)) {
        if (!request.modes.contains(tr.tp2.mode))         continue;
        if (r1.containsPattern(tr.tp1)) {
          if (r1.pathContainsRoute(tr.tp2.route))           continue;
          if (tr.sc1 != tr.sc2 && r1.pathContainsStop(tr.sc2))           continue;
          if (!request.analyst && penultimateRide && !toStops.containsKey(tr.tp2))           continue;
          TARGET_STOP:           for (int i=0; i < tr.tp2.getStops().size(); ++i) {
            StopCluster cluster=graph.index.stopClusterForStop.get(tr.tp2.getStops().get(i));
            if (cluster == tr.sc2) {
              Ride r2=xferRides.get(tr.sc2);
              if (r2 == null) {
                r2=new Ride(tr.sc2,r1);
                r2.accessDist=tr.distance;
                r2.accessTime=(int)(tr.distance / request.walkSpeed);
                xferRides.put(tr.sc2,r2);
              }
              for (              PatternRide pr : r2.patternRides) {
                if (pr.pattern == tr.tp2 && pr.fromIndex == i)                 continue TARGET_STOP;
              }
              r2.patternRides.add(new PatternRide(tr.tp2,i));
            }
          }
        }
      }
    }
    for (    Ride r : xferRides.values()) {
      if (addIfNondominated(r))       queue.insert(r,r.previous.durationLowerBound());
    }
    if (System.currentTimeMillis() > abortTime)     throw new RuntimeException("TIMEOUT");
  }
  LOG.info("Profile routing request finished in {} sec.",(System.currentTimeMillis() - searchBeginTime) / 1000.0);
  if (request.analyst) {
    makeSurfaces();
    return null;
  }
  Set<Ride> targetRides=Sets.newHashSet();
  for (  StopCluster cluster : toStopPaths.keySet()) {
    for (    Ride ride : retainedRides.get(cluster)) {
      PATTERN:       for (      PatternRide pr : ride.patternRides) {
        StopAtDistance clusterForPattern=toStops.get(pr.pattern);
        if (clusterForPattern != null && clusterForPattern.stop == cluster) {
          targetRides.add(ride);
          break PATTERN;
        }
      }
    }
  }
  LOG.info("{} nondominated rides stop near the destination.",targetRides.size());
  List<Option> options=Lists.newArrayList();
  for (  Ride ride : targetRides) {
    int dist=toStops.get(ride.patternRides.get(0).pattern).etime;
    Collection<StopAtDistance> accessPaths=fromStopPaths.get(ride.getAccessStopCluster());
    Collection<StopAtDistance> egressPaths=toStopPaths.get(ride.getEgressStopCluster());
    Option option=new Option(ride,accessPaths,egressPaths);
    StopCluster s0=ride.getAccessStopCluster();
    StopCluster s1=ride.getEgressStopCluster();
    if (!option.hasEmptyRides())     options.add(option);
  }
  options.add(new Option(null,directPaths,null));
  return new ProfileResponse(options,request.orderBy,request.limit);
}
