{
  if (graph.index.transfersForStop == null) {
    graph.index.initializeProfileTransfers();
  }
  LOG.info("modes: {}",request.modes);
  long searchBeginTime=System.currentTimeMillis();
  long abortTime=searchBeginTime + TIMEOUT * 1000;
  this.window=new TimeWindow(request.fromTime,request.toTime,graph.index.servicesRunning(request.date));
  for (  TraverseMode mode : ACCESS_MODES) {
    if (request.modes.contains(mode))     findStreetOption(mode);
  }
  fromStopPaths=findClosestStops(false);
  toStopPaths=findClosestStops(true);
  fromStops=findClosestPatterns(fromStopPaths);
  toStops=findClosestPatterns(toStopPaths);
  LOG.info("from patterns/stops: {}",fromStops);
  LOG.info("to patterns/stops: {}",toStops);
  Map<Stop,Ride> initialRides=Maps.newHashMap();
  for (  Entry<TripPattern,StopAtDistance> entry : fromStops.entrySet()) {
    TripPattern pattern=entry.getKey();
    StopAtDistance sd=entry.getValue();
    for (int i=0; i < pattern.getStops().size(); ++i) {
      if (pattern.getStops().get(i) == sd.stop) {
        if (request.modes.contains(pattern.mode)) {
          ProfileTransfer xfer=new ProfileTransfer(null,pattern,null,sd.stop,sd.etime);
          Ride ride=initialRides.get(sd.stop);
          if (ride == null) {
            ride=new Ride(sd.stop,null);
            initialRides.put(sd.stop,ride);
          }
          ride.patternRides.add(new PatternRide(pattern,i,null,xfer));
        }
      }
    }
  }
  for (  Ride ride : initialRides.values()) {
    queue.insert(ride,0);
  }
  while (!queue.empty()) {
    Ride ride=queue.extract_min();
    if (ride.to != null)     throw new AssertionError("Ride should be unfinished.");
    Map<Stop,Ride> rides=Maps.newHashMap();
    PR:     for (    PatternRide pr : ride.patternRides) {
      List<Stop> stops=pr.pattern.getStops();
      Stop targetStop=null;
      if (toStops.containsKey(pr.pattern)) {
        targetStop=toStops.get(pr.pattern).stop;
      }
      for (int s=pr.fromIndex + 1; s < stops.size(); ++s) {
        Stop stop=stops.get(s);
        boolean isTarget=(targetStop != null && targetStop == stop);
        if (isTarget || hasTransfers(stop,pr.pattern)) {
          PatternRide pr2=pr.extendToIndex(s,window);
          if (pr2 == null)           continue PR;
          Ride ride2=rides.get(stop);
          if (ride2 == null) {
            ride2=ride.extendTo(stop);
            rides.put(stop,ride2);
          }
          ride2.patternRides.add(pr2);
          if (isTarget)           targetRides.add(ride2);
        }
      }
    }
    Map<Stop,Ride> xferRides=Maps.newHashMap();
    for (    Ride r1 : rides.values()) {
      r1.calcStats(window,request.walkSpeed);
      if (r1.waitStats == null) {
        targetRides.remove(r1);
        continue;
      }
      if (r1.pathLength() >= MAX_RIDES)       continue;
      for (      ProfileTransfer tr : graph.index.transfersForStop.get(r1.to)) {
        if (r1.containsPattern(tr.tp1)) {
          if (r1.pathContainsRoute(tr.tp2.route))           continue;
          if (tr.s1 != tr.s2 && r1.pathContainsStop(tr.s2))           continue;
          for (int i=0; i < tr.tp2.getStops().size(); ++i) {
            if (tr.tp2.getStops().get(i) == tr.s2) {
              if (request.modes.contains(tr.tp2.mode)) {
                Ride r2=xferRides.get(tr.s2);
                if (r2 == null) {
                  r2=new Ride(tr.s2,r1);
                  xferRides.put(tr.s2,r2);
                }
                r2.patternRides.add(new PatternRide(tr.tp2,i,r1,tr));
              }
            }
          }
        }
      }
    }
    for (    Ride xr : xferRides.values()) {
      int dlb=xr.previous.durationLowerBound();
      if (dlb > MAX_DURATION)       continue;
      queue.insert(xr,dlb);
    }
    if (System.currentTimeMillis() > abortTime)     throw new RuntimeException("TIMEOUT");
  }
  List<Option> options=Lists.newArrayList();
  for (  Ride ride : targetRides) {
    int dist=toStops.get(ride.patternRides.get(0).pattern).etime;
    Collection<StopAtDistance> accessPaths=fromStopPaths.get(ride.getAccessStop());
    Collection<StopAtDistance> egressPaths=toStopPaths.get(ride.getEgressStop());
    Option option=new Option(ride,accessPaths,egressPaths);
    Stop s0=ride.getAccessStop();
    Stop s1=ride.getEgressStop();
    if (!option.hasEmptyRides())     options.add(option);
  }
  for (  Option option : directOptions) {
    options.add(option);
  }
  LOG.info("Profile routing request finished in {} sec.",(System.currentTimeMillis() - searchBeginTime) / 1000.0);
  return new ProfileResponse(options,request.orderBy,request.limit);
}
