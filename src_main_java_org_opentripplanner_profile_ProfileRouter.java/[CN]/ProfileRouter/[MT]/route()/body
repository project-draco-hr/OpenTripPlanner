{
  if (graph.index.transfersForStop == null) {
    graph.index.initializeProfileTransfers();
  }
  Arrays.fill(mins,Integer.MAX_VALUE);
  Arrays.fill(maxs,Integer.MAX_VALUE);
  LOG.info("modes: {}",request.modes);
  long searchBeginTime=System.currentTimeMillis();
  long abortTime=searchBeginTime + TIMEOUT * 1000;
  this.window=new TimeWindow(request.fromTime,request.toTime,graph.index.servicesRunning(request.date));
  LOG.info("Finding access/egress paths.");
  fromStopPaths=findClosestStops(false);
  fromStops=findClosestPatterns(fromStopPaths);
  if (!request.analyst) {
    toStopPaths=findClosestStops(true);
    toStops=findClosestPatterns(toStopPaths);
    for (    TraverseMode mode : ACCESS_MODES) {
      if (request.modes.contains(mode))       findStreetOption(mode);
    }
  }
  LOG.info("Done finding access/egress paths.");
  LOG.info("From patterns/stops: {}",fromStops);
  LOG.info("To patterns/stops: {}",toStops);
  Map<Stop,Ride> initialRides=Maps.newHashMap();
  for (  Entry<TripPattern,StopAtDistance> entry : fromStops.entrySet()) {
    TripPattern pattern=entry.getKey();
    StopAtDistance sd=entry.getValue();
    for (int i=0; i < pattern.getStops().size(); ++i) {
      if (pattern.getStops().get(i) == sd.stop) {
        if (request.modes.contains(pattern.mode)) {
          Ride ride=initialRides.get(sd.stop);
          if (ride == null) {
            ride=new Ride(sd.stop,null,null);
            initialRides.put(sd.stop,ride);
          }
          ride.patternRides.add(new PatternRide(pattern,i));
        }
      }
    }
  }
  for (  Ride ride : initialRides.values()) {
    queue.insert(ride,0);
  }
  while (!queue.empty()) {
    Ride ride=queue.extract_min();
    if (ride.to != null)     throw new AssertionError("Ride should be unfinished.");
    Map<Stop,Ride> rides=Maps.newHashMap();
    PR:     for (    PatternRide pr : ride.patternRides) {
      List<Stop> stops=pr.pattern.getStops();
      Stop targetStop=null;
      if (toStops != null && toStops.containsKey(pr.pattern)) {
        targetStop=toStops.get(pr.pattern).stop;
      }
      for (int s=pr.fromIndex + 1; s < stops.size(); ++s) {
        Stop stop=stops.get(s);
        boolean isTarget=(targetStop != null && targetStop == stop);
        PatternRide pr2=pr.extendToIndex(s,window);
        if (pr2 == null)         continue PR;
        Ride ride2=rides.get(stop);
        if (ride2 == null) {
          ride2=ride.extendTo(stop);
          rides.put(stop,ride2);
        }
        ride2.patternRides.add(pr2);
        if (isTarget)         targetRides.add(ride2);
      }
    }
    Map<Stop,Ride> xferRides=Maps.newHashMap();
    for (    Ride r1 : rides.values()) {
      r1.calcStats(window,request.walkSpeed);
      if (r1.waitStats == null) {
        targetRides.remove(r1);
        continue;
      }
      if (request.analyst) {
        TransitStop tstop=graph.index.stopVertexForStop.get(r1.to);
        int tsidx=tstop.getIndex();
        int lb=r1.durationLowerBound();
        int ub=r1.durationUpperBound();
        if (mins[tsidx] > lb)         mins[tsidx]=lb;
        if (maxs[tsidx] > ub)         maxs[tsidx]=ub;
      }
      int nRides=r1.pathLength();
      if (nRides >= MAX_RIDES)       continue;
      boolean penultimateRide=(nRides == MAX_RIDES - 1);
      for (      ProfileTransfer tr : graph.index.transfersForStop.get(r1.to)) {
        if (r1.containsPattern(tr.tp1)) {
          if (r1.pathContainsRoute(tr.tp2.route))           continue;
          if (tr.s1 != tr.s2 && r1.pathContainsStop(tr.s2))           continue;
          if (!request.analyst && penultimateRide && !toStops.containsKey(tr.tp2))           continue;
          TARGET_STOP:           for (int i=0; i < tr.tp2.getStops().size(); ++i) {
            if (tr.tp2.getStops().get(i) == tr.s2) {
              if (request.modes.contains(tr.tp2.mode)) {
                Ride r2=xferRides.get(tr.s2);
                if (r2 == null) {
                  r2=new Ride(tr.s2,r1,tr);
                  xferRides.put(tr.s2,r2);
                }
                for (                PatternRide pr : r2.patternRides) {
                  if (pr.pattern == tr.tp2 && pr.fromIndex == i)                   continue TARGET_STOP;
                }
                r2.patternRides.add(new PatternRide(tr.tp2,i));
              }
            }
          }
        }
      }
    }
    for (    Ride r : xferRides.values())     maybeAddRide(r);
    if (System.currentTimeMillis() > abortTime)     throw new RuntimeException("TIMEOUT");
  }
  LOG.info("Profile routing request finished in {} sec.",(System.currentTimeMillis() - searchBeginTime) / 1000.0);
  if (request.analyst) {
    makeSurfaces();
    return null;
  }
  List<Option> options=Lists.newArrayList();
  for (  Ride ride : targetRides) {
    int dist=toStops.get(ride.patternRides.get(0).pattern).etime;
    Collection<StopAtDistance> accessPaths=fromStopPaths.get(ride.getAccessStop());
    Collection<StopAtDistance> egressPaths=toStopPaths.get(ride.getEgressStop());
    Option option=new Option(ride,accessPaths,egressPaths);
    Stop s0=ride.getAccessStop();
    Stop s1=ride.getEgressStop();
    if (!option.hasEmptyRides())     options.add(option);
  }
  options.add(new Option(null,directPaths,null));
  return new ProfileResponse(options,request.orderBy,request.limit);
}
