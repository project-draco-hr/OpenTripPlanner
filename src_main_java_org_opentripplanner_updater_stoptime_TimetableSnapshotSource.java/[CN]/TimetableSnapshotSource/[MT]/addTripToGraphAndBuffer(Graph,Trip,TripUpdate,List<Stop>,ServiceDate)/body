{
  Preconditions.checkNotNull(stops);
  Preconditions.checkArgument(tripUpdate.getStopTimeUpdateCount() == stops.size(),"number of stop should match the number of stop time updates");
  Calendar serviceCalendar=serviceDate.getAsCalendar(timeZone);
  final long midnightSecondsSinceEpoch=serviceCalendar.getTimeInMillis() / MILLIS_PER_SECOND;
  List<StopTime> stopTimes=new ArrayList<>(tripUpdate.getStopTimeUpdateCount());
  for (int index=0; index < tripUpdate.getStopTimeUpdateCount(); ++index) {
    StopTimeUpdate stopTimeUpdate=tripUpdate.getStopTimeUpdate(index);
    Stop stop=stops.get(index);
    boolean skippedStop=isStopSkipped(stopTimeUpdate);
    if (!skippedStop) {
      StopTime stopTime=new StopTime();
      stopTime.setTrip(trip);
      stopTime.setStop(stop);
      if (stopTimeUpdate.hasArrival() && stopTimeUpdate.getArrival().hasTime()) {
        long arrivalTime=stopTimeUpdate.getArrival().getTime() - midnightSecondsSinceEpoch;
        if (arrivalTime < 0 || arrivalTime > MAX_ARRIVAL_DEPARTURE_TIME) {
          LOG.warn("ADDED trip has invalid arrival time (compared to start date in " + "TripDescriptor), skipping.");
          return false;
        }
        stopTime.setArrivalTime((int)arrivalTime);
      }
      if (stopTimeUpdate.hasDeparture() && stopTimeUpdate.getDeparture().hasTime()) {
        long departureTime=stopTimeUpdate.getDeparture().getTime() - midnightSecondsSinceEpoch;
        if (departureTime < 0 || departureTime > MAX_ARRIVAL_DEPARTURE_TIME) {
          LOG.warn("ADDED trip has invalid departure time (compared to start date in " + "TripDescriptor), skipping.");
          return false;
        }
        stopTime.setDepartureTime((int)departureTime);
      }
      stopTime.setTimepoint(1);
      if (stopTimeUpdate.hasStopSequence()) {
        stopTime.setStopSequence(stopTimeUpdate.getStopSequence());
      }
      if (index == tripUpdate.getStopTimeUpdateCount() - 1) {
        stopTime.setPickupType(1);
      }
 else {
        stopTime.setPickupType(0);
      }
      if (index == 0) {
        stopTime.setDropOffType(1);
      }
 else {
        stopTime.setDropOffType(0);
      }
      stopTimes.add(stopTime);
    }
  }
  StopPattern stopPattern=new StopPattern(stopTimes);
  TripPattern pattern=tripPatternCache.getOrCreateTripPattern(stopPattern,trip.getRoute(),graph);
  int serviceCode=graph.serviceCodes.get(trip.getServiceId());
  if (!pattern.getServices().get(serviceCode)) {
    BitSet services=(BitSet)pattern.getServices().clone();
    services.set(serviceCode);
    pattern.setServices(services);
  }
  TripTimes newTripTimes=new TripTimes(trip,stopTimes,graph.deduplicator);
  for (int stopIndex=0; stopIndex < newTripTimes.getNumStops(); stopIndex++) {
    newTripTimes.updateArrivalTime(stopIndex,newTripTimes.getScheduledArrivalTime(stopIndex));
    newTripTimes.updateDepartureTime(stopIndex,newTripTimes.getScheduledDepartureTime(stopIndex));
  }
  newTripTimes.serviceCode=serviceCode;
  boolean success=buffer.update(pattern,newTripTimes,serviceDate);
  return success;
}
