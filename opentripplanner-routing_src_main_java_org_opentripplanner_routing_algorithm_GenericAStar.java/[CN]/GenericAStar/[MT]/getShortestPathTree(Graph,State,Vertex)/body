{
  if (origin == null || target == null) {
    return null;
  }
  TraverseOptions options=origin.getOptions();
  ShortestPathTree spt=createShortestPathTree(origin,options);
  options.setTransferTable(graph.getTransferTable());
  final ExtraEdgesStrategy extraEdgesStrategy=options.extraEdgesStrategy;
  Map<Vertex,List<Edge>> extraEdges=new HashMap<Vertex,List<Edge>>();
  if (options.isArriveBy()) {
    extraEdgesStrategy.addIncomingEdgesForOrigin(extraEdges,origin.getVertex());
    extraEdgesStrategy.addIncomingEdgesForTarget(extraEdges,target);
  }
 else {
    extraEdgesStrategy.addOutgoingEdgesForOrigin(extraEdges,origin.getVertex());
    extraEdgesStrategy.addOutgoingEdgesForTarget(extraEdges,target);
  }
  if (extraEdges.isEmpty())   extraEdges=Collections.emptyMap();
  final RemainingWeightHeuristic heuristic=options.remainingWeightHeuristic;
  double initialWeight=heuristic.computeInitialWeight(origin,target);
  spt.add(origin);
  OTPPriorityQueueFactory factory=BinHeap.FACTORY;
  OTPPriorityQueue<State> pq=factory.create(graph.getVertices().size() + extraEdges.size());
  pq.insert(origin,origin.getWeight() + initialWeight);
  options=options.clone();
  double minWalkDistance=origin.getVertex().getDistanceToNearestTransitStop() + target.getDistanceToNearestTransitStop();
  options.setMaxWalkDistance(Math.max(options.getMaxWalkDistance(),minWalkDistance));
  long abortTime=Long.MAX_VALUE;
  if (options.searchAbortTime > 0)   abortTime=Math.min(abortTime,options.searchAbortTime);
  if (options.maxComputationTime > 0)   abortTime=Math.min(abortTime,System.currentTimeMillis() + options.maxComputationTime);
  int nVisited=0;
  while (!pq.empty()) {
    if (_verbose) {
      double w=pq.peek_min_key();
      System.out.println("pq min key = " + w);
    }
    if (abortTime < Long.MAX_VALUE && System.currentTimeMillis() > abortTime) {
      LOG.warn("Search timeout. origin={} target={}",origin,target);
      return null;
    }
    State u=pq.extract_min();
    if (!spt.visit(u))     continue;
    if (traverseVisitor != null) {
      traverseVisitor.visitVertex(u);
    }
    Vertex u_vertex=u.getVertex();
    if (_verbose)     System.out.println("   vertex " + u_vertex);
    if (_searchTerminationStrategy != null) {
      if (!_searchTerminationStrategy.shouldSearchContinue(origin.getVertex(),target,u,spt,options))       break;
    }
 else     if (u_vertex == target) {
      LOG.debug("total vertices visited {}",nVisited);
      return spt;
    }
    Collection<Edge> edges=getEdgesForVertex(graph,extraEdges,u_vertex,options);
    nVisited+=1;
    for (    Edge edge : edges) {
      for (State v=edge.traverse(u); v != null; v=v.getNextResult()) {
        if (traverseVisitor != null) {
          traverseVisitor.visitEdge(edge,v);
        }
        if (_skipTraversalResultStrategy != null && _skipTraversalResultStrategy.shouldSkipTraversalResult(origin.getVertex(),target,u,v,spt,options))         continue;
        double remaining_w=computeRemainingWeight(heuristic,v,target,options);
        if (remaining_w < 0 || Double.isInfinite(remaining_w)) {
          continue;
        }
        double estimate=v.getWeight() + remaining_w;
        if (_verbose) {
          System.out.println("      edge " + edge);
          System.out.println("      " + u.getWeight() + " -> "+ v.getWeight()+ "(w) + "+ remaining_w+ "(heur) = "+ estimate+ " vert = "+ v.getVertex());
        }
        if (estimate > options.maxWeight) {
          if (_verbose)           System.out.println("         too expensive to reach, not enqueued. estimated weight = " + estimate);
        }
 else         if (isWorstTimeExceeded(v,options)) {
          if (_verbose)           System.out.println("         too much time to reach, not enqueued. time = " + v.getTime());
        }
 else {
          if (spt.add(v)) {
            if (traverseVisitor != null)             traverseVisitor.visitEnqueue(v);
            pq.insert(v,estimate);
          }
        }
      }
    }
  }
  return spt;
}
