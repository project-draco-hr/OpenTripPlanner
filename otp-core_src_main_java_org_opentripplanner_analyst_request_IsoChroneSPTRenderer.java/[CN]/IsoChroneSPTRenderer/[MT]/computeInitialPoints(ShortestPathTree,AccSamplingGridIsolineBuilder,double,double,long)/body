{
  int n=0;
  int nSkippedDupEdge=0, nSkippedTimeOut=0;
  Collection<? extends State> allStates=spt.getAllStates();
  Set<Edge> processedEdges=new HashSet<Edge>(allStates.size());
  for (  State s0 : allStates) {
    for (    Edge e : s0.getVertex().getIncoming()) {
      if (e != null && e instanceof StreetEdge) {
        State s1=spt.getState(e.getFromVertex());
        if (s1 == null)         continue;
        long t0=s0.getActiveTime();
        long t1=s1.getActiveTime();
        if (t0 > tMax && t1 > tMax) {
          nSkippedTimeOut++;
          continue;
        }
        if (e.getFromVertex() == null || e.getToVertex() == null) {
          continue;
        }
        if (processedEdges.contains(e)) {
          nSkippedDupEdge++;
          continue;
        }
        processedEdges.add(e);
        Vertex vx0=s0.getVertex();
        Vertex vx1=s1.getVertex();
        LineString lineString=e.getGeometry();
        isolineBuilder.addSample(vx0.getCoordinate(),t0);
        isolineBuilder.addSample(vx1.getCoordinate(),t1);
        n+=2;
        Coordinate[] pList=lineString.getCoordinates();
        boolean reverse=vx1.getCoordinate().equals(pList[0]);
        double lineStringLen=distanceLibrary.fastLength(lineString);
        if (lineStringLen > d0) {
          int nSteps=(int)Math.floor(lineStringLen / d0) + 1;
          double stepLen=lineStringLen / nSteps;
          double startLen=0;
          double curLen=stepLen;
          int ns=1;
          for (int i=0; i < pList.length - 1; i++) {
            Coordinate p0=pList[i];
            Coordinate p1=pList[i + 1];
            double segLen=distanceLibrary.fastDistance(p0,p1);
            while (curLen - startLen < segLen) {
              double k=(curLen - startLen) / segLen;
              Coordinate p=new Coordinate(p0.x * (1 - k) + p1.x * k,p0.y * (1 - k) + p1.y * k);
              double t0b=(reverse ? t1 : t0) + curLen / v0;
              double t1b=(reverse ? t0 : t1) + (lineStringLen - curLen) / v0;
              isolineBuilder.addSample(p,t0b < t1b ? t0b : t1b);
              n++;
              curLen+=stepLen;
              ns++;
            }
            startLen+=segLen;
            if (ns >= nSteps)             break;
          }
        }
      }
    }
  }
  LOG.info("Created {} initial points ({} dup edges, {} out time) from {} states.",n,nSkippedDupEdge,nSkippedTimeOut,allStates.size());
}
