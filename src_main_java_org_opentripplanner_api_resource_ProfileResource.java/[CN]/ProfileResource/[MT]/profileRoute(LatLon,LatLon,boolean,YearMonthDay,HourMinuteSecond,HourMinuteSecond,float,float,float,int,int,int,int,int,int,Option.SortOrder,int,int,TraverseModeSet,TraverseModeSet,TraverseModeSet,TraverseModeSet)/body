{
  QueryParameter.checkRangeInclusive(limit,0,Integer.MAX_VALUE);
  QueryParameter.checkRangeInclusive(walkSpeed,1,7);
  QueryParameter.checkRangeInclusive(bikeSpeed,1,21);
  QueryParameter.checkRangeInclusive(carSpeed,1,36);
  QueryParameter.checkRangeInclusive(streetTime,1,480);
  QueryParameter.checkRangeInclusive(maxWalkTime,1,480);
  QueryParameter.checkRangeInclusive(maxBikeTime,1,480);
  QueryParameter.checkRangeInclusive(maxCarTime,1,480);
  QueryParameter.checkRangeInclusive(minBikeTime,0,maxBikeTime);
  QueryParameter.checkRangeInclusive(minCarTime,0,maxCarTime);
  QueryParameter.checkRangeInclusive(suboptimalMinutes,0,30);
  ProfileRequest req=new ProfileRequest();
  req.from=from;
  req.to=to;
  req.fromTime=fromTime.toSeconds();
  req.toTime=toTime.toSeconds();
  req.walkSpeed=walkSpeed;
  req.bikeSpeed=bikeSpeed;
  req.carSpeed=carSpeed;
  req.date=date.toJoda();
  req.orderBy=orderBy;
  req.limit=limit;
  req.accessModes=accessModes;
  req.egressModes=egressModes;
  req.directModes=directModes;
  req.transitModes=transitModes;
  req.analyst=analyst;
  req.streetTime=streetTime;
  req.maxWalkTime=maxWalkTime;
  req.maxBikeTime=maxBikeTime;
  req.maxCarTime=maxCarTime;
  req.minBikeTime=minBikeTime;
  req.minCarTime=minCarTime;
  req.suboptimalMinutes=suboptimalMinutes;
  if (req.analyst == true) {
    AnalystProfileRouterPrototype router=new AnalystProfileRouterPrototype(graph,req);
    TimeSurface.RangeSet result=router.route();
    Map<String,Integer> idForSurface=Maps.newHashMap();
    idForSurface.put("min",surfaceCache.add(result.min));
    idForSurface.put("avg",surfaceCache.add(result.avg));
    idForSurface.put("max",surfaceCache.add(result.max));
    return Response.status(Status.OK).entity(idForSurface).build();
  }
 else {
    ProfileRouter router=new ProfileRouter(graph,req);
    try {
      ProfileResponse response=router.route();
      if (req.analyst) {
        surfaceCache.add(router.minSurface);
        surfaceCache.add(router.maxSurface);
        List<TimeSurfaceShort> surfaceShorts=Lists.newArrayList();
        surfaceShorts.add(new TimeSurfaceShort(router.minSurface));
        surfaceShorts.add(new TimeSurfaceShort(router.maxSurface));
        return Response.status(Status.OK).entity(surfaceShorts).build();
      }
 else {
        return Response.status(Status.OK).entity(response).build();
      }
    }
  finally {
      router.cleanup();
    }
  }
}
