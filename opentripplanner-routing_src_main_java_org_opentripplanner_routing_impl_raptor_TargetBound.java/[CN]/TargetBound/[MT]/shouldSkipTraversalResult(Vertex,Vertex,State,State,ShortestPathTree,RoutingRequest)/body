{
  final Vertex vertex=current.getVertex();
  int vertexIndex=vertex.getIndex();
  if (vertexIndex < distance.length) {
    if (distance[vertexIndex] > 0.0) {
      targetDistance=distance[vertexIndex];
    }
 else {
      targetDistance=distanceLibrary.fastDistance(realTargetCoordinate.y,realTargetCoordinate.x,vertex.getY(),vertex.getX());
      distance[vertexIndex]=targetDistance;
      if (vertex instanceof TransitStop && targetDistance < bestTargetDistance) {
        bestTargetDistance=targetDistance;
      }
    }
  }
 else {
    targetDistance=distanceLibrary.fastDistance(realTargetCoordinate.y,realTargetCoordinate.x,vertex.getY(),vertex.getX());
  }
  final double remainingWalk=traverseOptions.maxWalkDistance - current.getWalkDistance();
  final double minWalk;
  double minTime=0;
  if (targetDistance > remainingWalk) {
    minWalk=this.distanceToNearestTransitStop + vertex.getDistanceToNearestTransitStop();
    minTime=traverseOptions.getBoardSlack();
    if (current.getBackEdge() instanceof StreetEdge && !transitLocalStreets.transferrable(vertex)) {
      return true;
    }
  }
 else {
    if (targetDistance < distanceToNearestTransitStop || !transitLocalStreets.transferrable(vertex))     minWalk=targetDistance;
 else     minWalk=distanceToNearestTransitStop;
  }
  if (minWalk > remainingWalk)   return true;
  final double optimisticDistance=current.getWalkDistance() + minWalk;
  minTime+=(targetDistance - minWalk) / Raptor.MAX_TRANSIT_SPEED + minWalk / speedUpperBound;
  double stateTime=current.getTime() + minTime - traverseOptions.dateTime;
  int i=0;
  boolean prevBounded=!bounders.isEmpty();
  for (  State bounder : bounders) {
    int prevTime=previousArrivalTime.get(i++);
    if (optimisticDistance * 1.1 > bounder.getWalkDistance() && current.getTime() + minTime > bounder.getTime() && current.getNumBoardings() >= bounder.getNumBoardings())     return true;
    if (!(optimisticDistance * 1.1 > bounder.getWalkDistance() && current.getTime() + minTime > prevTime) && current.getNumBoardings() >= bounder.getNumBoardings()) {
      prevBounded=false;
    }
    double bounderTime=bounder.getTime() - traverseOptions.dateTime;
    if (bounderTime * timeBoundFactor < stateTime) {
      return true;
    }
  }
  return prevBounded;
}
