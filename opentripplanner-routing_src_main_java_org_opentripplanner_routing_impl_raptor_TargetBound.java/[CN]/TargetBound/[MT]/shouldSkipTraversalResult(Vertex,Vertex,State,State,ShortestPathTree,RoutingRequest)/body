{
  final Vertex vertex=current.getVertex();
  targetDistance=distanceLibrary.fastDistance(realTargetCoordinate.x,realTargetCoordinate.y,vertex.getX(),vertex.getY());
  final double remainingWalk=traverseOptions.maxWalkDistance - current.getWalkDistance();
  final double minWalk;
  double minTime=0;
  if (targetDistance > remainingWalk) {
    minWalk=this.distanceToNearestTransitStop + vertex.getDistanceToNearestTransitStop();
    minTime=traverseOptions.getBoardSlack();
    if (current.getBackEdge() instanceof StreetEdge && !transitLocalStreets.transferrable(vertex)) {
      return true;
    }
  }
 else {
    minWalk=targetDistance;
  }
  if (minWalk > remainingWalk)   return true;
  final double optimisticDistance=current.getWalkDistance() + minWalk;
  minTime+=(targetDistance - minWalk) / Raptor.MAX_TRANSIT_SPEED + minWalk / speedUpperBound;
  double stateTime=current.getTime() + minTime - traverseOptions.dateTime;
  for (  State bounder : bounders) {
    if (optimisticDistance * 1.1 > bounder.getWalkDistance() && current.getTime() + minTime > bounder.getTime())     return true;
    double bounderTime=bounder.getTime() - traverseOptions.dateTime;
    if (bounderTime * timeBoundFactor < stateTime) {
      return true;
    }
  }
  return false;
}
