{
  StreetEdge street=(StreetEdge)edge;
  Vertex fromv=street.getFromVertex();
  StreetVertex newFrom, location;
  Geometry geometry=street.getGeometry();
  if (cache.containsKey(geometry)) {
    P2<StreetVertex> cached=cache.get(geometry);
    newFrom=cached.getFirst();
    location=cached.getSecond();
  }
 else {
    P2<LineString> geometries=getGeometry(street,nearestPoint);
    double totalGeomLength=geometry.getLength();
    double lengthRatioIn=geometries.getFirst().getLength() / totalGeomLength;
    double lengthIn=street.getLength() * lengthRatioIn;
    double lengthOut=street.getLength() * (1 - lengthRatioIn);
    newFrom=new StreetVertex(label + " (vertex going in to splitter)",geometries.getFirst(),name,lengthIn,false);
    newFrom.setElevationProfile(street.getElevationProfile(0,lengthIn));
    newFrom.setPermission(street.getPermission());
    location=new StreetVertex(label + " (vertex at splitter)",geometries.getSecond(),name,lengthOut,false);
    location.setElevationProfile(street.getElevationProfile(lengthIn,lengthIn + lengthOut));
    location.setPermission(street.getPermission());
    cache.put(geometry,new P2<StreetVertex>(newFrom,location));
    FreeEdge free=new FreeEdge(fromv,newFrom);
    TurnEdge incoming=new TurnEdge(newFrom,location);
    base.extra.add(free);
    base.extra.add(incoming);
  }
  Vertex tov=street.getToVertex();
  StreetEdge e;
  if (tov instanceof StreetVertex) {
    e=new TurnEdge(location,(StreetVertex)tov);
  }
 else {
    e=new OutEdge(location,tov);
  }
  base.extra.add(e);
  return location;
}
