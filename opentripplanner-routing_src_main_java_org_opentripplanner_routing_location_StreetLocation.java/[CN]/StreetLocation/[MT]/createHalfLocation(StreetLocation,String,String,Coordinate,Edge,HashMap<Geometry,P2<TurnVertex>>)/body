{
  StreetEdge street=(StreetEdge)edge;
  Vertex fromv=street.getFromVertex();
  TurnVertex newFrom, location;
  Geometry geometry=street.getGeometry();
  if (cache.containsKey(geometry)) {
    P2<TurnVertex> cached=cache.get(geometry);
    location=cached.getSecond();
  }
 else {
    P2<LineString> geometries=getGeometry(street,nearestPoint);
    double totalGeomLength=geometry.getLength();
    double lengthRatioIn=geometries.getFirst().getLength() / totalGeomLength;
    double lengthIn=street.getLength() * lengthRatioIn;
    double lengthOut=street.getLength() * (1 - lengthRatioIn);
    newFrom=new TurnVertex(null,label + " (vertex going in to splitter)",geometries.getFirst(),name,lengthIn,false,street.getNotes());
    newFrom.setElevationProfile(street.getElevationProfile(0,lengthIn));
    newFrom.setPermission(street.getPermission());
    newFrom.setNoThruTraffic(street.isNoThruTraffic());
    location=new TurnVertex(null,label + " (vertex at splitter)",geometries.getSecond(),name,lengthOut,false,street.getNotes());
    location.setElevationProfile(street.getElevationProfile(lengthIn,lengthIn + lengthOut));
    location.setPermission(street.getPermission());
    location.setNoThruTraffic(street.isNoThruTraffic());
    cache.put(geometry,new P2<TurnVertex>(newFrom,location));
    FreeEdge free=new FreeEdge(fromv,newFrom);
    TurnEdge incoming=new TurnEdge(newFrom,location);
    base.extra.add(free);
    base.extra.add(incoming);
  }
  Vertex tov=street.getToVertex();
  StreetEdge e;
  if (tov instanceof TurnVertex) {
    e=new TurnEdge(location,(TurnVertex)tov);
    if (edge instanceof TurnEdge) {
      ((TurnEdge)e).setRestrictedModes(((TurnEdge)edge).getRestrictedModes());
    }
  }
 else {
    e=new OutEdge(location,(StreetVertex)tov);
  }
  base.extra.add(e);
  return location;
}
