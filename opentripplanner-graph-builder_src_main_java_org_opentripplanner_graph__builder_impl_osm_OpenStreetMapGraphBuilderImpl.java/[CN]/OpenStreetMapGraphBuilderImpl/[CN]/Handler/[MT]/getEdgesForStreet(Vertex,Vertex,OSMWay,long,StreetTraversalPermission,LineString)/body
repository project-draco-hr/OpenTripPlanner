{
  Coordinate[] coordinates=geometry.getCoordinates();
  double d=0;
  for (int i=1; i < coordinates.length; ++i) {
    d+=DistanceLibrary.distance(coordinates[i - 1],coordinates[i]);
  }
  LineString backGeometry=(LineString)geometry.reverse();
  Map<String,String> tags=way.getTags();
  if (permissions == StreetTraversalPermission.NONE)   return new P2<PlainStreetEdge>(null,null);
  PlainStreetEdge street=null, backStreet=null;
  if (way.isTag("foot","yes") || way.isTag("foot","designated")) {
    permissions=permissions.add(StreetTraversalPermission.PEDESTRIAN);
  }
  if (way.isTagFalse("foot")) {
    permissions=permissions.remove(StreetTraversalPermission.PEDESTRIAN);
  }
  boolean forceBikes=false;
  if (way.isTag("bicycle","yes") || way.isTag("bicycle","designated")) {
    permissions=permissions.add(StreetTraversalPermission.BICYCLE);
    forceBikes=true;
  }
  if (way.isTag("cycleway","dismount") || way.isTag("bicycle","dismount")) {
    permissions=permissions.remove(StreetTraversalPermission.BICYCLE);
    if (forceBikes) {
      _log.warn("conflicting tags bicycle:[yes|designated] and cycleway:dismount on way " + way.getId() + ", assuming dismount");
    }
  }
  StreetTraversalPermission permissionsFront=permissions;
  StreetTraversalPermission permissionsBack=permissions;
  if (way.isTagTrue("oneway") || "roundabout".equals(tags.get("junction"))) {
    permissionsBack=permissionsBack.remove(StreetTraversalPermission.BICYCLE_AND_CAR);
  }
  if (way.isTag("oneway","-1")) {
    permissionsFront=permissionsFront.remove(StreetTraversalPermission.BICYCLE_AND_CAR);
  }
  if (way.isTagTrue("oneway:bicycle") || way.isTagFalse("bicycle:backwards")) {
    permissionsBack=permissionsBack.remove(StreetTraversalPermission.BICYCLE);
  }
  if (way.isTag("oneway:bicycle","-1")) {
    permissionsFront=permissionsFront.remove(StreetTraversalPermission.BICYCLE);
  }
  if (way.isTagFalse("oneway:bicycle") || way.isTagTrue("bicycle:backwards")) {
    if (permissions.allows(StreetTraversalPermission.BICYCLE)) {
      permissionsFront=permissionsFront.add(StreetTraversalPermission.BICYCLE);
      permissionsBack=permissionsBack.add(StreetTraversalPermission.BICYCLE);
    }
  }
  String cycleway=way.getTag("cycleway");
  String cyclewayLeft=way.getTag("cycleway:left");
  String cyclewayRight=way.getTag("cycleway:right");
  if (cycleway.startsWith("opposite") || cyclewayLeft.startsWith("opposite") || cyclewayRight.startsWith("opposite")) {
    permissionsBack=permissionsBack.add(StreetTraversalPermission.BICYCLE);
  }
  boolean noThruTraffic=way.isTag("access","destination") || way.isTag("access","private") || way.isTag("access","customers")|| way.isTag("access","delivery")|| way.isTag("access","forestry")|| way.isTag("access","agricultural");
  if (permissionsFront != StreetTraversalPermission.NONE) {
    street=getEdgeForStreet(start,end,way,startNode,d,permissionsFront,geometry,false);
    street.setNoThruTraffic(noThruTraffic);
  }
  if (permissionsBack != StreetTraversalPermission.NONE) {
    backStreet=getEdgeForStreet(end,start,way,startNode,d,permissionsBack,backGeometry,true);
    backStreet.setNoThruTraffic(noThruTraffic);
  }
  if ("roundabout".equals(tags.get("junction"))) {
    if (street != null)     street.setRoundabout(true);
    if (backStreet != null)     backStreet.setRoundabout(true);
  }
  return new P2<PlainStreetEdge>(street,backStreet);
}
