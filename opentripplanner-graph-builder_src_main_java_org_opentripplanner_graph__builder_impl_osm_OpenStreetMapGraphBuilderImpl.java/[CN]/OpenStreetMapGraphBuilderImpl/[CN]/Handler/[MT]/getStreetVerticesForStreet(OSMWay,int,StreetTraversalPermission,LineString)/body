{
  Coordinate[] coordinates=geometry.getCoordinates();
  double d=0;
  for (int i=1; i < coordinates.length; ++i) {
    d+=DistanceLibrary.distance(coordinates[i - 1],coordinates[i]);
  }
  LineString backGeometry=(LineString)geometry.reverse();
  Map<String,String> tags=way.getTags();
  if (permissions == StreetTraversalPermission.NONE)   return new P2<StreetVertex>(null,null);
  StreetVertex street=null, backStreet=null;
  if ("yes".equals(tags.get("oneway")) && ("no".equals(tags.get("oneway:bicycle")) || "opposite_lane".equals(tags.get("cycleway")) || "opposite".equals(tags.get("cycleway")))) {
    street=getStreetVertexForStreet(way,startNode,d,permissions,geometry,false);
    if (permissions.remove(StreetTraversalPermission.CAR) != StreetTraversalPermission.NONE)     backStreet=getStreetVertexForStreet(way,startNode,d,permissions.remove(StreetTraversalPermission.CAR),backGeometry,true);
  }
 else   if ("yes".equals(tags.get("oneway")) || "roundabout".equals(tags.get("junction"))) {
    street=getStreetVertexForStreet(way,startNode,d,permissions,geometry,false);
    if (permissions.allows(StreetTraversalPermission.PEDESTRIAN))     backStreet=getStreetVertexForStreet(way,startNode,d,StreetTraversalPermission.PEDESTRIAN,backGeometry,true);
  }
 else {
    street=getStreetVertexForStreet(way,startNode,d,permissions,geometry,false);
    backStreet=getStreetVertexForStreet(way,startNode,d,permissions,backGeometry,true);
  }
  for (  Map.Entry<P2<String>,P2<Double>> feature : safetyFeatures.entrySet()) {
    String key=feature.getKey().getFirst();
    String value=feature.getKey().getSecond();
    if (tags.get(key).equals(value)) {
      P2<Double> multipliers=feature.getValue();
      street.setBicycleSafetyEffectiveLength(street.getBicycleSafetyEffectiveLength() * multipliers.getFirst());
      backStreet.setBicycleSafetyEffectiveLength(backStreet.getBicycleSafetyEffectiveLength() * multipliers.getSecond());
    }
  }
  return new P2<StreetVertex>(street,backStreet);
}
