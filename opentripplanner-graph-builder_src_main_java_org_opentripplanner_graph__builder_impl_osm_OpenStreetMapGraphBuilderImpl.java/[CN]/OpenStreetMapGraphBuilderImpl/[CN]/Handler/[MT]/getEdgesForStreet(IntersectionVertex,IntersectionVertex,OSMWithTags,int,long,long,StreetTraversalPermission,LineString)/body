{
  Coordinate[] coordinates=geometry.getCoordinates();
  double d=0;
  for (int i=1; i < coordinates.length; ++i) {
    d+=distanceLibrary.distance(coordinates[i - 1],coordinates[i]);
  }
  LineString backGeometry=(LineString)geometry.reverse();
  Map<String,String> tags=way.getTags();
  if (permissions == StreetTraversalPermission.NONE)   return new P2<PlainStreetEdge>(null,null);
  PlainStreetEdge street=null, backStreet=null;
  String foot=way.getTag("foot");
  if ("yes".equals(foot) || "designated".equals(foot)) {
    permissions=permissions.add(StreetTraversalPermission.PEDESTRIAN);
  }
  if (OSMWithTags.isFalse(foot)) {
    permissions=permissions.remove(StreetTraversalPermission.PEDESTRIAN);
  }
  boolean forceBikes=false;
  String bicycle=way.getTag("bicycle");
  if ("yes".equals(bicycle) || "designated".equals(bicycle)) {
    permissions=permissions.add(StreetTraversalPermission.BICYCLE);
    forceBikes=true;
  }
  if (way.isTag("cycleway","dismount") || "dismount".equals(bicycle)) {
    permissions=permissions.remove(StreetTraversalPermission.BICYCLE);
    if (forceBikes) {
      _log.warn(graph.addBuilderAnnotation(new ConflictingBikeTags(way.getId())));
    }
  }
  P2<StreetTraversalPermission> permissionPair=getPermissions(permissions,way);
  StreetTraversalPermission permissionsFront=permissionPair.getFirst();
  StreetTraversalPermission permissionsBack=permissionPair.getSecond();
  if (permissionsFront != StreetTraversalPermission.NONE) {
    street=getEdgeForStreet(start,end,way,index,startNode,endNode,d,permissionsFront,geometry,false);
  }
  if (permissionsBack != StreetTraversalPermission.NONE) {
    backStreet=getEdgeForStreet(end,start,way,index,endNode,startNode,d,permissionsBack,backGeometry,true);
  }
  if ("roundabout".equals(tags.get("junction"))) {
    if (street != null)     street.setRoundabout(true);
    if (backStreet != null)     backStreet.setRoundabout(true);
  }
  return new P2<PlainStreetEdge>(street,backStreet);
}
