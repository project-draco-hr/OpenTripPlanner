{
  final int MAX_AREA_NODES=500;
  _log.debug("building visibility graphs for areas");
  for (  Area area : _areas) {
    Set<OSMNode> startingNodes=new HashSet<OSMNode>();
    List<Vertex> startingVertices=new ArrayList<Vertex>();
    Set<Edge> edges=new HashSet<Edge>();
    OSMWithTags areaEntity=area.parent;
    StreetTraversalPermission areaPermissions=getPermissionsForEntity(areaEntity,StreetTraversalPermission.PEDESTRIAN_AND_BICYCLE);
    if (areaPermissions == StreetTraversalPermission.NONE)     continue;
    setWayName(areaEntity);
    List<Point> vertices=new ArrayList<Point>();
    Set<Point> visibilityPoints=new HashSet<Point>();
    for (    Ring ring : area.outermostRings) {
      List<OSMNode> nodes=new ArrayList<OSMNode>();
      vertices.clear();
      for (      OSMNode node : ring.nodes) {
        if (nodes.contains(node)) {
          continue;
        }
        if (node == null) {
          throw new RuntimeException("node for area " + areaEntity.getId() + " does not exist");
        }
        Point point=new Point(node.getLon(),node.getLat());
        nodes.add(node);
        vertices.add(point);
      }
      Polygon polygon=new Polygon(vertices);
      if (polygon.area() < 0) {
        polygon.reverse();
        reversePolygonOfOSMNodes(nodes);
      }
      if (!polygon.is_in_standard_form()) {
        standardize(polygon.vertices,nodes);
      }
      int n=polygon.vertices.size();
      for (int i=0; i < n; ++i) {
        Point cur=polygon.vertices.get(i);
        Point prev=polygon.vertices.get((i + n - 1) % n);
        Point next=polygon.vertices.get((i + 1) % n);
        OSMNode curNode=nodes.get(i);
        if (_nodesWithNeighbors.contains(curNode.getId()) || multipleAreasContain(curNode.getId())) {
          visibilityPoints.add(cur);
          startingNodes.add(curNode);
        }
 else         if ((cur.x - prev.x) * (next.y - cur.y) - (cur.y - prev.y) * (next.x - cur.x) < 0) {
          visibilityPoints.add(cur);
        }
      }
      ArrayList<Polygon> polygons=new ArrayList<Polygon>();
      polygons.add(polygon);
      for (      Ring innerRing : ring.holes) {
        ArrayList<OSMNode> holeNodes=new ArrayList<OSMNode>();
        vertices=new ArrayList<Point>();
        for (        OSMNode node : innerRing.nodes) {
          if (holeNodes.contains(node)) {
            continue;
          }
          if (node == null) {
            throw new RuntimeException("node for area does not exist");
          }
          Point point=new Point(node.getLon(),node.getLat());
          holeNodes.add(node);
          vertices.add(point);
          visibilityPoints.add(point);
          if (_nodesWithNeighbors.contains(node.getId()) || multipleAreasContain(node.getId())) {
            startingNodes.add(node);
          }
        }
        Polygon hole=new Polygon(vertices);
        if (hole.area() > 0) {
          reversePolygonOfOSMNodes(holeNodes);
          hole.reverse();
        }
        if (!hole.is_in_standard_form()) {
          standardize(hole.vertices,holeNodes);
        }
        nodes.addAll(holeNodes);
        polygons.add(hole);
      }
      Environment areaEnv=new Environment(polygons);
      if (visibilityPoints.size() > MAX_AREA_NODES) {
        _log.warn("Area " + area.parent + " is too complicated ("+ visibilityPoints.size()+ " > "+ MAX_AREA_NODES);
        continue;
      }
      if (!areaEnv.is_valid(VISIBILITY_EPSILON)) {
        _log.warn("Area " + area.parent + " is not epsilon-valid (epsilon = "+ VISIBILITY_EPSILON+ ")");
        continue;
      }
      VisibilityGraph vg=new VisibilityGraph(areaEnv,VISIBILITY_EPSILON,visibilityPoints);
      AreaEdgeList edgeList=new AreaEdgeList();
      for (int i=0; i < nodes.size(); ++i) {
        OSMNode nodeI=nodes.get(i);
        for (int j=0; j < nodes.size(); ++j) {
          if (i == j)           continue;
          if (vg.get(0,i,0,j)) {
            IntersectionVertex startEndpoint=getVertexForOsmNode(nodeI,areaEntity);
            OSMNode nodeJ=nodes.get(j);
            IntersectionVertex endEndpoint=getVertexForOsmNode(nodeJ,areaEntity);
            Coordinate[] coordinates=new Coordinate[]{startEndpoint.getCoordinate(),endEndpoint.getCoordinate()};
            LineString geometry=GeometryUtils.getGeometryFactory().createLineString(coordinates);
            String id="way (area) " + areaEntity.getId() + " from "+ nodeI.getId()+ " to "+ nodeJ.getId();
            id=unique(id);
            String name=getNameForWay(areaEntity,id);
            double length=distanceLibrary.distance(startEndpoint.getCoordinate(),endEndpoint.getCoordinate());
            AreaEdge street=edgeFactory.createAreaEdge(nodeI,nodeJ,areaEntity,startEndpoint,endEndpoint,geometry,name,length,areaPermissions,i > j,edgeList);
            street.setId(id);
            edges.add(street);
            if (startingNodes.contains(nodeI)) {
              startingVertices.add(startEndpoint);
            }
          }
        }
      }
    }
    pruneAreaEdges(startingVertices,edges);
  }
}
