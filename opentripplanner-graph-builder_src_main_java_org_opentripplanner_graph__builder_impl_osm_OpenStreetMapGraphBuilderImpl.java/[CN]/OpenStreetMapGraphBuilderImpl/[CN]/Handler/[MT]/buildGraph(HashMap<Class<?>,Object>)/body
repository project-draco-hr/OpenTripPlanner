{
  processRelations();
  if (staticBikeRental) {
    processBikeRentalNodes();
  }
  HashSet<Long> _keep=new HashSet<Long>(_nodesWithNeighbors);
  _keep.addAll(_areaNodes);
  _nodes.keySet().retainAll(_keep);
  initIntersectionNodes();
  buildBasicGraph();
  buildAreas();
  buildElevatorEdges(graph);
  for (  List<TurnRestrictionTag> restrictions : turnRestrictionsByFromWay.values()) {
    for (    TurnRestrictionTag restrictionTag : restrictions) {
      if (restrictionTag.possibleFrom.isEmpty()) {
        _log.warn("No from edge found for " + restrictionTag);
        continue;
      }
      if (restrictionTag.possibleTo.isEmpty()) {
        _log.warn("No to edge found for " + restrictionTag);
        continue;
      }
      for (      PlainStreetEdge from : restrictionTag.possibleFrom) {
        if (from == null) {
          _log.warn("from-edge is null in turn " + restrictionTag);
          continue;
        }
        for (        PlainStreetEdge to : restrictionTag.possibleTo) {
          if (from == null || to == null) {
            continue;
          }
          int angleDiff=from.getOutAngle() - to.getInAngle();
          if (angleDiff < 0) {
            angleDiff+=360;
          }
switch (restrictionTag.direction) {
case LEFT:
            if (angleDiff >= 160) {
              continue;
            }
          break;
case RIGHT:
        if (angleDiff <= 200)         continue;
      break;
case U:
    if ((angleDiff <= 150 || angleDiff > 210))     continue;
  break;
case STRAIGHT:
if (angleDiff >= 30 && angleDiff < 330) continue;
break;
}
TurnRestriction restriction=new TurnRestriction();
restriction.from=from;
restriction.to=to;
restriction.type=restrictionTag.type;
restriction.modes=restrictionTag.modes;
restriction.time=restrictionTag.time;
from.addTurnRestriction(restriction);
}
}
}
}
if (customNamer != null) {
customNamer.postprocess(graph);
}
extra.put(ElevationPoint.class,elevationData);
applyBikeSafetyFactor(graph);
}
