{
  this.graph=graph;
  processRelations();
  _nodes.keySet().retainAll(_nodesWithNeighbors);
  long wayIndex=0;
  Set<Long> possibleIntersectionNodes=new HashSet<Long>();
  Set<Long> intersectionNodes=new HashSet<Long>();
  HashMap<Long,HashMap> multiLevelNodesLevels=new HashMap<Long,HashMap>();
  for (  OSMWay way : _ways.values()) {
    List<Long> nodes=way.getNodeRefs();
    for (    long node : nodes) {
      if (possibleIntersectionNodes.contains(node)) {
        intersectionNodes.add(node);
      }
 else {
        possibleIntersectionNodes.add(node);
      }
    }
  }
  GeometryFactory geometryFactory=new GeometryFactory();
  ArrayList<Vertex> endpoints=new ArrayList<Vertex>();
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 10000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    WayProperties wayData=wayPropertySet.getDataForWay(way);
    if (!way.hasTag("name")) {
      String creativeName=wayPropertySet.getCreativeNameForWay(way);
      if (creativeName != null) {
        way.addTag("otp:gen_name",creativeName);
      }
    }
    Set<Alert> note=wayPropertySet.getNoteForWay(way);
    StreetTraversalPermission permissions=getPermissionsForEntity(way,wayData.getPermission());
    if (permissions == StreetTraversalPermission.NONE)     continue;
    List<Long> nodes=way.getNodeRefs();
    Vertex startEndpoint=null, endEndpoint=null;
    ArrayList<Coordinate> segmentCoordinates=new ArrayList<Coordinate>();
    if (way.hasTag("otp:numeric_level")) {
    }
 else     if (way.hasTag("level")) {
      String level=way.getTag("level");
      way.addTag("otp:numeric_level",Integer.toString(Integer.parseInt(level) + 1000));
      way.addTag("otp:human_level",level);
    }
 else     if (way.hasTag("layer")) {
      String layer=way.getTag("layer");
      way.addTag("otp:numeric_level",Integer.toString(Integer.parseInt(layer) + 2000));
      way.addTag("otp:human_level",layer);
    }
 else {
      way.addTag("otp:numeric_level","3000");
      way.addTag("otp:human_level","ground level");
    }
    Long startNode=null;
    OSMNode osmStartNode=null;
    for (int i=0; i < nodes.size() - 1; i++) {
      Long endNode=nodes.get(i + 1);
      if (osmStartNode == null) {
        startNode=nodes.get(i);
        osmStartNode=_nodes.get(startNode);
      }
      OSMNode osmEndNode=_nodes.get(endNode);
      if (osmStartNode == null || osmEndNode == null)       continue;
      LineString geometry;
      if (segmentCoordinates.size() == 0) {
        segmentCoordinates.add(getCoordinate(osmStartNode));
      }
      if (intersectionNodes.contains(endNode) || i == nodes.size() - 2) {
        segmentCoordinates.add(getCoordinate(osmEndNode));
        geometry=geometryFactory.createLineString(segmentCoordinates.toArray(new Coordinate[0]));
        segmentCoordinates.clear();
      }
 else {
        segmentCoordinates.add(getCoordinate(osmEndNode));
        continue;
      }
      if (startEndpoint == null) {
        String label=getVertexLabelFromNode(osmStartNode,way);
        if (isMultiLevelNode(osmStartNode)) {
          HashMap<Integer,String> levels;
          int level=Integer.parseInt(way.getTag("otp:numeric_level"));
          if (multiLevelNodesLevels.containsKey(osmStartNode.getId())) {
            levels=multiLevelNodesLevels.get(osmStartNode.getId());
          }
 else {
            levels=new HashMap<Integer,String>();
            multiLevelNodesLevels.put(osmStartNode.getId(),levels);
          }
          if (!levels.containsKey(level)) {
            levels.put(level,way.getTag("otp:human_level"));
          }
 else           if (!levels.get(level).equals(way.getTag("otp:human_level"))) {
            throw new IllegalStateException("Multiple levels have the same " + "level number!");
          }
        }
        startEndpoint=graph.getVertex(label);
        if (startEndpoint == null) {
          Coordinate coordinate=getCoordinate(osmStartNode);
          startEndpoint=new EndpointVertex(label,coordinate.x,coordinate.y,label);
          graph.addVertex(startEndpoint);
          endpoints.add(startEndpoint);
        }
      }
 else {
        startEndpoint=endEndpoint;
      }
      String label=getVertexLabelFromNode(osmEndNode,way);
      if (isMultiLevelNode(osmEndNode)) {
        HashMap<Integer,String> levels;
        int level=Integer.parseInt(way.getTag("otp:numeric_level"));
        if (multiLevelNodesLevels.containsKey(osmEndNode.getId())) {
          levels=multiLevelNodesLevels.get(osmEndNode.getId());
        }
 else {
          levels=new HashMap<Integer,String>();
          multiLevelNodesLevels.put(osmEndNode.getId(),levels);
        }
        if (!levels.containsKey(level)) {
          levels.put(level,way.getTag("otp:human_level"));
        }
 else         if (!levels.get(level).equals(way.getTag("otp:human_level"))) {
          throw new IllegalStateException("Multiple levels have the same " + "level number!");
        }
      }
      endEndpoint=graph.getVertex(label);
      if (endEndpoint == null) {
        Coordinate coordinate=getCoordinate(osmEndNode);
        endEndpoint=new EndpointVertex(label,coordinate.x,coordinate.y,label);
        graph.addVertex(endEndpoint);
        endpoints.add(endEndpoint);
      }
      P2<PlainStreetEdge> streets=getEdgesForStreet(startEndpoint,endEndpoint,way,i,permissions,geometry);
      PlainStreetEdge street=streets.getFirst();
      if (street != null) {
        graph.addEdge(street);
        double safety=wayData.getSafetyFeatures().getFirst();
        street.setBicycleSafetyEffectiveLength(street.getLength() * safety);
        if (safety < bestBikeSafety) {
          bestBikeSafety=safety;
        }
        if (note != null) {
          street.setNote(note);
        }
      }
      PlainStreetEdge backStreet=streets.getSecond();
      if (backStreet != null) {
        graph.addEdge(backStreet);
        double safety=wayData.getSafetyFeatures().getSecond();
        if (safety < bestBikeSafety) {
          bestBikeSafety=safety;
        }
        backStreet.setBicycleSafetyEffectiveLength(backStreet.getLength() * safety);
        if (note != null) {
          backStreet.setNote(note);
        }
      }
      List<TurnRestrictionTag> restrictionTags=turnRestrictionsByFromWay.get(way.getId());
      if (restrictionTags != null) {
        for (        TurnRestrictionTag tag : restrictionTags) {
          if (tag.via == startNode) {
            TurnRestriction restriction=turnRestrictionsByTag.get(tag);
            restriction.from=backStreet;
          }
 else           if (tag.via == endNode) {
            TurnRestriction restriction=turnRestrictionsByTag.get(tag);
            restriction.from=street;
          }
        }
      }
      restrictionTags=turnRestrictionsByToWay.get(way.getId());
      if (restrictionTags != null) {
        for (        TurnRestrictionTag tag : restrictionTags) {
          if (tag.via == startNode) {
            TurnRestriction restriction=turnRestrictionsByTag.get(tag);
            restriction.to=street;
          }
 else           if (tag.via == endNode) {
            TurnRestriction restriction=turnRestrictionsByTag.get(tag);
            restriction.to=backStreet;
          }
        }
      }
      startNode=endNode;
      osmStartNode=_nodes.get(startNode);
    }
  }
  for (  Long nodeId : multiLevelNodesLevels.keySet()) {
    OSMNode node=_nodes.get(nodeId);
    HashMap<Integer,String> levels=multiLevelNodesLevels.get(nodeId);
    ArrayList<Vertex> onboardVertices=new ArrayList<Vertex>();
    Integer[] levelKeys=levels.keySet().toArray(new Integer[0]);
    Arrays.sort(levelKeys);
    for (    Integer level : levelKeys) {
      String humanLevel=levels.get(level);
      String sourceVertLabel="osm node " + nodeId + "_"+ humanLevel;
      EndpointVertex sourceVert=(EndpointVertex)graph.getVertex(sourceVertLabel);
      Vertex middleVert=new Vertex(sourceVertLabel + "_middle",sourceVert.getX(),sourceVert.getY());
      graph.addVertex(middleVert);
      FreeEdge free=new FreeEdge(sourceVert,middleVert);
      FreeEdge back=new FreeEdge(middleVert,sourceVert);
      graph.addEdge(free);
      graph.addEdge(back);
      Vertex onboardVert=new Vertex(sourceVertLabel + "_onboard",sourceVert.getX(),sourceVert.getY());
      graph.addVertex(onboardVert);
      ElevatorBoardEdge board=new ElevatorBoardEdge(middleVert,onboardVert);
      graph.addEdge(board);
      ElevatorAlightEdge alight=new ElevatorAlightEdge(onboardVert,middleVert,humanLevel);
      graph.addEdge(alight);
      onboardVertices.add(onboardVert);
    }
    Integer vSize=onboardVertices.size() - 1;
    for (Integer i=0; i < vSize; i++) {
      Vertex from=onboardVertices.get(i);
      Vertex to=onboardVertices.get(i + 1);
      ElevatorHopEdge theEdge=new ElevatorHopEdge(from,to,StreetTraversalPermission.PEDESTRIAN);
      ElevatorHopEdge backEdge=new ElevatorHopEdge(to,from,StreetTraversalPermission.PEDESTRIAN);
      graph.addEdge(theEdge);
      graph.addEdge(backEdge);
    }
  }
  Map<Edge,TurnRestriction> turnRestrictions=new HashMap<Edge,TurnRestriction>();
  for (  TurnRestriction restriction : turnRestrictionsByTag.values()) {
    turnRestrictions.put(restriction.from,restriction);
  }
  if (customNamer != null) {
    customNamer.postprocess(graph);
  }
  applyBikeSafetyFactor(graph);
  StreetUtils.pruneFloatingIslands(graph);
  StreetUtils.makeEdgeBased(graph,endpoints,turnRestrictions);
}
