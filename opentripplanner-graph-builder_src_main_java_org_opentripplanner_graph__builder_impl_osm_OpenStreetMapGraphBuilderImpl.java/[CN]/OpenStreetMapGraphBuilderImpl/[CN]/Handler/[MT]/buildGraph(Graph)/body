{
  Set<Integer> nodesWithNeighbors=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    if (nodes.size() > 1)     nodesWithNeighbors.addAll(nodes);
  }
  _nodes.keySet().retainAll(nodesWithNeighbors);
  pruneFloatingIslands();
  HashMap<Coordinate,ArrayList<Edge>> edgesByLocation=new HashMap<Coordinate,ArrayList<Edge>>();
  int wayIndex=0;
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 1000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    StreetTraversalPermission permissions=getPermissionsForEntity(way);
    if (permissions == StreetTraversalPermission.NONE)     continue;
    List<Integer> nodes=way.getNodeRefs();
    for (int i=0; i < nodes.size() - 1; i++) {
      Integer startNode=nodes.get(i);
      String vFromId=getVertexIdForNodeId(startNode) + "_" + i+ "_"+ way.getId();
      Integer endNode=nodes.get(i + 1);
      String vToId=getVertexIdForNodeId(endNode) + "_" + i+ "_"+ way.getId();
      OSMNode osmStartNode=_nodes.get(startNode);
      OSMNode osmEndNode=_nodes.get(endNode);
      if (osmStartNode == null || osmEndNode == null)       continue;
      Vertex from=addVertex(graph,vFromId,osmStartNode);
      Vertex to=addVertex(graph,vToId,osmEndNode);
      double d=from.distance(to);
      Street street=getEdgeForStreet(from,to,way,d,permissions);
      graph.addEdge(street);
      Street backStreet=getEdgeForStreet(to,from,way,d,permissions);
      graph.addEdge(backStreet);
      ArrayList<Edge> startEdges=edgesByLocation.get(from.getCoordinate());
      if (startEdges == null) {
        startEdges=new ArrayList<Edge>();
        edgesByLocation.put(from.getCoordinate(),startEdges);
      }
      startEdges.add(street);
      ArrayList<Edge> endEdges=edgesByLocation.get(to.getCoordinate());
      if (endEdges == null) {
        endEdges=new ArrayList<Edge>();
        edgesByLocation.put(to.getCoordinate(),endEdges);
      }
      endEdges.add(backStreet);
    }
  }
  for (  ArrayList<Edge> edges : edgesByLocation.values()) {
    for (    Edge in : edges) {
      Vertex tov=in.getToVertex();
      Coordinate c=tov.getCoordinate();
      ArrayList<Edge> outEdges=edgesByLocation.get(c);
      if (outEdges != null) {
        boolean unified=false;
        if (outEdges.size() == 2) {
          for (          Edge out : outEdges) {
            Vertex fromVertex=out.getFromVertex();
            if (tov != fromVertex && out.getName() == in.getName()) {
              Intersection v=(Intersection)tov;
              v.mergeFrom(graph,(Intersection)fromVertex);
              graph.removeVertex(fromVertex);
              unified=true;
              break;
            }
          }
        }
        if (!unified) {
          for (          Edge out : outEdges) {
            if (tov != out.getFromVertex() && out instanceof Street && out.getFromVertex().getCoordinate().equals(c)) {
              graph.addEdge(new Turn(in,out));
            }
          }
        }
      }
    }
  }
}
