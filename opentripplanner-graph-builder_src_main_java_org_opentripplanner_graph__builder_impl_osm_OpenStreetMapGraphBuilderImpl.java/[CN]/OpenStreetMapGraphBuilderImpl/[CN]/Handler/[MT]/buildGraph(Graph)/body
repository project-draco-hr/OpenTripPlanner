{
  Set<Integer> nodesWithNeighbors=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    if (nodes.size() > 1)     nodesWithNeighbors.addAll(nodes);
  }
  _nodes.keySet().retainAll(nodesWithNeighbors);
  pruneFloatingIslands();
  int wayIndex=0;
  Set<Integer> possibleIntersectionNodes=new HashSet<Integer>();
  Set<Integer> intersectionNodes=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    for (    int node : nodes) {
      if (possibleIntersectionNodes.contains(node)) {
        intersectionNodes.add(node);
      }
 else {
        possibleIntersectionNodes.add(node);
      }
    }
  }
  ArrayList<P2<EndpointVertex>> endpoints=new ArrayList<P2<EndpointVertex>>();
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 1000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    StreetTraversalPermission permissions=getPermissionsForEntity(way);
    if (permissions == StreetTraversalPermission.NONE)     continue;
    List<Integer> nodes=way.getNodeRefs();
    P2<EndpointVertex> startEndpoints=null, endEndpoints=null;
    ArrayList<Coordinate> segmentCoordinates=new ArrayList<Coordinate>();
    GeometryFactory geometryFactory=new GeometryFactory();
    Integer startNode=null;
    OSMNode osmStartNode=null;
    for (int i=0; i < nodes.size() - 1; i++) {
      Integer endNode=nodes.get(i + 1);
      if (osmStartNode == null) {
        startNode=nodes.get(i);
        osmStartNode=_nodes.get(startNode);
      }
      OSMNode osmEndNode=_nodes.get(endNode);
      if (osmStartNode == null || osmEndNode == null)       continue;
      LineString geometry;
      if (segmentCoordinates.size() == 0) {
        segmentCoordinates.add(getCoordinate(osmStartNode));
      }
      if (intersectionNodes.contains(endNode) || i == nodes.size() - 2) {
        segmentCoordinates.add(getCoordinate(osmEndNode));
        geometry=geometryFactory.createLineString(segmentCoordinates.toArray(new Coordinate[0]));
        segmentCoordinates.clear();
      }
 else {
        segmentCoordinates.add(getCoordinate(osmEndNode));
        continue;
      }
      if (startEndpoints == null) {
        String label="osm node " + osmStartNode.getId();
        startEndpoints=new P2<EndpointVertex>((EndpointVertex)graph.getVertex(label + " in"),(EndpointVertex)graph.getVertex(label + " out"));
        if (startEndpoints.getFirst() == null) {
          Coordinate coordinate=getCoordinate(osmStartNode);
          EndpointVertex in=new EndpointVertex(label + " in",coordinate.x,coordinate.y,label);
          in=(EndpointVertex)graph.addVertex(in);
          EndpointVertex out=new EndpointVertex(label + " out",coordinate.x,coordinate.y,label);
          out=(EndpointVertex)graph.addVertex(out);
          startEndpoints=new P2<EndpointVertex>(in,out);
          endpoints.add(startEndpoints);
        }
      }
 else {
        startEndpoints=endEndpoints;
      }
      String label="osm node " + osmEndNode.getId();
      endEndpoints=new P2<EndpointVertex>((EndpointVertex)graph.getVertex(label + " in"),(EndpointVertex)graph.getVertex(label + " out"));
      if (endEndpoints.getFirst() == null) {
        Coordinate coordinate=getCoordinate(osmEndNode);
        EndpointVertex in=new EndpointVertex(label + " in",coordinate.x,coordinate.y,label);
        in=(EndpointVertex)graph.addVertex(in);
        EndpointVertex out=new EndpointVertex(label + " out",coordinate.x,coordinate.y,label);
        out=(EndpointVertex)graph.addVertex(out);
        endEndpoints=new P2<EndpointVertex>(in,out);
        endpoints.add(endEndpoints);
      }
      P2<StreetVertex> streets=getStreetVerticesForStreet(way,i,permissions,geometry);
      StreetVertex street=streets.getFirst();
      if (street != null) {
        graph.addVertex(street);
        FreeEdge in=new FreeEdge(startEndpoints.getSecond(),street);
        OutEdge out=new OutEdge(street,endEndpoints.getFirst());
        graph.addEdge(in);
        graph.addEdge(out);
      }
      StreetVertex backStreet=streets.getSecond();
      if (backStreet != null) {
        graph.addVertex(backStreet);
        FreeEdge in=new FreeEdge(endEndpoints.getSecond(),backStreet);
        OutEdge out=new OutEdge(backStreet,startEndpoints.getFirst());
        graph.addEdge(in);
        graph.addEdge(out);
      }
      startNode=endNode;
      osmStartNode=_nodes.get(startNode);
    }
  }
  for (  P2<EndpointVertex> vertices : endpoints) {
    Vertex in=vertices.getFirst();
    Vertex out=vertices.getSecond();
    for (    Edge e : graph.getIncoming(in)) {
      StreetVertex v1=(StreetVertex)e.getFromVertex();
      for (      Edge e2 : graph.getOutgoing(out)) {
        StreetVertex v2=(StreetVertex)e2.getToVertex();
        if (v1 != v2 && v1.getEdgeId() != v2.getEdgeId()) {
          graph.addEdge(new TurnEdge(v1,v2));
        }
      }
    }
  }
  StreetUtils.unify(graph,endpoints);
}
