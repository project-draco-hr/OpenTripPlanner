{
  Set<Integer> nodesWithNeighbors=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    if (nodes.size() > 1)     nodesWithNeighbors.addAll(nodes);
  }
  _nodes.keySet().retainAll(nodesWithNeighbors);
  pruneFloatingIslands();
  HashMap<Coordinate,ArrayList<Edge>> edgesByLocation=new HashMap<Coordinate,ArrayList<Edge>>();
  int wayIndex=0;
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 1000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    StreetTraversalPermission permissions=getPermissionsForEntity(way);
    if (permissions == StreetTraversalPermission.NONE)     continue;
    List<Integer> nodes=way.getNodeRefs();
    for (int i=0; i < nodes.size() - 1; i++) {
      Integer startNode=nodes.get(i);
      String vFromId=getVertexIdForNodeId(startNode) + "_" + i+ "_"+ way.getId();
      Integer endNode=nodes.get(i + 1);
      String vToId=getVertexIdForNodeId(endNode) + "_" + i+ "_"+ way.getId();
      OSMNode osmStartNode=_nodes.get(startNode);
      OSMNode osmEndNode=_nodes.get(endNode);
      if (osmStartNode == null || osmEndNode == null)       continue;
      Vertex from=addVertex(graph,vFromId,osmStartNode);
      Vertex to=addVertex(graph,vToId,osmEndNode);
      ArrayList<Street> streets=getEdgesForStreet(from,to,way,permissions);
      for (      Street street : streets) {
        graph.addEdge(street);
        Vertex start=street.getFromVertex();
        ArrayList<Edge> edges=edgesByLocation.get(start.getCoordinate());
        if (edges == null) {
          edges=new ArrayList<Edge>();
          edgesByLocation.put(start.getCoordinate(),edges);
        }
        edges.add(street);
      }
    }
  }
  for (  ArrayList<Edge> edges : edgesByLocation.values()) {
    for (    Edge in : edges) {
      Vertex tov=in.getToVertex();
      Coordinate c=tov.getCoordinate();
      ArrayList<Edge> outEdges=edgesByLocation.get(c);
      if (outEdges != null) {
        boolean unified=false;
        if (outEdges.size() == 1) {
          Edge out=outEdges.get(0);
          Vertex fromVertex=out.getFromVertex();
          if (tov != fromVertex && out.getName() == in.getName()) {
            Intersection v=(Intersection)tov;
            v.mergeFrom(graph,(Intersection)fromVertex);
            graph.removeVertex(fromVertex);
            unified=true;
          }
        }
 else         if (outEdges.size() == 2) {
          if (outEdges.get(0).getToVertex() == in.getFromVertex() || outEdges.get(1).getToVertex() == in.getFromVertex()) {
            for (            Edge out : outEdges) {
              Vertex fromVertex=out.getFromVertex();
              if (tov != fromVertex && out.getName() == in.getName()) {
                Intersection v=(Intersection)tov;
                v.mergeFrom(graph,(Intersection)fromVertex);
                graph.removeVertex(fromVertex);
                unified=true;
                break;
              }
            }
          }
        }
        if (!unified) {
          for (          Edge out : outEdges) {
            if (tov != out.getFromVertex() && out instanceof Street && out.getFromVertex().getCoordinate().equals(c)) {
              graph.addEdge(new Turn(in,out));
            }
          }
        }
      }
    }
  }
}
