{
  Set<Integer> nodesWithNeighbors=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    if (nodes.size() > 1)     nodesWithNeighbors.addAll(nodes);
  }
  _nodes.keySet().retainAll(nodesWithNeighbors);
  pruneFloatingIslands();
  int nodeIndex=0;
  for (  OSMNode node : _nodes.values()) {
    if (nodeIndex % 1000 == 0)     _log.debug("nodes=" + nodeIndex + "/"+ _nodes.size());
    nodeIndex++;
    int nodeId=node.getId();
    String id=getVertexIdForNodeId(nodeId);
    Vertex vertex=graph.getVertex(id);
    if (vertex != null)     throw new IllegalStateException("osm node already loaded: id=" + id);
    GenericVertex newVertex=new GenericVertex(id,node.getLon(),node.getLat());
    newVertex.setType(Intersection.class);
    graph.addVertex(newVertex);
  }
  int wayIndex=0;
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 1000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    StreetTraversalPermission permissions=getPermissionsForWay(way);
    List<Integer> nodes=way.getNodeRefs();
    for (int i=0; i < nodes.size() - 1; i++) {
      String vFromId=getVertexIdForNodeId(nodes.get(i));
      String vToId=getVertexIdForNodeId(nodes.get(i + 1));
      Vertex from=graph.getVertex(vFromId);
      Vertex to=graph.getVertex(vToId);
      if (from == null || to == null)       continue;
      double d=from.distance(to);
      graph.addEdge(getEdgeForStreet(from,to,way,d,permissions));
      graph.addEdge(getEdgeForStreet(to,from,way,d,permissions));
    }
  }
}
