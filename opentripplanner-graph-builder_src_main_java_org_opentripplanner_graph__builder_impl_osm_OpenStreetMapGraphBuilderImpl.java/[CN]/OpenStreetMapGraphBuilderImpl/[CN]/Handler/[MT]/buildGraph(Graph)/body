{
  Set<Integer> nodesWithNeighbors=new HashSet<Integer>();
  for (  OSMWay way : _ways.values()) {
    List<Integer> nodes=way.getNodeRefs();
    if (nodes.size() > 1)     nodesWithNeighbors.addAll(nodes);
  }
  _nodes.keySet().retainAll(nodesWithNeighbors);
  int nodeIndex=0;
  for (  OSMNode node : _nodes.values()) {
    if (nodeIndex % 1000 == 0)     _log.debug("nodes=" + nodeIndex + "/"+ _nodes.size());
    nodeIndex++;
    int nodeId=node.getId();
    String id=getVertexIdForNodeId(nodeId);
    Vertex vertex=graph.getVertex(id);
    if (vertex != null)     throw new IllegalStateException("osm node already loaded: id=" + id);
    vertex=new SameInAndOutVertex(id,Intersection.class,node.getLon(),node.getLat());
    graph.addVertex(vertex);
  }
  int wayIndex=0;
  for (  OSMWay way : _ways.values()) {
    if (wayIndex % 1000 == 0)     _log.debug("ways=" + wayIndex + "/"+ _ways.size());
    wayIndex++;
    StreetTraversalPermission permissions=getPermissionsForWay(way);
    List<Integer> nodes=way.getNodeRefs();
    for (int i=0; i < nodes.size() - 1; i++) {
      String vFromId=getVertexIdForNodeId(nodes.get(i));
      String vToId=getVertexIdForNodeId(nodes.get(i + 1));
      SameInAndOutVertex from=(SameInAndOutVertex)graph.getVertex(vFromId);
      SameInAndOutVertex to=(SameInAndOutVertex)graph.getVertex(vToId);
      if (from == null || to == null)       continue;
      double d=from.distance(to);
      from.addEdge(getEdgeForStreet(from,to,way,d,permissions));
      to.addEdge(getEdgeForStreet(to,from,way,d,permissions));
    }
  }
}
