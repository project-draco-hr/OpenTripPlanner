{
  long beginCalcTime=System.currentTimeMillis();
  long totalPropagationTime=0;
  TIntIntMap initialStops=new TIntIntHashMap();
  TIntIntIterator initialIterator=accessTimes.iterator();
  while (initialIterator.hasNext()) {
    initialIterator.advance();
    int stopIndex=initialIterator.key();
    int accessTime=initialIterator.value();
    initialStops.put(stopIndex,accessTime);
  }
  PropagatedTimesStore propagatedTimesStore=new PropagatedTimesStore(graph,data.nTargets);
  int iterations=(req.toTime - req.fromTime - 60) / 60 + 1;
  iterations*=MONTE_CARLO_COUNT_PER_MINUTE;
  ts.searchCount=iterations;
  int[][] timesAtTargetsEachIteration=new int[iterations][data.nTargets];
  ts.timeStep=60;
  int[] scheduledTimesAtTargets=new int[data.nTargets];
  System.arraycopy(walkTimes,0,scheduledTimesAtTargets,0,scheduledTimesAtTargets.length);
  int iteration=0;
  for (int departureTime=req.toTime - 60, n=0; departureTime >= req.fromTime; departureTime-=60, n++) {
    if (n % 15 == 0) {
      LOG.info("minute {}",n);
    }
    this.runRaptorScheduled(initialStops,departureTime);
    this.doPropagation(bestNonTransferTimes,scheduledTimesAtTargets,departureTime);
    for (int i=0; i < MONTE_CARLO_COUNT_PER_MINUTE; i++) {
      data.randomizeOffsets();
      int[] bestTimesCopy=Arrays.copyOf(bestTimes,bestTimes.length);
      int[] bestNonTransferTimesCopy=Arrays.copyOf(bestNonTransferTimes,bestNonTransferTimes.length);
      int[] previousPatternsCopy=Arrays.copyOf(previousPatterns,previousPatterns.length);
      this.runRaptorFrequency(departureTime,bestTimesCopy,bestNonTransferTimesCopy,previousPatternsCopy);
      int[] frequencyTimesAtTargets=timesAtTargetsEachIteration[iteration++];
      System.arraycopy(scheduledTimesAtTargets,0,frequencyTimesAtTargets,0,scheduledTimesAtTargets.length);
      this.doPropagation(bestNonTransferTimesCopy,frequencyTimesAtTargets,departureTime);
    }
  }
  long calcTime=System.currentTimeMillis() - beginCalcTime;
  LOG.info("calc time {}sec",calcTime / 1000.0);
  LOG.info("  propagation {}sec",totalPropagationTime / 1000.0);
  LOG.info("  raptor {}sec",(calcTime - totalPropagationTime) / 1000.0);
  ts.propagation=(int)totalPropagationTime;
  ts.transitSearch=(int)(calcTime - totalPropagationTime);
  propagatedTimesStore.setFromArray(timesAtTargetsEachIteration);
  return propagatedTimesStore;
}
