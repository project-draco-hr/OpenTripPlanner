{
  State orig=this;
  State unoptimized=orig;
  State ret=orig.reversedClone();
  long newInitialWaitTime=-1;
  boolean needToFigureInAdditionalWaitTime=false;
  PathParser pathParsers[];
  pathParsers=stateData.opt.rctx.pathParsers;
  stateData.opt.rctx.pathParsers=new PathParser[0];
  Edge edge=null;
  try {
    while (orig.getBackState() != null) {
      edge=orig.getBackEdge();
      if (optimize) {
        if (edge instanceof PatternBoard && orig.getNumBoardings() == 1 && forward)         ret=((PatternBoard)edge).traverse(ret,orig.getTime());
 else         ret=edge.traverse(ret);
        if (ret == null)         LOG.debug("Error traversing edge " + edge + " in reverse optimization");
      }
 else {
        EdgeNarrative narrative=orig.getBackEdgeNarrative();
        StateEditor editor=ret.edit(edge,narrative);
        editor.setFromState(orig);
        editor.incrementTimeInSeconds(orig.getAbsTimeDeltaSec());
        editor.incrementWeight(orig.getWeightDelta());
        editor.incrementWalkDistance(orig.getWalkDistanceDelta());
        if (orig.isBikeRenting() != orig.getBackState().isBikeRenting())         editor.setBikeRenting(!orig.isBikeRenting());
        ret=editor.makeState();
        EdgeNarrative origNarrative=orig.getBackEdgeNarrative();
        EdgeNarrative retNarrative=ret.getBackEdgeNarrative();
        copyExistingNarrativeToNewNarrativeAsAppropriate(origNarrative,retNarrative);
      }
      orig=orig.getBackState();
    }
  }
 catch (  NullPointerException e) {
    LOG.warn("Cannot reverse path at edge: " + edge + ", returning unoptimized path. If edge is a PatternInterlineDwell,"+ " this is not totally unexpected; otherwise, you might want to"+ " look into it");
    stateData.opt.rctx.pathParsers=pathParsers;
    if (forward)     return this;
 else     return unoptimized.reverse();
  }
  stateData.opt.rctx.pathParsers=pathParsers;
  if (forward) {
    return ret.reverse();
  }
 else   return ret;
}
