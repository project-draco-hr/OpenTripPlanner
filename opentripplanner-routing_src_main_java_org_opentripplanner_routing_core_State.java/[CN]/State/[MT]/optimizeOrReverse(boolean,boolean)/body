{
  State orig=this;
  State unoptimized=orig;
  State ret=orig.reversedClone();
  long newInitialWaitTime=this.stateData.initialWaitTime;
  PathParser pathParsers[];
  pathParsers=stateData.opt.rctx.pathParsers;
  stateData.opt.rctx.pathParsers=new PathParser[0];
  Edge edge=null;
  while (orig.getBackState() != null) {
    edge=orig.getBackEdge();
    if (optimize) {
      if (edge instanceof TransitBoardAlight && forward && orig.getNumBoardings() == 1 && ((((TransitBoardAlight)edge).isBoarding() && !stateData.opt.isArriveBy()) || (!((TransitBoardAlight)edge).isBoarding() && stateData.opt.isArriveBy()))) {
        ret=((TransitBoardAlight)edge).traverse(ret,orig.getBackState().getTime());
        newInitialWaitTime=ret.stateData.initialWaitTime;
      }
 else       ret=edge.traverse(ret);
      if (ret == null) {
        LOG.warn("Cannot reverse path at edge: " + edge + ", returning unoptimized path. If edge is a "+ "PatternInterlineDwell, this is not totally unexpected; "+ "otherwise, you might want to look into it");
        stateData.opt.rctx.pathParsers=pathParsers;
        if (forward)         return this;
 else         return unoptimized.reverse();
      }
    }
 else {
      EdgeNarrative narrative=orig.getBackEdgeNarrative();
      StateEditor editor=ret.edit(edge,narrative);
      editor.setFromState(orig);
      editor.incrementTimeInSeconds(orig.getAbsTimeDeltaSec());
      editor.incrementWeight(orig.getWeightDelta());
      editor.incrementWalkDistance(orig.getWalkDistanceDelta());
      if (orig.isBikeRenting() != orig.getBackState().isBikeRenting())       editor.setBikeRenting(!orig.isBikeRenting());
      ret=editor.makeState();
      EdgeNarrative origNarrative=orig.getBackEdgeNarrative();
      EdgeNarrative retNarrative=ret.getBackEdgeNarrative();
      copyExistingNarrativeToNewNarrativeAsAppropriate(origNarrative,retNarrative);
    }
    orig=orig.getBackState();
  }
  stateData.opt.rctx.pathParsers=pathParsers;
  if (forward) {
    State reversed=ret.reverse();
    if (getWeight() <= reversed.getWeight())     LOG.warn("Optimization did not decrease weight: before " + this.getWeight() + " after "+ reversed.getWeight());
    if (getElapsedTime() != reversed.getElapsedTime())     LOG.warn("Optimization changed time: before " + this.getElapsedTime() + " after "+ reversed.getElapsedTime());
    if (getActiveTime() <= reversed.getActiveTime())     LOG.warn("Optimization did not decrease active time: before " + this.getActiveTime() + " after "+ reversed.getActiveTime()+ ", boardings: "+ this.getNumBoardings());
    if (reversed.getWeight() < this.getBackState().getWeight())     LOG.warn("Weight has been reduced enough to make it run backwards, now:" + reversed.getWeight() + " backState "+ getBackState().getWeight()+ ", "+ "number of boardings: "+ getNumBoardings());
    if (getTime() != reversed.getTime())     LOG.warn("Times do not match");
    if (Math.abs(getWeight() - reversed.getWeight()) > 1 && newInitialWaitTime == stateData.initialWaitTime)     LOG.warn("Weight is changed (before: " + getWeight() + ", after: "+ reversed.getWeight()+ "), initial wait times "+ "constant at "+ newInitialWaitTime);
    if (newInitialWaitTime != reversed.stateData.initialWaitTime)     LOG.warn("Initial wait time not propagated: is " + reversed.stateData.initialWaitTime + ", should be "+ newInitialWaitTime);
    reversed.initializeFieldsFrom(this);
    return reversed;
  }
 else   return ret;
}
