{
  State orig=this;
  State unoptimized=orig;
  State ret=orig.reversedClone();
  long newInitialWaitTime=-1;
  boolean needToFigureInAdditionalWaitTime=false;
  PathParser pathParsers[];
  pathParsers=stateData.opt.rctx.pathParsers;
  stateData.opt.rctx.pathParsers=new PathParser[0];
  Edge edge=null;
  try {
    while (orig.getBackState() != null) {
      edge=orig.getBackEdge();
      if (optimize) {
        ret=edge.traverse(ret);
        if (ret == null)         LOG.debug("Error traversing edge " + edge + " in reverse optimization");
      }
 else {
        EdgeNarrative narrative=orig.getBackEdgeNarrative();
        StateEditor editor=ret.edit(edge,narrative);
        editor.setFromState(orig);
        if (needToFigureInAdditionalWaitTime) {
          editor.incrementTimeInSeconds((int)newInitialWaitTime);
          editor.setInitialWaitTime(newInitialWaitTime);
          editor.incrementWeight(newInitialWaitTime * stateData.opt.waitAtBeginningFactor);
          needToFigureInAdditionalWaitTime=false;
        }
        editor.incrementTimeInSeconds(orig.getAbsTimeDeltaSec());
        editor.incrementWeight(orig.getWeightDelta());
        editor.incrementWalkDistance(orig.getWalkDistanceDelta());
        if (orig.isBikeRenting() != orig.getBackState().isBikeRenting())         editor.setBikeRenting(!orig.isBikeRenting());
        ret=editor.makeState();
        EdgeNarrative origNarrative=orig.getBackEdgeNarrative();
        EdgeNarrative retNarrative=ret.getBackEdgeNarrative();
        copyExistingNarrativeToNewNarrativeAsAppropriate(origNarrative,retNarrative);
      }
      orig=orig.getBackState();
      if (forward && orig.getNumBoardings() == 0 && optimize) {
        optimize=false;
        if (isEverBoarded()) {
          newInitialWaitTime=Math.abs(ret.getTime() - orig.getTime());
          needToFigureInAdditionalWaitTime=true;
        }
      }
    }
  }
 catch (  NullPointerException e) {
    LOG.warn("Cannot reverse path at edge: " + edge + ", returning unoptimized path. If edge is a PatternInterlineDwell,"+ " this is not totally unexpected; otherwise, you might want to"+ " look into it");
    stateData.opt.rctx.pathParsers=pathParsers;
    if (forward)     return this;
 else     return unoptimized.reverse();
  }
  stateData.opt.rctx.pathParsers=pathParsers;
  if (forward) {
    return ret.reverse();
  }
 else   return ret;
}
