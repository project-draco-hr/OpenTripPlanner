{
  Vertex sv=s.getVertex();
  double euclidianDistance=distanceLibrary.fastDistance(sv.getY(),sv.getX(),targetY,targetX);
  if (useTransit) {
    double streetSpeed=options.getStreetSpeedUpperBound();
    if (s.isAlightedLocal()) {
      if (euclidianDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
        return -1;
      }
      return options.walkReluctance * euclidianDistance / streetSpeed;
    }
 else {
      int boardCost;
      if (s.isOnboard()) {
        boardCost=0;
      }
 else {
        boardCost=options.getBoardCostLowerBound();
      }
      if (s.isEverBoarded()) {
        boardCost+=options.transferPenalty;
        if (localStreetService != null) {
          if (options.getMaxWalkDistance() - s.getWalkDistance() < euclidianDistance && sv instanceof IntersectionVertex && !localStreetService.transferrable(sv)) {
            return Double.POSITIVE_INFINITY;
          }
        }
      }
      if (euclidianDistance < target.getDistanceToNearestTransitStop()) {
        if (euclidianDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
          return -1;
        }
        return options.walkReluctance * euclidianDistance / streetSpeed;
      }
 else {
        double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + sv.getDistanceToNearestTransitStop();
        if (mandatoryWalkDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
          return -1;
        }
        double distance=(euclidianDistance - mandatoryWalkDistance) / maxSpeed + mandatoryWalkDistance * options.walkReluctance / streetSpeed + boardCost;
        return Math.min(distance,options.walkReluctance * euclidianDistance / streetSpeed);
      }
    }
  }
 else {
    return options.walkReluctance * euclidianDistance / maxSpeed;
  }
}
