{
  Vertex sv=s.getVertex();
  double euclideanDistance=distanceLibrary.fastDistance(sv.getY(),sv.getX(),targetY,targetX);
  if (useTransit) {
    double streetSpeed=options.getStreetSpeedUpperBound();
    if (s.isAlightedLocal() || euclideanDistance < target.getDistanceToNearestTransitStop()) {
      if (euclideanDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
        return -1;
      }
      return options.walkReluctance * euclideanDistance / streetSpeed;
    }
    int boardCost;
    if (s.isOnboard()) {
      boardCost=0;
    }
 else {
      boardCost=options.getBoardCostLowerBound();
      if (s.isEverBoarded()) {
        boardCost+=options.transferPenalty;
        if (localStreetService != null) {
          if (options.getMaxWalkDistance() - s.getWalkDistance() < euclideanDistance && sv instanceof IntersectionVertex && !localStreetService.transferrable(sv)) {
            return Double.POSITIVE_INFINITY;
          }
        }
      }
    }
    double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + sv.getDistanceToNearestTransitStop();
    if (mandatoryWalkDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
      return -1;
    }
    double transitCost=(euclideanDistance - mandatoryWalkDistance) / maxSpeed + boardCost;
    double transitStreetCost=mandatoryWalkDistance * options.walkReluctance / streetSpeed;
    return Math.min(transitCost + transitStreetCost,options.walkReluctance * euclideanDistance / streetSpeed);
  }
 else {
    return options.walkReluctance * euclideanDistance / maxSpeed;
  }
}
