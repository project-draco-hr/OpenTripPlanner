{
  Vertex sv=s.getVertex();
  double euclidianDistance=distanceLibrary.fastDistance(sv.getCoordinate(),target.getCoordinate());
  if (useTransit) {
    double speed=options.getSpeedUpperBound();
    if (s.isAlightedLocal()) {
      if (euclidianDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
        return -1;
      }
      return options.walkReluctance * euclidianDistance / speed;
    }
 else {
      int boardCost;
      if (s.isOnboard()) {
        boardCost=0;
      }
 else {
        boardCost=options.getBoardCostLowerBound();
      }
      if (s.isEverBoarded()) {
        boardCost+=options.transferPenalty;
        if (localStreetService != null) {
          if (s.getOptions().getMaxWalkDistance() - s.getWalkDistance() < distanceLibrary.fastDistance(sv.getCoordinate(),target.getCoordinate()) && !localStreetService.transferrable(sv)) {
            return Double.POSITIVE_INFINITY;
          }
        }
      }
      if (euclidianDistance < target.getDistanceToNearestTransitStop()) {
        if (euclidianDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
          return -1;
        }
        return options.walkReluctance * euclidianDistance / speed;
      }
 else {
        double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + sv.getDistanceToNearestTransitStop();
        if (mandatoryWalkDistance + s.getWalkDistance() > options.getMaxWalkDistance()) {
          return -1;
        }
        double distance=(euclidianDistance - mandatoryWalkDistance) / maxSpeed + mandatoryWalkDistance * options.walkReluctance / speed + boardCost;
        return Math.min(distance,options.walkReluctance * euclidianDistance / speed);
      }
    }
  }
 else {
    return options.walkReluctance * euclidianDistance / maxSpeed;
  }
}
