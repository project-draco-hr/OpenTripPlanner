{
  Coordinate coordinate=location.getCoordinate();
  Envelope envelope=new Envelope(coordinate);
  double envelopeGrowthAmount=0.001;
  double radius=0;
  double xscale=Math.cos(coordinate.y * Math.PI / 180);
  CandidateEdgeBundle candidateEdges=new CandidateEdgeBundle();
  while (candidateEdges.size() == 0) {
    envelope.expandBy(envelopeGrowthAmount / xscale,envelopeGrowthAmount);
    radius+=envelopeGrowthAmount;
    if (radius > MAX_DISTANCE_FROM_STREET_DEGREES) {
      return candidateEdges;
    }
    Iterable<Edge> nearbyEdges=getEdgesForEnvelope(envelope);
    for (    Edge e : nearbyEdges) {
      if (e == null || e.getFromVertex() == null || !(e instanceof StreetEdge)) {
        continue;
      }
      StreetEdge se=(StreetEdge)e;
      if (!reqs.canBeTraversed(se)) {
        continue;
      }
      double preference=1;
      if (preferredEdges != null && preferredEdges.contains(e)) {
        preference=3.0;
      }
      TraverseModeSet modes=reqs.modes;
      CandidateEdge ce=new CandidateEdge(se,location,preference,modes);
      if (ce.distance < radius) {
        candidateEdges.add(ce);
      }
    }
  }
  Collection<CandidateEdgeBundle> bundles=candidateEdges.binByDistanceAndAngle();
  CandidateEdgeBundle best=null;
  for (  CandidateEdgeBundle bundle : bundles) {
    if (best == null || bundle.best.score < best.best.score) {
      if (possibleTransitLinksOnly) {
        if (!(bundle.allowsCars() || bundle.isPlatform()))         continue;
      }
      best=bundle;
    }
  }
  return best;
}
