{
  LOG.debug("Looking for/making a vertex near {}",location);
  Coordinate coord=location.getCoordinate();
  StreetVertex intersection=getIntersectionAt(coord);
  String calculatedName=location.name;
  if (intersection != null) {
    boolean canEscape=false;
    if (options == null) {
      canEscape=true;
    }
 else {
      TraversalRequirements reqs=new TraversalRequirements(options);
      for (      StreetEdge e : Iterables.filter(options.arriveBy ? intersection.getIncoming() : intersection.getOutgoing(),StreetEdge.class)) {
        if (reqs.canBeTraversed(e)) {
          canEscape=true;
          break;
        }
      }
    }
    if (canEscape) {
      if (!location.hasName()) {
        LOG.debug("found intersection {}. not splitting.",intersection);
        Set<String> uniqueNameSet=new HashSet<String>();
        for (        Edge e : intersection.getOutgoing()) {
          if (e instanceof StreetEdge) {
            uniqueNameSet.add(e.getName());
          }
        }
        List<String> uniqueNames=new ArrayList<String>(uniqueNameSet);
        Locale locale;
        if (options == null) {
          locale=new Locale("en");
        }
 else {
          locale=options.locale;
        }
        ResourceBundle resources=ResourceBundle.getBundle("internals",locale);
        String fmt=resources.getString("corner");
        if (uniqueNames.size() > 1) {
          calculatedName=String.format(fmt,uniqueNames.get(0),uniqueNames.get(1));
        }
 else         if (uniqueNames.size() == 1) {
          calculatedName=uniqueNames.get(0);
        }
 else {
          calculatedName=resources.getString("unnamedStreet");
        }
      }
      TemporaryStreetLocation closest=new TemporaryStreetLocation("corner " + Math.random(),coord,calculatedName,endVertex);
      if (endVertex) {
        new TemporaryFreeEdge(intersection,closest);
      }
 else {
        new TemporaryFreeEdge(closest,intersection);
      }
      return closest;
    }
  }
  double closestStopDistance=Double.POSITIVE_INFINITY;
  Vertex closestStop=null;
  if (options != null && options.modes.isTransit()) {
    for (    TransitStop v : getNearbyTransitStops(coord,1000)) {
      if (!v.isStreetLinkable())       continue;
      double d=SphericalDistanceLibrary.distance(v.getCoordinate(),coord);
      if (d < closestStopDistance) {
        closestStopDistance=d;
        closestStop=v;
      }
    }
  }
  LOG.debug(" best stop: {} distance: {}",closestStop,closestStopDistance);
  TemporaryStreetLocation closestStreet=null;
  CandidateEdgeBundle bundle=getClosestEdges(location,options,extraEdges,null,false);
  CandidateEdge candidate=bundle.best;
  double closestStreetDistance=Double.POSITIVE_INFINITY;
  if (candidate != null) {
    StreetEdge bestStreet=candidate.edge;
    Coordinate nearestPoint=candidate.nearestPointOnEdge;
    closestStreetDistance=SphericalDistanceLibrary.distance(coord,nearestPoint);
    LOG.debug("best street: {} dist: {}",bestStreet.toString(),closestStreetDistance);
    if (calculatedName == null || "".equals(calculatedName)) {
      calculatedName=bestStreet.getName();
    }
    String closestName=String.format("%s_%s",bestStreet.getName(),location.toString());
    closestStreet=createTemporaryStreetLocation(graph,closestName,calculatedName,bundle.toEdgeList(),nearestPoint,endVertex);
  }
  if (closestStreet == null) {
    LOG.debug("returning only transit stop (no street found)");
    return closestStop;
  }
 else {
    if (closestStop != null) {
      double relativeStopDistance=closestStopDistance / closestStreetDistance;
      if (relativeStopDistance < 1.5) {
        LOG.debug("linking transit stop to street (distances are comparable)");
        if (endVertex) {
          new TemporaryFreeEdge(closestStop,closestStreet);
        }
 else {
          new TemporaryFreeEdge(closestStreet,closestStop);
        }
      }
    }
    LOG.debug("returning split street");
    return closestStreet;
  }
}
