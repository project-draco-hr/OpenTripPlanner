{
  final double metersPerDegreeLat=111111.111;
  double cosLat=FastMath.cos(FastMath.toRadians(lat));
  double radiusDegreesLat=radiusMeters / metersPerDegreeLat;
  double radiusDegreesLon=radiusDegreesLat * cosLat;
  Envelope envelope=new Envelope(lon,lon,lat,lat);
  envelope.expandBy(radiusDegreesLon,radiusDegreesLat);
  double squaredRadiusDegreesLat=radiusDegreesLat * radiusDegreesLat;
  TIntSet candidateVertices=spatialIndex.query(envelope);
  int closestVertex=-1;
  double closestDistance=Double.POSITIVE_INFINITY;
  TIntIterator vertexIterator=candidateVertices.iterator();
  while (vertexIterator.hasNext()) {
    int v=vertexIterator.next();
    StreetIntersection intersection=vertices.get(v);
    double dx=intersection.getLon() - lon;
    double dy=intersection.getLat() - lat;
    dx*=cosLat;
    double squaredDistanceDegreesLat=dx * dx + dy * dy;
    if (squaredDistanceDegreesLat <= squaredRadiusDegreesLat) {
      if (squaredDistanceDegreesLat < closestDistance) {
        closestVertex=v;
        closestDistance=squaredDistanceDegreesLat;
      }
    }
  }
  if (closestVertex >= 0) {
    closestDistance=FastMath.sqrt(closestDistance) * metersPerDegreeLat;
    int edgeId=nEdges++;
    StreetSegment segment=edges.get(edgeId);
    segment.setFlag(StreetSegment.Flag.TRANSIT_LINK);
    segment.setFromVertex(closestVertex);
    segment.setToVertex(stopIndex);
    outgoingEdges.get(closestVertex).add(edgeId);
    incomingEdges.get(closestVertex).add(edgeId);
  }
}
