{
  final double metersPerDegreeLat=111111.111;
  double cosLat=FastMath.cos(FastMath.toRadians(lat));
  double radiusDegreesLat=radiusMeters / metersPerDegreeLat;
  double radiusDegreesLon=radiusDegreesLat * cosLat;
  Envelope envelope=new Envelope(lon,lon,lat,lat);
  envelope.expandBy(radiusDegreesLon,radiusDegreesLat);
  double squaredRadiusDegreesLat=radiusDegreesLat * radiusDegreesLat;
  TIntSet candidateVertices=spatialIndex.query(envelope);
  int closestVertex=-1;
  double closestDistance=Double.POSITIVE_INFINITY;
  VertexStore.Vertex vertex=vertexStore.getCursor();
  TIntIterator vertexIterator=candidateVertices.iterator();
  while (vertexIterator.hasNext()) {
    int v=vertexIterator.next();
    vertex.seek(v);
    double dx=vertex.getLon() - lon;
    double dy=vertex.getLat() - lat;
    dx*=cosLat;
    double squaredDistanceDegreesLat=dx * dx + dy * dy;
    if (squaredDistanceDegreesLat <= squaredRadiusDegreesLat) {
      if (squaredDistanceDegreesLat < closestDistance) {
        closestVertex=v;
        closestDistance=squaredDistanceDegreesLat;
      }
    }
  }
  int stopVertexIndex=vertexStore.addVertex(lat,lon);
  if (closestVertex >= 0) {
    closestDistance=FastMath.sqrt(closestDistance) * metersPerDegreeLat;
    int foreEdgeId=edgeStore.addStreetPair(closestVertex,stopVertexIndex,closestDistance);
    int backEdgeId=foreEdgeId + 1;
    edgeStore.getCursor(foreEdgeId).setFlag(EdgeStore.Flag.TRANSIT_LINK);
    edgeStore.getCursor(backEdgeId).setFlag(EdgeStore.Flag.TRANSIT_LINK);
  }
  return stopVertexIndex;
}
