{
  ShortestPathTree spt=createShortestPathTree();
  OTPPriorityQueue<SPTVertex> queue=createPriorityQueue();
  SPTVertex spt_origin=spt.addVertex(origin,initialState,0,options);
  queue.insert(spt_origin,spt_origin.weightSum);
  Map<Vertex,List<Edge>> extraEdges=null;
  if (_extraEdgesStrategy != null) {
    extraEdges=new HashMap<Vertex,List<Edge>>();
    _extraEdgesStrategy.addOutgoingEdgesForOrigin(extraEdges,origin);
  }
  while (!queue.empty()) {
    if (_verbose) {
      double v=queue.peek_min_key();
      System.out.println("min," + v);
    }
    SPTVertex spt_u=queue.extract_min();
    Vertex fromv=spt_u.mirror;
    State state=spt_u.state;
    if (_verbose)     System.out.println(fromv);
    if (_searchTerminationStrategy != null && !_searchTerminationStrategy.shouldSearchContinue(origin,null,spt_u,spt,options))     break;
    Collection<Edge> outgoing=GraphLibrary.getOutgoingEdges(graph,fromv,extraEdges);
    for (    Edge edge : outgoing) {
      if (_skipEdgeStrategy != null && _skipEdgeStrategy.shouldSkipEdge(spt_origin,null,spt_u,edge,spt,options))       continue;
      for (TraverseResult wr=edge.traverse(state,options); wr != null; wr=wr.getNextResult()) {
        if (wr.weight < 0) {
          throw new NegativeWeightException(String.valueOf(wr.weight) + " on edge " + edge);
        }
        if (_skipTraverseResultStrategy != null && _skipTraverseResultStrategy.shouldSkipTraversalResult(spt_origin,null,spt_u,wr,spt,options))         continue;
        EdgeNarrative er=wr.getEdgeNarrative();
        Vertex toVertex=er.getToVertex();
        double new_w=spt_u.weightSum + wr.weight;
        if (_verbose)         System.out.println("  w=" + spt_u.weightSum + "+"+ wr.weight+ "="+ new_w+ " "+ toVertex);
        if (new_w > options.maxWeight)         continue;
        SPTVertex spt_v=spt.addVertex(toVertex,wr.state,new_w,options);
        if (spt_v != null) {
          spt_v.setParent(spt_u,edge,er);
          queue.insert_or_dec_key(spt_v,new_w);
        }
      }
    }
  }
  return spt;
}
