{
  long startTime=TestUtils.dateInSeconds(2009,10,11,12,0,0);
  GraphPath path;
  Graph graph=new Graph();
  ContractionHierarchy hierarchy;
  URL resource=getClass().getResource("nyc_streets/streets.shp");
  File file=null;
  if (resource != null) {
    file=new File(resource.getFile());
  }
  if (file == null || !file.exists()) {
    System.out.println("No New York City basemap; skipping; see comment in TestShapefileStreetGraphBuilderImpl for details");
    return;
  }
  ShapefileFeatureSourceFactoryImpl factory=new ShapefileFeatureSourceFactoryImpl(file);
  ShapefileStreetSchema schema=new ShapefileStreetSchema();
  schema.setIdAttribute("SegmentID");
  schema.setNameAttribute("Street");
  CaseBasedBooleanConverter selector1=new CaseBasedBooleanConverter("FeatureTyp",false);
  HashMap<String,Boolean> streets=new HashMap<String,Boolean>();
  streets.put("0",true);
  selector1.setValues(streets);
  NullBooleanConverter selector2=new NullBooleanConverter("SAFStPlace",true);
  schema.setFeatureSelector(new CompositeBooleanConverter(selector1,selector2));
  CaseBasedTraversalPermissionConverter perms=new CaseBasedTraversalPermissionConverter("TrafDir",StreetTraversalPermission.PEDESTRIAN_AND_BICYCLE);
  perms.addPermission("W",StreetTraversalPermission.ALL,StreetTraversalPermission.PEDESTRIAN);
  perms.addPermission("A",StreetTraversalPermission.PEDESTRIAN,StreetTraversalPermission.ALL);
  perms.addPermission("T",StreetTraversalPermission.ALL,StreetTraversalPermission.ALL);
  schema.setPermissionConverter(perms);
  ShapefileStreetGraphBuilderImpl loader=new ShapefileStreetGraphBuilderImpl();
  loader.setFeatureSourceFactory(factory);
  loader.setSchema(schema);
  loader.buildGraph(graph);
  resource=getClass().getResource("subway.zip");
  file=null;
  if (resource != null) {
    file=new File(resource.getFile());
  }
  if (file == null || !file.exists()) {
    System.out.println("No New York City subway GTFS; skipping; see comment in TestShapefileStreetGraphBuilderImpl for details");
    return;
  }
  GtfsGraphBuilderImpl gtfsBuilder=new GtfsGraphBuilderImpl();
  GtfsBundle bundle=new GtfsBundle();
  bundle.setPath(file);
  ArrayList<GtfsBundle> bundleList=new ArrayList<GtfsBundle>();
  bundleList.add(bundle);
  GtfsBundles bundles=new GtfsBundles();
  bundles.setBundles(bundleList);
  gtfsBuilder.setGtfsBundles(bundles);
  gtfsBuilder.buildGraph(graph);
  NetworkLinker nl=new NetworkLinker(graph);
  nl.createLinkage();
  TraverseOptions options=new TraverseOptions();
  options.setModes(new TraverseModeSet(TraverseMode.WALK,TraverseMode.SUBWAY));
  options.optimizeFor=OptimizeType.QUICK;
  CalendarServiceData data=graph.getService(CalendarServiceData.class);
  assertNotNull(data);
  CalendarServiceImpl calendarService=new CalendarServiceImpl();
  calendarService.setData(data);
  options.setCalendarService(calendarService);
  options.setServiceDays(startTime);
  options.setTransferTable(graph.getTransferTable());
  Vertex start1=graph.getVertex("0072480");
  Vertex end1=graph.getVertex("0032341");
  assertNotNull(end1);
  assertNotNull(start1);
  ShortestPathTree shortestPathTree=AStar.getShortestPathTree(graph,start1,end1,startTime,options);
  path=shortestPathTree.getPath(end1,true);
  assertNotNull(path);
  boolean subway1=false;
  for (  State state : path.states) {
    if (state.getBackEdge() == null)     continue;
    System.out.println(state.getBackEdgeNarrative().getMode());
    if (TraverseMode.SUBWAY.equals(state.getBackEdgeNarrative().getMode())) {
      subway1=true;
      break;
    }
  }
  assertTrue("Path must take subway",subway1);
  ContractionHierarchySet chs=new ContractionHierarchySet();
  chs.addModeAndOptimize(new ModeAndOptimize(TraverseMode.WALK,OptimizeType.QUICK));
  chs.setContractionFactor(0.50);
  chs.setGraph(graph);
  chs.build();
  ContractionHierarchySerializationLibrary.writeGraph(chs,new File("/tmp/contracted"));
  chs=ContractionHierarchySerializationLibrary.readGraph(new File("/tmp/contracted"));
  hierarchy=chs.getHierarchy(options);
  assertNotNull(hierarchy);
  Vertex start=null;
  Vertex end=null;
  start=hierarchy.up.getVertex("0072480");
  end=hierarchy.up.getVertex("0032341");
  if (start == null)   start=hierarchy.down.getVertex("0072480");
  if (start == null)   start=hierarchy.graph.getVertex("0072480");
  if (end == null)   end=hierarchy.down.getVertex("0032341");
  if (end == null)   end=hierarchy.graph.getVertex("0032341");
  assertNotNull(start);
  assertNotNull(end);
  path=hierarchy.getShortestPath(start,end,0,options);
  assertNotNull(path);
  GraphPath pathWithSubways=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull(pathWithSubways);
  boolean subway=false;
  for (  State state : pathWithSubways.states) {
    if (state.getBackEdge() == null)     continue;
    if (TraverseMode.SUBWAY.equals(state.getBackEdgeNarrative().getMode())) {
      subway=true;
      break;
    }
  }
  assertTrue("Path must take subway",subway);
  options.setArriveBy(true);
  pathWithSubways=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull("Reverse path must be found",pathWithSubways);
  subway=false;
  for (  State state : pathWithSubways.states) {
    if (state.getBackEdge() == null)     continue;
    if (TraverseMode.SUBWAY.equals(state.getBackEdgeNarrative().getMode())) {
      subway=true;
      break;
    }
  }
  assertTrue("Reverse path must take subway",subway);
  options.setArriveBy(false);
  options.worstTime=startTime + 60 * 90;
  path=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull(path);
  options.worstTime=startTime + 60;
  path=hierarchy.getShortestPath(start,end,startTime,options);
  assertNull(path);
  long now=System.currentTimeMillis();
  int i=0;
  int notNull=0;
  Collection<GraphVertex> upVertices=hierarchy.up.getVertices();
  ArrayList<GraphVertex> vertices=new ArrayList<GraphVertex>(upVertices);
  vertices.addAll(hierarchy.down.getVertices());
  vertices.addAll(hierarchy.graph.getVertices());
  DisjointSet<Vertex> components=new DisjointSet<Vertex>();
  for (  GraphVertex gv : vertices) {
    for (    DirectEdge e : filter(gv.getOutgoing(),DirectEdge.class)) {
      components.union(gv.vertex,e.getToVertex());
    }
  }
  ArrayList<GraphVertex> verticesOut=new ArrayList<GraphVertex>();
  for (  GraphVertex gv : vertices) {
    Vertex v=gv.vertex;
    int componentSize=components.size(components.find(v));
    if (componentSize > upVertices.size() / 2) {
      if (gv.getDegreeOut() != 0) {
        verticesOut.add(gv);
      }
    }
  }
  assertTrue(verticesOut.size() > 0);
  assertTrue(vertices.size() > verticesOut.size());
  vertices=verticesOut;
  Random random=new Random(0);
  for (  GraphVertex gv1 : vertices) {
    Vertex v1=gv1.vertex;
    if (++i == 100) {
      break;
    }
    if (hierarchy.up.getVertex(v1.getLabel()) == null) {
      --i;
      continue;
    }
    GraphVertex gv2=null;
    Vertex v2=null;
    while (v2 == null || gv2.getDegreeIn() == 0) {
      int j=Math.abs(random.nextInt()) % vertices.size();
      gv2=vertices.get(j);
      v2=gv2.vertex;
      if (v1.getLabel() == v2.getLabel()) {
        continue;
      }
      if (hierarchy.down.getVertex(v2.getLabel()) == null) {
        v2=null;
        continue;
      }
    }
    options.setArriveBy(i % 2 == 0);
    assertNotNull(v1);
    assertNotNull(v2);
    GraphPath path2=hierarchy.getShortestPath(v1,v2,startTime,options);
    if (path2 != null) {
      notNull+=1;
    }
  }
  System.out.println("not null: " + notNull + " of "+ i);
  System.out.println("time for 100 shortest paths (on a not-particularly-contracted graph): " + (System.currentTimeMillis() - now) / 1000.0);
  assertTrue(notNull / (float)i > 0.95);
}
