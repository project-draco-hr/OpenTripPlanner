{
  long startTime=TestUtils.dateInSeconds("America/New_York",2009,10,11,12,0,0);
  GraphPath path;
  Graph graph=new Graph();
  ContractionHierarchy hierarchy;
  URL resource=getClass().getResource("nyc_streets/streets.shp");
  File file=null;
  if (resource != null) {
    file=new File(resource.getFile());
  }
  if (file == null || !file.exists()) {
    System.out.println("No New York City basemap; skipping; see comment in TestShapefileStreetGraphBuilderImpl for details");
    return;
  }
  ShapefileFeatureSourceFactoryImpl factory=new ShapefileFeatureSourceFactoryImpl(file);
  ShapefileStreetSchema schema=new ShapefileStreetSchema();
  schema.setIdAttribute("SegmentID");
  schema.setNameAttribute("Street");
  CaseBasedBooleanConverter selector1=new CaseBasedBooleanConverter("FeatureTyp",false);
  HashMap<String,Boolean> streets=new HashMap<String,Boolean>();
  streets.put("0",true);
  selector1.setValues(streets);
  NullBooleanConverter selector2=new NullBooleanConverter("SAFStPlace",true);
  schema.setFeatureSelector(new CompositeBooleanConverter(selector1,selector2));
  CaseBasedTraversalPermissionConverter perms=new CaseBasedTraversalPermissionConverter("TrafDir",StreetTraversalPermission.PEDESTRIAN_AND_BICYCLE);
  perms.addPermission("W",StreetTraversalPermission.ALL,StreetTraversalPermission.PEDESTRIAN);
  perms.addPermission("A",StreetTraversalPermission.PEDESTRIAN,StreetTraversalPermission.ALL);
  perms.addPermission("T",StreetTraversalPermission.ALL,StreetTraversalPermission.ALL);
  schema.setPermissionConverter(perms);
  ShapefileStreetGraphBuilderImpl loader=new ShapefileStreetGraphBuilderImpl();
  loader.setFeatureSourceFactory(factory);
  loader.setSchema(schema);
  loader.buildGraph(graph,new HashMap<Class<?>,Object>());
  resource=getClass().getResource("subway.zip");
  file=null;
  if (resource != null) {
    file=new File(resource.getFile());
  }
  if (file == null || !file.exists()) {
    System.out.println("No New York City subway GTFS; skipping; see comment in TestShapefileStreetGraphBuilderImpl for details");
    return;
  }
  GtfsGraphBuilderImpl gtfsBuilder=new GtfsGraphBuilderImpl();
  GtfsBundle bundle=new GtfsBundle();
  bundle.setPath(file);
  ArrayList<GtfsBundle> bundleList=new ArrayList<GtfsBundle>();
  bundleList.add(bundle);
  GtfsBundles bundles=new GtfsBundles();
  bundles.setBundles(bundleList);
  gtfsBuilder.setGtfsBundles(bundles);
  gtfsBuilder.buildGraph(graph,new HashMap<Class<?>,Object>());
  NetworkLinker nl=new NetworkLinker(graph);
  nl.createLinkage();
  RoutingRequest options=new RoutingRequest();
  options.setModes(new TraverseModeSet(TraverseMode.WALK,TraverseMode.SUBWAY));
  options.optimize=OptimizeType.QUICK;
  Vertex start1=graph.getVertex("0072480");
  Vertex end1=graph.getVertex("0032341");
  assertNotNull(end1);
  assertNotNull(start1);
  options.dateTime=startTime;
  options.setRoutingContext(graph,start1,end1);
  ShortestPathTree shortestPathTree=new GenericAStar().getShortestPathTree(options);
  path=shortestPathTree.getPath(end1,true);
  assertNotNull(path);
  boolean subway1=false;
  for (  State state : path.states) {
    if (state.getBackEdge() == null)     continue;
    System.out.println(state.getBackMode());
    if (TraverseMode.SUBWAY.equals(state.getBackMode())) {
      subway1=true;
      break;
    }
  }
  assertTrue("Path must take subway",subway1);
  ContractionHierarchySet chs=new ContractionHierarchySet();
  chs.addTraverseOptions(new RoutingRequest(TraverseMode.WALK,OptimizeType.QUICK));
  chs.setContractionFactor(0.50);
  chs.setGraph(graph);
  chs.build();
  graph.setHierarchies(chs);
  graph.save(new File("/tmp/contracted"));
  graph=Graph.load(new File("/tmp/contracted"),Graph.LoadLevel.FULL);
  chs=graph.getHierarchies();
  hierarchy=chs.getHierarchy(options);
  assertNotNull(hierarchy);
  Vertex start=null;
  Vertex end=null;
  start=graph.getVertex("0072480");
  end=graph.getVertex("0032341");
  path=hierarchy.getShortestPath(start,end,0,options);
  assertNotNull(path);
  GraphPath pathWithSubways=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull(pathWithSubways);
  boolean subway=false;
  for (  State state : pathWithSubways.states) {
    if (state.getBackEdge() == null)     continue;
    if (TraverseMode.SUBWAY.equals(state.getBackMode())) {
      subway=true;
      break;
    }
  }
  assertTrue("Path must take subway",subway);
  options.setArriveBy(true);
  pathWithSubways=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull("Reverse path must be found",pathWithSubways);
  subway=false;
  for (  State state : pathWithSubways.states) {
    if (state.getBackEdge() == null)     continue;
    if (TraverseMode.SUBWAY.equals(state.getBackMode())) {
      subway=true;
      break;
    }
  }
  assertTrue("Reverse path must take subway",subway);
  options.setArriveBy(false);
  options.worstTime=startTime + 60 * 90;
  path=hierarchy.getShortestPath(start,end,startTime,options);
  assertNotNull(path);
  options.worstTime=startTime + 60;
  path=hierarchy.getShortestPath(start,end,startTime,options);
  assertNull(path);
  long now=System.currentTimeMillis();
  int i=0;
  int notNull=0;
  Collection<Vertex> chv=hierarchy.chv;
  Collection<Vertex> vertices=graph.getVertices();
  DisjointSet<Vertex> components=new DisjointSet<Vertex>();
  for (  Vertex v : vertices) {
    for (    Edge e : v.getOutgoing()) {
      components.union(v,e.getToVertex());
    }
  }
  ArrayList<Vertex> verticesOut=new ArrayList<Vertex>();
  for (  Vertex v : vertices) {
    int componentSize=components.size(components.find(v));
    if (componentSize > chv.size() / 2) {
      if (v.getDegreeOut() != 0) {
        verticesOut.add(v);
      }
    }
  }
  assertTrue(verticesOut.size() > 0);
  assertTrue(vertices.size() > verticesOut.size());
  vertices=verticesOut;
  Random random=new Random(0);
  for (  Vertex orig : vertices) {
    if (++i == 100) {
      break;
    }
    if (!chv.contains(orig) || orig.getDegreeOut() < 1) {
      --i;
      continue;
    }
    Vertex dest=null;
    while (dest == null) {
      int j=(int)(Math.abs((long)random.nextInt()) % verticesOut.size());
      dest=verticesOut.get(j);
      if (orig.equals(dest)) {
        continue;
      }
      if (!chv.contains(dest) || dest.getDegreeIn() < 1) {
        dest=null;
        continue;
      }
    }
    options.setArriveBy(i % 2 == 0);
    assertNotNull(orig);
    assertNotNull(dest);
    GraphPath path2=hierarchy.getShortestPath(orig,dest,startTime,options);
    if (path2 != null) {
      notNull+=1;
    }
  }
  System.out.println("not null: " + notNull + " of "+ i);
  System.out.println("time for 100 shortest paths (on a not-particularly-contracted graph): " + (System.currentTimeMillis() - now) / 1000.0);
  assertTrue(notNull / (float)i > 0.95);
}
