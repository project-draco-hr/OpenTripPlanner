{
  final double LAT0=01.0;
  final double LON0=65.0;
  final double STEP=0.001;
  final int N=10;
  Graph graph=new Graph();
  Vertex[][] verticesIn=new Vertex[N][];
  Vertex[][] verticesOut=new Vertex[N][];
  for (int y=0; y < N; ++y) {
    verticesIn[y]=new Vertex[N];
    verticesOut[y]=new Vertex[N];
    for (int x=0; x < N; ++x) {
      double xc=x * STEP + LON0;
      double yc=y * STEP + LAT0;
      Vertex in=new EndpointVertex("(" + x + ", "+ y+ ") in",xc,yc);
      graph.addVertex(in);
      verticesIn[y][x]=in;
      Vertex out=new EndpointVertex("(" + x + ", "+ y+ ") out",xc,yc);
      graph.addVertex(out);
      verticesOut[y][x]=out;
    }
  }
  for (int i=0; i < N; ++i) {
    for (int j=0; j < N - 1; ++j) {
      double lon=j * STEP + LON0;
      double lat=i * STEP + LAT0;
      double d=111.111;
      LineString geometry=GeometryUtils.makeLineString(lon,lat,lon + STEP,lat);
      StreetVertex we=new StreetVertex("a(" + j + ", "+ i+ ")",geometry,"",d,false,null);
      StreetVertex ew=new StreetVertex("a(" + j + ", "+ i+ ")",(LineString)geometry.reverse(),"",d,true,null);
      graph.addVertex(we);
      graph.addVertex(ew);
      lon=i * STEP + LON0;
      lat=j * STEP + LAT0;
      d=111.111;
      geometry=GeometryUtils.makeLineString(lon,lat,lon,lat + STEP);
      StreetVertex sn=new StreetVertex("d(" + i + ", "+ j+ ")",geometry,"",d,false,null);
      StreetVertex ns=new StreetVertex("d(" + i + ", "+ j+ ")",(LineString)geometry.reverse(),"",d,true,null);
      graph.addVertex(sn);
      graph.addVertex(ns);
      graph.addEdge(new FreeEdge(verticesOut[i][j],we));
      graph.addEdge(new FreeEdge(verticesOut[j][i],sn));
      graph.addEdge(new FreeEdge(verticesOut[i][j + 1],ew));
      graph.addEdge(new FreeEdge(verticesOut[j + 1][i],ns));
      graph.addEdge(new FreeEdge(ew,verticesIn[i][j]));
      graph.addEdge(new FreeEdge(ns,verticesIn[j][i]));
      graph.addEdge(new FreeEdge(we,verticesIn[i][j + 1]));
      graph.addEdge(new FreeEdge(sn,verticesIn[j + 1][i]));
      assertEquals(we,graph.addVertex(we));
      assertEquals(ew,graph.addVertex(ew));
      assertEquals(sn,graph.addVertex(sn));
      assertEquals(ns,graph.addVertex(ns));
    }
  }
  for (int y=0; y < N; ++y) {
    for (int x=0; x < N; ++x) {
      Vertex vertexIn=verticesIn[y][x];
      for (      DirectEdge e1 : filter(vertexIn.getIncoming(),DirectEdge.class)) {
        Vertex vertexOut=verticesOut[y][x];
        StreetVertex fromv=(StreetVertex)e1.getFromVertex();
        for (        DirectEdge e2 : filter(vertexOut.getOutgoing(),DirectEdge.class)) {
          StreetVertex tov=(StreetVertex)e2.getToVertex();
          if (tov.getEdgeId().equals(fromv.getEdgeId())) {
            continue;
          }
          graph.addEdge(new TurnEdge(fromv,tov));
        }
        assertTrue(fromv.getDegreeOut() <= 4);
      }
    }
  }
  final int graphSize=N * N * 2 + (N * (N - 1) * 4);
  assertEquals(graphSize,graph.getVertices().size());
  TraverseOptions options=new TraverseOptions();
  options.optimizeFor=OptimizeType.QUICK;
  options.walkReluctance=1;
  options.speed=1;
  OverlayGraph og=new OverlayGraph(graph);
  Dijkstra dijkstra=new Dijkstra(og,verticesOut[0][0],options,graph.getVertex("a(0, 0)"),3);
  BasicShortestPathTree spt=dijkstra.getShortestPathTree(verticesIn[0][2],4);
  State v03=spt.getState(verticesIn[0][3]);
  assertNull(v03);
  dijkstra=new Dijkstra(og,verticesOut[0][0],options,graph.getVertex("a(0, 0)"),6);
  spt=dijkstra.getShortestPathTree(verticesIn[0][3],500);
  v03=spt.getState(verticesIn[0][3]);
  assertNotNull(v03);
  dijkstra=new Dijkstra(og,verticesOut[0][1],options,verticesIn[0][2]);
  spt=dijkstra.getShortestPathTree(verticesIn[0][3],20);
  v03=spt.getState(verticesIn[0][3]);
  assertNull(v03);
  dijkstra=new Dijkstra(og,verticesOut[0][1],options,verticesIn[0][2]);
  spt=dijkstra.getShortestPathTree(verticesIn[0][3],130);
  v03=spt.getState(verticesIn[0][3]);
  assertNotNull(v03);
  ContractionHierarchy testch=new ContractionHierarchy(graph,new TraverseOptions(TraverseMode.WALK,OptimizeType.QUICK),0.0);
  Vertex v=graph.getVertex("a(2, 2)");
  List<Shortcut> shortcuts=testch.getShortcuts(v,true).shortcuts;
  assertEquals(16,shortcuts.size());
  v=graph.getVertex("(0, 0) in");
  shortcuts=testch.getShortcuts(v,true).shortcuts;
  assertEquals(0,shortcuts.size());
  ContractionHierarchy hierarchy=new ContractionHierarchy(graph,new TraverseOptions(TraverseMode.WALK,OptimizeType.QUICK),1.0);
  int n=hierarchy.updown.getVertices().size();
  assertTrue(hierarchy.core.getVertices().size() == 0);
  System.out.println("Contracted");
  GraphPath path=hierarchy.getShortestPath(verticesOut[0][0],verticesIn[N - 1][N - 1],1000000000,options);
  assertNotNull(path);
  assertEquals((N - 1) * 2 + 2,path.states.size());
  for (int i=0; i < path.states.size() - 1; ++i) {
    State s=path.states.get(i);
    Vertex sv=s.getVertex();
    Edge e=path.edges.get(i);
    assertSame(e.getFromVertex(),sv);
  }
  options=new TraverseOptions();
  options.optimizeFor=OptimizeType.QUICK;
  options.speed=1;
  options.remainingWeightHeuristic=new TrivialRemainingWeightHeuristic();
  for (int x1=0; x1 < N; ++x1) {
    for (int y1=0; y1 < N; ++y1) {
      for (int x2=0; x2 < N; ++x2) {
        for (int y2=0; y2 < N; ++y2) {
          if (x1 == x2 && y1 == y2) {
            continue;
          }
          options.setArriveBy(false);
          path=hierarchy.getShortestPath(verticesOut[y1][x1],verticesIn[y2][x2],1000000000,options);
          assertNotNull(path);
          options.setArriveBy(true);
          path=hierarchy.getShortestPath(verticesOut[y1][x1],verticesIn[y2][x2],1000000000,options);
          assertNotNull(path);
        }
      }
    }
  }
}
