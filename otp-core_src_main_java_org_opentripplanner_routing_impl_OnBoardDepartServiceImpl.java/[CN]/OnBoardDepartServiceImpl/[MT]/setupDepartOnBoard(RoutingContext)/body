{
  DistanceLibrary distanceLibrary=SphericalDistanceLibrary.getInstance();
  RoutingRequest opt=ctx.opt;
  AgencyAndId tripId=opt.getStartingTransitTripId();
  TransitIndexService transitIndexService=ctx.graph.getService(TransitIndexService.class);
  TableTripPattern tripPattern=transitIndexService.getTripPatternForTrip(tripId);
  if (tripPattern == null) {
    throw new IllegalArgumentException("Unknown/invalid trip ID: " + tripId);
  }
  List<PatternHop> hops=tripPattern.getPatternHops();
  Double lon=opt.getFrom().getLng();
  Double lat=opt.getFrom().getLat();
  PatternStopVertex nextStop;
  TripTimes bestTripTimes=null;
  ServiceDay bestServiceDay=null;
  int stopIndex;
  double fractionCovered;
  LineString geomRemaining;
  Coordinate point=lon == null || lat == null ? null : new Coordinate(lon,lat);
  if (point != null) {
    PatternHop bestHop=null;
    double minDist=Double.MAX_VALUE;
    for (    PatternHop hop : hops) {
      LineString line=hop.getGeometry();
      double dist=distanceLibrary.fastDistance(point,line);
      if (dist < minDist) {
        minDist=dist;
        bestHop=hop;
      }
    }
    if (minDist > 1000)     LOG.warn("On-board depart: origin point suspiciously away from nearest trip shape ({} meters)",minDist);
 else     LOG.info("On-board depart: origin point {} meters away from hop shape",minDist);
    LineString geometry=bestHop.getGeometry();
    P2<LineString> geomPair=GeometryUtils.splitGeometryAtPoint(geometry,point);
    geomRemaining=geomPair.getSecond();
    double total=distanceLibrary.fastLength(geometry);
    double remaining=distanceLibrary.fastLength(geomRemaining);
    fractionCovered=total > 0.0 ? (double)(1.0 - remaining / total) : 0.0;
    nextStop=(PatternStopVertex)bestHop.getToVertex();
    stopIndex=bestHop.getStopIndex();
    int minDelta=Integer.MAX_VALUE;
    int actDelta=0;
    for (    ServiceDay serviceDay : ctx.serviceDays) {
      ServiceDate serviceDate=serviceDay.getServiceDate();
      TableTripPattern pattern=nextStop.getTripPattern();
      TripTimes tripTimes=pattern.getTripTimes(pattern.getTripIndex(tripId));
      if (ctx.timetableSnapshot != null) {
        Timetable timeTable=ctx.timetableSnapshot.resolve(pattern,serviceDate);
        tripTimes=timeTable.getTripTimes(timeTable.getTripIndex(tripId));
      }
      int depTime=tripTimes.getDepartureTime(stopIndex);
      int arrTime=tripTimes.getArrivalTime(stopIndex);
      int estTime=(int)Math.round(depTime * fractionCovered + arrTime * (1 - fractionCovered));
      int time=serviceDay.secondsSinceMidnight(opt.dateTime);
      int deltaTime=Math.abs(time - estTime);
      if (deltaTime < minDelta) {
        minDelta=deltaTime;
        actDelta=time - estTime;
        bestTripTimes=tripTimes;
        bestServiceDay=serviceDay;
      }
    }
    if (minDelta > 60000)     LOG.warn("On-board depart: delta between scheduled/real-time and actual time suspiciously large: {} seconds.",actDelta);
 else     LOG.info("On-board depart: delta between scheduled/real-time and actual time is {} seconds.",actDelta);
  }
 else {
    PatternHop firstHop=hops.get(0);
    PatternHop lastHop=hops.get(hops.size() - 1);
    for (    ServiceDay serviceDay : ctx.serviceDays) {
      ServiceDate serviceDate=serviceDay.getServiceDate();
      TripTimes tripTimes=tripPattern.getTripTimes(tripPattern.getTripIndex(tripId));
      if (ctx.timetableSnapshot != null) {
        Timetable timeTable=ctx.timetableSnapshot.resolve(tripPattern,serviceDate);
        tripTimes=timeTable.getTripTimes(timeTable.getTripIndex(tripId));
      }
      int depTime=tripTimes.getDepartureTime(firstHop.getStopIndex());
      int arrTime=tripTimes.getArrivalTime(lastHop.getStopIndex());
      int time=serviceDay.secondsSinceMidnight(opt.dateTime);
      if (depTime <= time && time <= arrTime) {
        bestTripTimes=tripTimes;
        bestServiceDay=serviceDay;
      }
    }
    if (bestServiceDay == null) {
      throw new RuntimeException("Unable to determine on-board depart service day.");
    }
    int time=bestServiceDay.secondsSinceMidnight(opt.dateTime);
    PatternHop bestHop=null;
    for (    PatternHop hop : hops) {
      int depTime=bestTripTimes.getDepartureTime(hop.getStopIndex());
      if (depTime > time) {
        break;
      }
 else {
        bestHop=hop;
      }
    }
    nextStop=(PatternStopVertex)bestHop.getToVertex();
    stopIndex=bestHop.getStopIndex();
    LineString geometry=bestHop.getGeometry();
    int depTime=bestTripTimes.getDepartureTime(stopIndex);
    int arrTime=bestTripTimes.getArrivalTime(stopIndex);
    fractionCovered=((double)(time - depTime)) / ((double)(arrTime - depTime));
    P2<LineString> geomPair=GeometryUtils.splitGeometryAtFraction(geometry,fractionCovered);
    geomRemaining=geomPair.getSecond();
    if (geomRemaining.isEmpty()) {
      lon=Double.NaN;
      lat=Double.NaN;
    }
 else {
      Coordinate start=geomRemaining.getCoordinateN(0);
      lon=start.x;
      lat=start.y;
    }
  }
  OnboardDepartVertex onboardDepart=new OnboardDepartVertex("on_board_depart",lon,lat);
  OnBoardDepartPatternHop startHop=new OnBoardDepartPatternHop(onboardDepart,nextStop,bestTripTimes,bestServiceDay,stopIndex,fractionCovered);
  startHop.setGeometry(geomRemaining);
  return onboardDepart;
}
