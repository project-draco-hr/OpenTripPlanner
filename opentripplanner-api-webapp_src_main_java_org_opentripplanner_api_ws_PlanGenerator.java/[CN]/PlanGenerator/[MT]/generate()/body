{
  TraverseOptions options=getOptions(request);
  checkLocationsAccessible(request,options);
  List<GraphPath> paths=null;
  boolean tooSloped=false;
  try {
    List<NamedPlace> intermediates=request.getIntermediatePlaces();
    if (intermediates.size() == 0) {
      paths=pathService.plan(request.getFromPlace(),request.getToPlace(),request.getDateTime(),options,request.getNumItineraries());
      if (paths == null && request.getWheelchair()) {
        options.maxSlope=Double.MAX_VALUE;
        paths=pathService.plan(request.getFromPlace(),request.getToPlace(),request.getDateTime(),options,request.getNumItineraries());
        tooSloped=true;
      }
    }
 else {
      paths=pathService.plan(request.getFromPlace(),request.getToPlace(),intermediates,request.isIntermediatePlacesOrdered(),request.getDateTime(),options);
    }
  }
 catch (  VertexNotFoundException e) {
    LOG.info("Vertex not found: " + request.getFrom() + " : "+ request.getTo(),e);
    throw e;
  }
  if (paths == null || paths.size() == 0) {
    LOG.info("Path not found: " + request.getFrom() + " : "+ request.getTo());
    throw new PathNotFoundException();
  }
  TripPlan plan=generatePlan(paths,request);
  if (plan != null) {
    for (    Itinerary i : plan.itinerary) {
      i.tooSloped=tooSloped;
      if (i.legs.size() == 0) {
        LOG.warn("itinerary has no legs");
        continue;
      }
      Leg firstLeg=i.legs.get(0);
      firstLeg.from.orig=request.getFromName();
      Leg lastLeg=i.legs.get(i.legs.size() - 1);
      lastLeg.to.orig=request.getToName();
    }
  }
  return plan;
}
