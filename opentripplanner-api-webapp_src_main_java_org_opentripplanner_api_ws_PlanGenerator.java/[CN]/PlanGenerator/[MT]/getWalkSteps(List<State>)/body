{
  List<WalkStep> steps=new ArrayList<WalkStep>();
  WalkStep step=null;
  double lastAngle=0, distance=0;
  int roundaboutExit=0;
  String roundaboutPreviousStreet=null;
  for (  State currState : states) {
    State backState=currState.getBackState();
    Edge edge=currState.getBackEdge();
    EdgeNarrative edgeNarrative=currState.getBackEdgeNarrative();
    boolean createdNewStep=false;
    if (edge instanceof FreeEdge) {
      continue;
    }
    if (!edgeNarrative.getMode().isOnStreetNonTransit()) {
      continue;
    }
    Geometry geom=edgeNarrative.getGeometry();
    if (geom == null) {
      continue;
    }
    if (edge instanceof ElevatorAlightEdge) {
      step=createWalkStep(currState);
      step.streetName=((ElevatorAlightEdge)edge).getName();
      step.relativeDirection=RelativeDirection.ELEVATOR;
      steps.add(step);
      continue;
    }
    String streetName=edgeNarrative.getName();
    if (step == null) {
      step=createWalkStep(currState);
      createdNewStep=true;
      steps.add(step);
      double thisAngle=DirectionUtils.getFirstAngle(geom);
      step.setAbsoluteDirection(thisAngle);
      distance=edgeNarrative.getDistance();
    }
 else     if (step.streetName != streetName && (step.streetName != null && !step.streetName.equals(streetName)) && (!step.bogusName || !edgeNarrative.hasBogusName())) {
      if (roundaboutExit > 0) {
        step.exit=Integer.toString(roundaboutExit);
        if (streetName.equals(roundaboutPreviousStreet)) {
          step.stayOn=true;
        }
        roundaboutExit=0;
      }
      step=createWalkStep(currState);
      createdNewStep=true;
      steps.add(step);
      if (edgeNarrative.isRoundabout()) {
        roundaboutExit=1;
        roundaboutPreviousStreet=backState.getBackEdgeNarrative().getName();
      }
      double thisAngle=DirectionUtils.getFirstAngle(geom);
      step.setDirections(lastAngle,thisAngle,edgeNarrative.isRoundabout());
      distance=edgeNarrative.getDistance();
    }
 else {
      double thisAngle=DirectionUtils.getFirstAngle(geom);
      RelativeDirection direction=WalkStep.getRelativeDirection(lastAngle,thisAngle,edgeNarrative.isRoundabout());
      boolean optionsBefore=backState.multipleOptionsBefore();
      if (edgeNarrative.isRoundabout()) {
        if (optionsBefore) {
          roundaboutExit+=1;
        }
      }
      if (edgeNarrative.isRoundabout() || direction == RelativeDirection.CONTINUE) {
      }
 else {
        boolean shouldGenerateContinue=false;
        if (edge instanceof PlainStreetEdge) {
          double angleDiff=getAbsoluteAngleDiff(thisAngle,lastAngle);
          for (          DirectEdge alternative : backState.getVertex().getOutgoingStreetEdges()) {
            if (alternative instanceof TinyTurnEdge) {
              alternative=alternative.getToVertex().getOutgoingStreetEdges().get(0);
            }
            if (alternative.getName().equals(streetName)) {
              continue;
            }
            double altAngle=DirectionUtils.getFirstAngle(alternative.getGeometry());
            double altAngleDiff=getAbsoluteAngleDiff(altAngle,lastAngle);
            if (angleDiff > Math.PI / 4 || altAngleDiff - angleDiff < Math.PI / 16) {
              shouldGenerateContinue=true;
              break;
            }
          }
        }
 else         if (edge instanceof TinyTurnEdge) {
        }
 else {
          double angleDiff=getAbsoluteAngleDiff(lastAngle,thisAngle);
          State twoStatesBack=backState.getBackState();
          Vertex backVertex=twoStatesBack.getVertex();
          for (          DirectEdge alternative : backVertex.getOutgoingStreetEdges()) {
            List<DirectEdge> alternatives=alternative.getToVertex().getOutgoingStreetEdges();
            if (alternatives.size() == 0) {
              continue;
            }
            alternative=alternatives.get(0);
            if (alternative.getName().equals(streetName)) {
              continue;
            }
            double altAngle=DirectionUtils.getFirstAngle(alternative.getGeometry());
            double altAngleDiff=getAbsoluteAngleDiff(altAngle,lastAngle);
            if (angleDiff > Math.PI / 4 || altAngleDiff - angleDiff < Math.PI / 16) {
              shouldGenerateContinue=true;
              break;
            }
          }
        }
        if (shouldGenerateContinue) {
          step=createWalkStep(currState);
          createdNewStep=true;
          steps.add(step);
          step.setDirections(lastAngle,thisAngle,false);
          step.stayOn=true;
          distance=edgeNarrative.getDistance();
        }
      }
    }
    if (!createdNewStep) {
      if (step.elevation != null) {
        String s=encodeElevationProfile(edge,distance);
        if (step.elevation.length() > 0 && s != null && s.length() > 0)         step.elevation+=",";
        step.elevation+=s;
      }
      distance+=edgeNarrative.getDistance();
    }
    step.distance+=edgeNarrative.getDistance();
    step.addAlerts(edgeNarrative.getNotes());
    lastAngle=DirectionUtils.getLastAngle(geom);
  }
  return steps;
}
