{
  Itinerary itinerary=makeEmptyItinerary(path);
  Leg leg=null;
  List<String> notesForNewLeg=new ArrayList<String>();
  Edge edge=null;
  EdgeNarrative edgeNarrative=null;
  TraverseMode mode=null;
  TraverseMode previousMode=null;
  CoordinateArrayListSequence coordinates=new CoordinateArrayListSequence();
  State finalState=path.states.getLast();
  double previousElevation=Double.MAX_VALUE;
  double edgeElapsedTime;
  GeometryFactory geometryFactory=new GeometryFactory();
  int startWalk=-1;
  int i=-1;
  for (  State currState : path.states) {
    i++;
    edge=currState.getBackEdge();
    edgeNarrative=currState.getBackEdgeNarrative();
    if (edge == null)     continue;
    Set<String> notes=edgeNarrative.getNotes();
    if (notes != null) {
      if (leg == null) {
        notesForNewLeg.addAll(notes);
      }
 else {
        for (        String note : notes) {
          leg.addNote(note);
        }
      }
    }
    edgeElapsedTime=currState.getTimeInMillis() - currState.getBackState().getTimeInMillis();
    if (mode == TraverseMode.BOARDING || mode == TraverseMode.ALIGHTING) {
      itinerary.waitingTime+=edgeElapsedTime;
    }
    if (edge instanceof FreeEdge && currState != finalState) {
      continue;
    }
    mode=edgeNarrative.getMode();
    boolean changingToInterlinedTrip=leg != null && leg.route != null && !leg.route.equals(edgeNarrative.getName()) && mode.isTransit() && previousMode != null && previousMode.isTransit();
    if (mode != previousMode || changingToInterlinedTrip) {
      previousMode=mode;
      if (mode == TraverseMode.TRANSFER) {
        itinerary.walkTime+=edgeElapsedTime;
        itinerary.walkDistance+=edgeNarrative.getDistance();
        continue;
      }
 else       if (mode == TraverseMode.BOARDING) {
        itinerary.transfers++;
        continue;
      }
 else       if (mode == TraverseMode.ALIGHTING) {
        leg.to=makePlace(edgeNarrative.getToVertex());
        leg.endTime=new Date(currState.getBackState().getTimeInMillis());
        continue;
      }
 else       if (changingToInterlinedTrip) {
        leg.to=makePlace(edgeNarrative.getFromVertex());
        leg.endTime=new Date(currState.getBackState().getTimeInMillis());
        Geometry geometry=geometryFactory.createLineString(coordinates);
        leg.legGeometry=PolylineEncoder.createEncodings(geometry);
        coordinates=new CoordinateArrayListSequence();
        leg=makeLeg(currState);
        leg.interlineWithPreviousLeg=true;
        for (        String noteForNewLeg : notesForNewLeg) {
          leg.addNote(noteForNewLeg);
        }
        notesForNewLeg.clear();
        leg.mode=mode.toString();
        startWalk=-1;
        leg.route=edgeNarrative.getName();
        itinerary.addLeg(leg);
      }
 else {
        if (leg != null) {
          if (startWalk != -1) {
            leg.walkSteps=getWalkSteps(pathService,path.states.subList(startWalk,i));
          }
          if (leg.to == null) {
            leg.to=makePlace(edgeNarrative.getFromVertex());
            leg.endTime=new Date(currState.getBackState().getTimeInMillis());
          }
          Geometry geometry=geometryFactory.createLineString(coordinates);
          leg.legGeometry=PolylineEncoder.createEncodings(geometry);
          coordinates=new CoordinateArrayListSequence();
          if (showIntermediateStops && leg.stop != null) {
            leg.stop.remove(leg.stop.size() - 1);
            if (leg.stop.isEmpty()) {
              leg.stop=null;
            }
          }
        }
        leg=makeLeg(currState);
        for (        String noteForNewLeg : notesForNewLeg) {
          leg.addNote(noteForNewLeg);
        }
        notesForNewLeg.clear();
        if (mode == null) {
          mode=currState.getBackState().getBackEdgeNarrative().getMode();
          previousMode=mode;
        }
        leg.mode=mode.toString();
        if (mode.isOnStreetNonTransit()) {
          startWalk=i;
        }
 else {
          startWalk=-1;
          leg.route=edgeNarrative.getName();
        }
        itinerary.addLeg(leg);
      }
    }
    leg.distance+=edgeNarrative.getDistance();
    Geometry edgeGeometry=edgeNarrative.getGeometry();
    if (edgeGeometry != null) {
      Coordinate[] edgeCoordinates=edgeGeometry.getCoordinates();
      if (coordinates.size() > 0 && coordinates.getCoordinate(coordinates.size() - 1).equals(edgeCoordinates[0])) {
        coordinates.extend(edgeCoordinates,1);
      }
 else {
        coordinates.extend(edgeCoordinates);
      }
    }
    if (mode.isOnStreetNonTransit()) {
      itinerary.walkTime+=edgeElapsedTime;
      itinerary.walkDistance+=edgeNarrative.getDistance();
      if (edge instanceof EdgeWithElevation) {
        PackedCoordinateSequence profile=((EdgeWithElevation)edge).getElevationProfile();
        previousElevation=applyElevation(profile,itinerary,previousElevation);
      }
    }
 else     if (mode.isTransit()) {
      itinerary.transitTime+=edgeElapsedTime;
      if (showIntermediateStops) {
        if (leg.stop == null) {
          leg.stop=new ArrayList<Place>();
        }
        if (!(currState.getBackEdge() instanceof Dwell || currState.getBackEdge() instanceof PatternDwell || currState.getBackEdge() instanceof PatternInterlineDwell)) {
          Place stop=makePlace(currState);
          leg.stop.add(stop);
        }
 else {
          leg.stop.get(leg.stop.size() - 1).departure=new Date(currState.getTime());
        }
      }
    }
  }
  if (leg != null) {
    leg.to=makePlace(edgeNarrative.getToVertex());
    leg.endTime=new Date(finalState.getTimeInMillis());
    Geometry geometry=geometryFactory.createLineString(coordinates);
    leg.legGeometry=PolylineEncoder.createEncodings(geometry);
    if (startWalk != -1) {
      leg.walkSteps=getWalkSteps(pathService,path.states.subList(startWalk,i + 1));
    }
    if (showIntermediateStops && leg.stop != null) {
      leg.stop.remove(leg.stop.size() - 1);
      if (leg.stop.isEmpty()) {
        leg.stop=null;
      }
    }
  }
  if (itinerary.transfers == -1) {
    itinerary.transfers=0;
  }
  itinerary.removeBogusLegs();
  return itinerary;
}
