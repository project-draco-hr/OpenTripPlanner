{
  HashSet<Vertex> transitShortestPathVertices=new HashSet<Vertex>();
  graph.rebuildVertexAndEdgeIndices();
  RoutingRequest walk=new RoutingRequest(TraverseMode.WALK);
  RoutingRequest wheelchair=new RoutingRequest(TraverseMode.WALK);
  wheelchair.wheelchairAccessible=true;
  RoutingRequest bikeflat=new RoutingRequest(TraverseMode.BICYCLE);
  bikeflat.optimize=OptimizeType.FLAT;
  RoutingRequest bikesafe=new RoutingRequest(TraverseMode.BICYCLE);
  bikesafe.optimize=OptimizeType.SAFE;
  RoutingRequest bikequick=new RoutingRequest(TraverseMode.BICYCLE);
  bikequick.optimize=OptimizeType.QUICK;
  RoutingRequest[] requests=new RoutingRequest[]{walk,wheelchair,bikeflat,bikesafe,bikequick};
  int i=0;
  final Collection<Vertex> allVertices=graph.getVertices();
  HashMap<Vertex,HashMap<Vertex,int[]>> paths=new HashMap<Vertex,HashMap<Vertex,int[]>>();
  HashMap<Vertex,HashMap<Vertex,T2<Double,Integer>>> costs=new HashMap<Vertex,HashMap<Vertex,T2<Double,Integer>>>();
  for (  Vertex v : allVertices) {
    ++i;
    if (i % 1000 == 0) {
      log.debug(i + " / " + allVertices.size());
    }
    if (!(v instanceof TransitStop)) {
      continue;
    }
    for (    RoutingRequest req : requests) {
      req.setRoutingContext(graph,v,null);
      req.setMaxWalkDistance(3000);
      GenericDijkstra dijkstra=new GenericDijkstra(req);
      State origin=new MaxWalkState(v,req);
      ShortestPathTree spt=dijkstra.getShortestPathTree(origin);
      HashMap<Vertex,int[]> map=null;
      HashMap<Vertex,T2<Double,Integer>> cost=null;
      if (req == walk && saveShortestPaths) {
        map=new HashMap<Vertex,int[]>();
        cost=new HashMap<Vertex,T2<Double,Integer>>();
        paths.put(v,map);
        costs.put(v,cost);
      }
      int[] path=new int[1000];
      for (      State s : spt.getAllStates()) {
        Vertex destStopVertex=s.getVertex();
        if (destStopVertex instanceof TransitStop) {
          int pathIndex=0;
          if (req == walk && saveShortestPaths) {
            cost.put(destStopVertex,new T2<Double,Integer>(s.getWalkDistance(),(int)s.getElapsedTimeSeconds()));
          }
          while (s != null) {
            transitShortestPathVertices.add(s.getVertex());
            path[pathIndex++]=s.getVertex().getIndex();
            s=s.getBackState();
          }
          if (req == walk && saveShortestPaths) {
            map.put(destStopVertex,Arrays.copyOf(path,pathIndex));
          }
        }
      }
    }
  }
  TransitLocalStreetService service=new TransitLocalStreetService(transitShortestPathVertices,paths,costs);
  graph.putService(TransitLocalStreetService.class,service);
}
