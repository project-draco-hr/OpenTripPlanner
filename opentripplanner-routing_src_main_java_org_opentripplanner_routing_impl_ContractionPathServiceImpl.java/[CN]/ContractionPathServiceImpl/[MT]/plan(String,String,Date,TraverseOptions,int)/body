{
  ArrayList<String> notFound=new ArrayList<String>();
  Vertex fromVertex=getVertexForPlace(fromPlace,options);
  if (fromVertex == null) {
    notFound.add("from");
  }
  Vertex toVertex=getVertexForPlace(toPlace,options);
  if (toVertex == null) {
    notFound.add("to");
  }
  if (notFound.size() > 0) {
    throw new VertexNotFoundException(notFound);
  }
  State state=new State(targetTime.getTime());
  if (_calendarService != null)   options.setCalendarService(_calendarService);
  HashSet<GraphPath> paths=new HashSet<GraphPath>();
  Queue<TraverseOptions> optionQueue=new LinkedList<TraverseOptions>();
  optionQueue.add(options);
  if (options.modes.getTrainish() && options.modes.contains(TraverseMode.BUS)) {
    TraverseOptions busOnly=options.clone();
    busOnly.modes=options.modes.clone();
    busOnly.modes.setTrainish(false);
  }
  optionQueue.add(options);
  double maxWeight=Double.MAX_VALUE;
  long maxTime=options.isArriveBy() ? 0 : Long.MAX_VALUE;
  while (paths.size() < nItineraries) {
    options=optionQueue.poll();
    if (options == null) {
      break;
    }
    options.worstTime=maxTime;
    options.maxWeight=maxWeight;
    GraphPath path=_routingService.route(fromVertex,toVertex,state,options);
    if (maxWeight == Double.MAX_VALUE) {
      if (path == null) {
        return null;
      }
      maxWeight=path.vertices.lastElement().weightSum * 2;
      long tripTime=path.vertices.lastElement().state.getTime() - path.vertices.firstElement().state.getTime();
      if (options.isArriveBy()) {
        maxTime=path.vertices.lastElement().state.getTime() - tripTime * 2;
      }
 else {
        maxTime=path.vertices.firstElement().state.getTime() + tripTime * 2;
      }
    }
    if (path == null) {
      continue;
    }
    if (!paths.contains(path)) {
      paths.add(path);
      for (      SPTEdge spte : path.edges) {
        Edge e=spte.payload;
        if (e instanceof PatternBoard) {
          Trip trip=spte.getTrip();
          String routeName=GtfsLibrary.getRouteName(trip.getRoute());
          RouteSpec spec=new RouteSpec(trip.getId().getAgencyId(),routeName);
          TraverseOptions newOptions=options.clone();
          newOptions.bannedRoutes.add(spec);
          if (!optionQueue.contains(newOptions)) {
            optionQueue.add(newOptions);
          }
        }
      }
    }
  }
  if (paths.size() == 0) {
    return null;
  }
  return new ArrayList<GraphPath>(paths);
}
