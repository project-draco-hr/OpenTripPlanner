{
  StreetVertexIndexService streetIndex=new StreetVertexIndexServiceImpl(graph);
  GeometryFactory geometryFactory=GeometryUtils.getGeometryFactory();
  GraphIndex gidx=new GraphIndex(graph);
  LOG.info("Linking stops directly to one another for long distance routing...");
  int nTransfers=0;
  for (  TransitStop ts0 : Iterables.filter(graph.getVertices(),TransitStop.class)) {
    Coordinate c0=ts0.getCoordinate();
    Map<TripPattern,StopAtDistance> closestStops=new SimpleIsochrone.MinMap<TripPattern,StopAtDistance>();
    for (    TransitStop ts1 : streetIndex.getNearbyTransitStops(c0,radius)) {
      if (!ts1.isStreetLinkable())       continue;
      double distance=distanceLibrary.distance(c0,ts1.getCoordinate());
      StopAtDistance nearbyStop=new StopAtDistance(ts1,distance);
      for (      TripPattern pattern : gidx.patternsForStop.get(ts1.getStop())) {
        closestStops.put(pattern,nearbyStop);
      }
    }
    Set<StopAtDistance> uniqueStops=Sets.newHashSet();
    uniqueStops.addAll(closestStops.values());
    for (    StopAtDistance nearbyStop : uniqueStops) {
      if (nearbyStop.tstop == ts0)       continue;
      Coordinate coordinates[]=new Coordinate[]{c0,nearbyStop.tstop.getCoordinate()};
      LineString geometry=geometryFactory.createLineString(coordinates);
      new SimpleTransfer(ts0,nearbyStop.tstop,nearbyStop.dist,geometry);
      nTransfers+=1;
    }
    LOG.debug("Linked stop {} to {} nearby stops on other patterns.",ts0.getStop(),uniqueStops.size());
  }
  LOG.info("Done linking stops to one another. Created {} transfers.",nTransfers);
}
