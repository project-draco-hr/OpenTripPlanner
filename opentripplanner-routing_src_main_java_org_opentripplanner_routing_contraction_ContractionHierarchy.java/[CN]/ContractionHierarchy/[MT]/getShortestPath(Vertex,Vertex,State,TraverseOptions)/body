{
  if (origin == null || target == null) {
    return null;
  }
  Map<Vertex,ArrayList<Edge>> extraEdges=getExtraEdges(origin,target);
  LabelBasicShortestPathTree upspt=new LabelBasicShortestPathTree();
  LabelBasicShortestPathTree downspt=new LabelBasicShortestPathTree();
  FibHeap<SPTVertex> upqueue=new FibHeap<SPTVertex>(up.getVertices().size() + graph.getVertices().size() + extraEdges.size());
  FibHeap<SPTVertex> downqueue=new FibHeap<SPTVertex>(down.getVertices().size() + graph.getVertices().size() + extraEdges.size());
  SPTVertex spt_origin=upspt.addVertex(origin,init,0,options);
  upqueue.insert(spt_origin,spt_origin.weightSum);
  SPTVertex spt_target=downspt.addVertex(target,init,0,options);
  downqueue.insert(spt_target,spt_target.weightSum);
  HashSet<Vertex> upclosed=new HashSet<Vertex>();
  HashSet<Vertex> downclosed=new HashSet<Vertex>();
  Vertex meeting=null;
  double bestMeetingCost=Double.POSITIVE_INFINITY;
  boolean done_up=false;
  boolean done_down=false;
  while (!(done_up && done_down)) {
    if (!done_up) {
      if (upqueue.empty()) {
        done_up=true;
        continue;
      }
      SPTVertex up_u=upqueue.extract_min();
      Vertex fromv=up_u.mirror;
      String fromLabel=fromv.getLabel();
      if (up_u.weightSum > bestMeetingCost) {
        done_up=true;
        continue;
      }
      upclosed.add(fromv);
      if (downclosed.contains(fromv)) {
        double thisMeetingCost=up_u.weightSum + downspt.getVertex(fromv).weightSum;
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=fromv;
        }
        continue;
      }
      GraphVertex fromgv=graph.getGraphVertex(fromLabel);
      if (options.getArriveBy() && fromgv != null) {
        continue;
      }
      Collection<Edge> outgoing=null;
      if (fromgv != null) {
        outgoing=fromgv.getOutgoing();
      }
      fromgv=up.getGraphVertex(fromLabel);
      if (fromgv != null) {
        if (outgoing == null) {
          outgoing=fromgv.getOutgoing();
        }
 else {
          Collection<Edge> upOutgoing=fromgv.getOutgoing();
          ArrayList<Edge> newOutgoing=new ArrayList<Edge>(outgoing.size() + upOutgoing.size());
          newOutgoing.addAll(outgoing);
          newOutgoing.addAll(upOutgoing);
          outgoing=newOutgoing;
        }
      }
      if (extraEdges.containsKey(fromv)) {
        List<Edge> newOutgoing=new ArrayList<Edge>();
        if (outgoing != null) {
          for (          Edge edge : outgoing)           newOutgoing.add(edge);
        }
        newOutgoing.addAll(extraEdges.get(fromv));
        outgoing=newOutgoing;
      }
      State state=up_u.state;
      for (      Edge edge : outgoing) {
        Vertex toVertex=edge.getToVertex();
        if (upclosed.contains(toVertex)) {
          continue;
        }
        TraverseResult wr=edge.traverse(state,options);
        if (wr == null) {
          continue;
        }
        if (wr.weight < 0) {
          throw new NegativeWeightException(String.valueOf(wr.weight) + " on edge " + edge);
        }
        double new_w=up_u.weightSum + wr.weight;
        if (new_w > options.maxWeight) {
          continue;
        }
        if (!options.getArriveBy() && wr.state.getTime() > options.worstTime) {
          continue;
        }
        SPTVertex up_v=upspt.addVertex(toVertex,wr.state,new_w,options);
        if (up_v != null) {
          up_v.setParent(up_u,edge);
          upqueue.insert_or_dec_key(up_v,new_w);
        }
      }
    }
    if (!done_down) {
      if (downqueue.empty()) {
        done_down=true;
        continue;
      }
      SPTVertex down_u=downqueue.extract_min();
      Vertex tov=down_u.mirror;
      if (down_u.weightSum > bestMeetingCost) {
        done_down=true;
        continue;
      }
      String toLabel=tov.getLabel();
      if (upclosed.contains(tov)) {
        double thisMeetingCost=down_u.weightSum + upspt.getVertex(tov).weightSum;
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=tov;
        }
      }
      downclosed.add(tov);
      GraphVertex maingv=graph.getGraphVertex(toLabel);
      if (!options.getArriveBy() && maingv != null) {
        continue;
      }
      GraphVertex downgv=down.getGraphVertex(tov);
      Collection<Edge> incoming=null;
      if (downgv != null) {
        incoming=downgv.getIncoming();
      }
      if (maingv != null) {
        if (incoming == null) {
          incoming=maingv.getIncoming();
        }
 else {
          Collection<Edge> mainIncoming=maingv.getIncoming();
          ArrayList<Edge> newIncoming=new ArrayList<Edge>(incoming.size() + mainIncoming.size());
          newIncoming.addAll(incoming);
          newIncoming.addAll(mainIncoming);
          incoming=newIncoming;
        }
      }
      if (extraEdges.containsKey(tov)) {
        List<Edge> newIncoming=new ArrayList<Edge>();
        if (incoming != null) {
          for (          Edge edge : incoming)           newIncoming.add(edge);
        }
        newIncoming.addAll(extraEdges.get(tov));
        incoming=newIncoming;
      }
      State state=down_u.state;
      for (      Edge edge : incoming) {
        Vertex fromVertex=edge.getFromVertex();
        if (downclosed.contains(fromVertex)) {
          continue;
        }
        TraverseResult wr=edge.traverseBack(state,options);
        if (wr == null) {
          continue;
        }
        if (wr.weight < 0) {
          throw new NegativeWeightException(String.valueOf(wr.weight) + " on edge " + edge);
        }
        double new_w=down_u.weightSum + wr.weight;
        if (new_w > options.maxWeight) {
          continue;
        }
        if (options.getArriveBy() && wr.state.getTime() < options.worstTime) {
          continue;
        }
        SPTVertex down_v=downspt.addVertex(fromVertex,wr.state,new_w,options);
        if (down_v != null) {
          down_v.setParent(down_u,edge);
          downqueue.insert_or_dec_key(down_v,new_w);
        }
      }
    }
  }
  if (meeting == null) {
    return null;
  }
  GraphPath upPath=upspt.getPath(meeting);
  GraphPath downPath=downspt.getPath(meeting);
  GraphPath path=new GraphPath();
  path.edges.addAll(upPath.edges);
  ListIterator<SPTEdge> it=downPath.edges.listIterator(downPath.edges.size());
  while (it.hasPrevious()) {
    SPTEdge e=it.previous();
    SPTVertex swap=e.tov;
    e.tov=e.fromv;
    e.fromv=swap;
    path.edges.add(e);
  }
  if (path.edges == null) {
    return null;
  }
  path.edges=flatten(path.edges);
  if (options.getArriveBy()) {
    cleanPathEdgesBack(init,path,options);
  }
 else {
    cleanPathEdges(init,path,options);
  }
  return path;
}
