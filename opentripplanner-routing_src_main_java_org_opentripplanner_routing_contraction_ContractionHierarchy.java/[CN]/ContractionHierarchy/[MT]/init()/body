{
  createThreadPool();
  updown=new OverlayGraph();
  long start=System.currentTimeMillis();
  HashMap<Vertex,Integer> deletedNeighbors=new HashMap<Vertex,Integer>();
  _log.debug("Preparing contraction hierarchy -- this may take quite a while");
  _log.debug("Initializing priority queue");
  BinHeap<Vertex> pq=initPriorityQueue(core);
  _log.debug("Contracting");
  long lastNotified=System.currentTimeMillis();
  int i=0;
  int nContractableVertices, totalContractableVertices;
  totalContractableVertices=nContractableVertices=pq.size();
  int nContractableEdges=countContractableEdges(core);
  boolean edgesRemoved=false;
  while (!pq.empty()) {
    if (i > Math.ceil(totalContractableVertices * contractionFactor)) {
      break;
    }
    i+=1;
    Vertex vertex=pq.extract_min();
    _log.trace("contracting vertex " + vertex);
    WitnessSearchResult shortcutsAndSearchSpace;
    if (pq.empty()) {
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
 else {
      while (true) {
        shortcutsAndSearchSpace=getShortcuts(vertex,true);
        int deleted=0;
        if (deletedNeighbors.containsKey(vertex)) {
          deleted=deletedNeighbors.get(vertex);
        }
        double new_prio=getImportance(vertex,shortcutsAndSearchSpace,deleted);
        Double new_min=pq.peek_min_key();
        if (new_prio <= new_min) {
          break;
        }
 else {
          pq.insert(vertex,new_prio);
          vertex=pq.extract_min();
        }
      }
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
    long now=System.currentTimeMillis();
    if (now - lastNotified > 5000) {
      _log.debug("contracted: " + i + " / "+ totalContractableVertices+ " ("+ i / (double)totalContractableVertices + ") total time " + (now - start) / 1000.0 + "sec, average degree " + nContractableEdges / (nContractableVertices + 0.00001));
      lastNotified=now;
    }
    HashSet<Vertex> neighbors=new HashSet<Vertex>();
    for (    DirectEdge de : filter(core.getOutgoing(vertex),DirectEdge.class)) {
      Vertex toVertex=de.getToVertex();
      core.removeIncoming(toVertex,de);
      updown.addOutgoing(vertex,de);
      neighbors.add(toVertex);
      nContractableEdges--;
    }
    for (    DirectEdge de : filter(core.getIncoming(vertex),DirectEdge.class)) {
      Vertex fromVertex=de.getFromVertex();
      core.removeOutgoing(fromVertex,de);
      updown.addIncoming(vertex,de);
      neighbors.add(fromVertex);
      nContractableEdges--;
    }
    core.removeVertex(vertex);
    for (    Vertex n : neighbors) {
      int deleted=0;
      if (deletedNeighbors.containsKey(n)) {
        deleted=deletedNeighbors.get(n);
      }
      deleted+=1;
      deletedNeighbors.put(n,deleted);
      WitnessSearchResult nwsr=getShortcuts(n,true);
      double new_prio=getImportance(n,nwsr,deleted);
      pq.rekey(n,new_prio);
    }
    List<Shortcut> shortcuts=shortcutsAndSearchSpace.shortcuts;
    for (    Shortcut shortcut : shortcuts) {
      core.addDirectEdge(shortcut);
    }
    nContractableVertices--;
    nContractableEdges+=shortcuts.size();
    if (nContractableVertices == 0) {
      continue;
    }
  }
  threadPool.shutdownNow();
  threadPool=null;
}
