{
  createThreadPool();
  up=new Graph(graph);
  down=new Graph(graph);
  long start=System.currentTimeMillis();
  HashMap<Vertex,Integer> deletedNeighbors=new HashMap<Vertex,Integer>();
  _log.debug("Preparing contraction hierarchy -- this may take quite a while");
  _log.debug("init prio queue");
  BinHeap<Vertex> pq=initPriorityQueue(graph);
  _log.debug("contract");
  long lastNotified=System.currentTimeMillis();
  int i=0;
  int nVertices=pq.size();
  int totalVertices=nVertices;
  int nEdges=countEdges(graph);
  boolean edgesRemoved=false;
  while (!pq.empty()) {
    if (i++ > Math.ceil(totalVertices * contractionFactor)) {
      break;
    }
    Vertex vertex=pq.extract_min();
    WitnessSearchResult shortcutsAndSearchSpace;
    if (pq.empty()) {
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
 else {
      while (true) {
        shortcutsAndSearchSpace=getShortcuts(vertex,true);
        int deleted=0;
        if (deletedNeighbors.containsKey(vertex)) {
          deleted=deletedNeighbors.get(vertex);
        }
        double new_prio=getImportance(vertex,shortcutsAndSearchSpace,deleted);
        Double new_min=pq.peek_min_key();
        if (new_prio <= new_min) {
          break;
        }
 else {
          pq.insert(vertex,new_prio);
          vertex=pq.extract_min();
        }
      }
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
    long now=System.currentTimeMillis();
    if (now - lastNotified > 5000) {
      _log.debug("contracted: " + i + " / "+ totalVertices+ " ("+ i / (double)totalVertices + ") total time " + (now - start) / 1000.0 + "sec, average degree " + nEdges / (nVertices + 0.00001));
      lastNotified=now;
    }
    Vertex downVertex=down.getVertex(down.addVertex(vertex));
    HashSet<Vertex> neighbors=new HashSet<Vertex>();
    for (    Edge ee : graph.getIncoming(vertex)) {
      nEdges--;
      Vertex originalFromVertex=graph.getVertex(ee.getFromVertex());
      down.addVertex(originalFromVertex.vertex);
      originalFromVertex.removeOutgoing(ee);
      downVertex.addIncoming(ee);
      neighbors.add(originalFromVertex.vertex);
    }
    Vertex upVertex=up.getVertex(up.addVertex(vertex));
    for (    DirectEdge ee : filter(graph.getOutgoing(vertex),DirectEdge.class)) {
      nEdges--;
      Vertex originalToVertex=graph.getVertex(ee.getToVertex());
      up.addVertex(originalToVertex.vertex);
      originalToVertex.removeIncoming(ee);
      upVertex.addOutgoing(ee);
      neighbors.add(originalToVertex.vertex);
    }
    graph.removeVertex(vertex);
    for (    Vertex n : neighbors) {
      int deleted=0;
      if (deletedNeighbors.containsKey(n)) {
        deleted=deletedNeighbors.get(n);
      }
      deleted+=1;
      deletedNeighbors.put(n,deleted);
      WitnessSearchResult nwsr=getShortcuts(n,true);
      double new_prio=getImportance(n,nwsr,deleted);
      pq.rekey(n,new_prio);
    }
    List<Shortcut> shortcuts=shortcutsAndSearchSpace.shortcuts;
    for (    Shortcut shortcut : shortcuts) {
      graph.addEdge(shortcut.getFromVertex(),shortcut.getToVertex(),shortcut);
    }
    nVertices--;
    nEdges+=shortcuts.size();
    if (nVertices == 0) {
      continue;
    }
  }
  threadPool.shutdownNow();
  threadPool=null;
}
