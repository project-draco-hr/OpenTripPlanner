{
  createThreadPool();
  updown=new OverlayGraph();
  long start=System.currentTimeMillis();
  HashMap<Vertex,Integer> deletedNeighbors=new HashMap<Vertex,Integer>();
  _log.debug("Preparing contraction hierarchy -- this may take quite a while");
  _log.debug("Initializing priority queue");
  BinHeap<Vertex> pq=initPriorityQueue(graph);
  _log.debug("Contracting");
  long lastNotified=System.currentTimeMillis();
  int i=0;
  int nContractableVertices, totalContractableVertices;
  totalContractableVertices=nContractableVertices=pq.size();
  int nContractableEdges=countContractableEdges(graph);
  boolean edgesRemoved=false;
  while (!pq.empty()) {
    i+=1;
    Vertex vertex=pq.extract_min();
    _log.trace("contracting vertex " + vertex);
    WitnessSearchResult shortcutsAndSearchSpace;
    if (pq.empty()) {
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
 else {
      while (true) {
        shortcutsAndSearchSpace=getShortcuts(vertex,true);
        int deleted=0;
        if (deletedNeighbors.containsKey(vertex)) {
          deleted=deletedNeighbors.get(vertex);
        }
        double new_prio=getImportance(vertex,shortcutsAndSearchSpace,deleted);
        Double new_min=pq.peek_min_key();
        if (new_prio <= new_min) {
          break;
        }
 else {
          pq.insert(vertex,new_prio);
          vertex=pq.extract_min();
        }
      }
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
    long now=System.currentTimeMillis();
    if (now - lastNotified > 5000) {
      _log.debug("contracted: " + i + " / "+ totalContractableVertices+ " ("+ i / (double)totalContractableVertices + ") total time " + (now - start) / 1000.0 + "sec, average degree " + nContractableEdges / (nContractableVertices + 0.00001));
      lastNotified=now;
    }
    HashSet<Vertex> neighbors=new HashSet<Vertex>();
    for (    DirectEdge de : filter(graph.getOutgoing(vertex),DirectEdge.class)) {
      Vertex toVertex=de.getToVertex();
      graph.removeIncoming(toVertex,de);
      updown.addOutgoing(vertex,de);
      neighbors.add(toVertex);
      nContractableEdges--;
    }
    for (    DirectEdge de : filter(graph.getIncoming(vertex),DirectEdge.class)) {
      Vertex fromVertex=de.getFromVertex();
      graph.removeOutgoing(fromVertex,de);
      updown.addIncoming(vertex,de);
      neighbors.add(fromVertex);
      nContractableEdges--;
    }
    graph.removeVertex(vertex);
    for (    Vertex n : neighbors) {
      int deleted=0;
      if (deletedNeighbors.containsKey(n)) {
        deleted=deletedNeighbors.get(n);
      }
      deleted+=1;
      deletedNeighbors.put(n,deleted);
      WitnessSearchResult nwsr=getShortcuts(n,true);
      double new_prio=getImportance(n,nwsr,deleted);
      pq.rekey(n,new_prio);
    }
    List<Shortcut> shortcuts=shortcutsAndSearchSpace.shortcuts;
    for (    Shortcut shortcut : shortcuts) {
      graph.addDirectEdge(shortcut);
    }
    nContractableVertices--;
    nContractableEdges+=shortcuts.size();
    if (nContractableVertices == 0) {
      continue;
    }
  }
  threadPool.shutdownNow();
  threadPool=null;
}
