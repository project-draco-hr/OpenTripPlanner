{
  if (origin == null || target == null) {
    return null;
  }
  RoutingRequest upOptions=opt.clone();
  RoutingRequest downOptions=opt.clone();
  upOptions.setArriveBy(false);
  upOptions.dateTime=time;
  upOptions.setRoutingContext(graph,origin,target);
  downOptions.setArriveBy(true);
  downOptions.dateTime=time;
  upOptions.setRoutingContext(graph,target,origin);
  double minWalkDistance=origin.getDistanceToNearestTransitStop() + target.getDistanceToNearestTransitStop();
  upOptions.setMaxWalkDistance(Math.max(upOptions.getMaxWalkDistance(),minWalkDistance));
  downOptions.setMaxWalkDistance(Math.max(downOptions.getMaxWalkDistance(),minWalkDistance));
  final boolean VERBOSE=false;
  final int INITIAL_SIZE=1000;
  if (VERBOSE)   _log.debug("origin {} target {}",origin,target);
  Map<Vertex,ArrayList<Edge>> extraEdges=getExtraEdges(origin,target);
  BasicShortestPathTree upspt=new BasicShortestPathTree(upOptions);
  BasicShortestPathTree downspt=new BasicShortestPathTree(downOptions);
  BinHeap<State> upqueue=new BinHeap<State>(INITIAL_SIZE);
  BinHeap<State> downqueue=new BinHeap<State>(INITIAL_SIZE);
  HashSet<Vertex> upclosed=new HashSet<Vertex>(INITIAL_SIZE);
  HashSet<Vertex> downclosed=new HashSet<Vertex>(INITIAL_SIZE);
  State upInit=new State(origin,upOptions);
  upspt.add(upInit);
  upqueue.insert(upInit,upInit.getWeight());
  State downInit=new State(target,downOptions);
  downspt.add(downInit);
  downqueue.insert(downInit,downInit.getWeight());
  Vertex meeting=null;
  double bestMeetingCost=Double.POSITIVE_INFINITY;
  boolean done_up=false;
  boolean done_down=false;
  while (!(done_up && done_down)) {
    if (!done_up) {
      if (upqueue.empty()) {
        done_up=true;
        continue;
      }
      State up_su=upqueue.extract_min();
      if (up_su.exceedsWeightLimit(bestMeetingCost)) {
        if (VERBOSE)         _log.debug("pruning on up tree (best meeting cost)");
        done_up=true;
        continue;
      }
      Vertex u=up_su.getVertex();
      upclosed.add(u);
      if (VERBOSE)       _log.debug("    extract up {}",u);
      if (downclosed.contains(u) && downspt.getState(u).getWalkDistance() + up_su.getWalkDistance() <= up_su.getOptions().getMaxWalkDistance()) {
        double thisMeetingCost=up_su.getWeight() + downspt.getState(u).getWeight();
        if (VERBOSE)         _log.debug("    meeting at {}",u);
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=u;
        }
        continue;
      }
      if (opt.isArriveBy() && !(u instanceof StreetVertex)) {
        continue;
      }
      Collection<Edge> outgoing=u.getOutgoing();
      if (VERBOSE)       _log.debug("        {} edges in core",outgoing.size());
      if (extraEdges.containsKey(u)) {
        List<Edge> newOutgoing=new ArrayList<Edge>();
        newOutgoing.addAll(extraEdges.get(u));
        if (VERBOSE)         _log.debug("        {} edges in extra",newOutgoing.size());
        newOutgoing.addAll(outgoing);
        outgoing=newOutgoing;
      }
      for (      Edge edge : outgoing) {
        if (VERBOSE)         _log.debug("        edge up {}",edge);
        if (edge instanceof OutEdge) {
          continue;
        }
        State up_sv=edge.traverse(up_su);
        if (up_sv == null) {
          continue;
        }
        Vertex v=up_sv.getVertex();
        if (upclosed.contains(v)) {
          continue;
        }
        if (up_sv.exceedsWeightLimit(opt.maxWeight)) {
          continue;
        }
        if (!opt.isArriveBy() && up_sv.getTime() > opt.worstTime) {
          continue;
        }
        if (upspt.add(up_sv)) {
          double weight=up_sv.getWeight();
          if (weight < bestMeetingCost)           upqueue.insert(up_sv,weight);
        }
      }
    }
    if (!done_down) {
      if (downqueue.empty()) {
        done_down=true;
        continue;
      }
      State down_su=downqueue.extract_min();
      if (!downspt.visit(down_su))       continue;
      if (down_su.exceedsWeightLimit(bestMeetingCost)) {
        done_down=true;
        continue;
      }
      Vertex down_u=down_su.getVertex();
      if (VERBOSE)       _log.debug("    extract down {}",down_u);
      if (upclosed.contains(down_u) && upspt.getState(down_u).getWalkDistance() + down_su.getWalkDistance() <= down_su.getOptions().getMaxWalkDistance()) {
        double thisMeetingCost=down_su.getWeight() + upspt.getState(down_u).getWeight();
        if (VERBOSE)         _log.debug("    meeting at {}",down_u);
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=down_u;
        }
      }
      downclosed.add(down_u);
      if (!opt.isArriveBy() && !(down_u instanceof StreetVertex)) {
        continue;
      }
      Collection<Edge> incoming=down_u.getIncoming();
      if (VERBOSE)       _log.debug("        {} edges in core",incoming.size());
      if (extraEdges.containsKey(down_u)) {
        List<Edge> newIncoming=new ArrayList<Edge>();
        newIncoming.addAll(incoming);
        newIncoming.addAll(extraEdges.get(down_u));
        incoming=newIncoming;
      }
      if (VERBOSE)       _log.debug("        {} edges with overlay and extra",incoming.size());
      for (      Edge edge : incoming) {
        if (VERBOSE)         _log.debug("        edge down {}",edge);
        Vertex down_v=edge.getFromVertex();
        if (downclosed.contains(down_v)) {
          continue;
        }
        if (edge instanceof OutEdge) {
          continue;
        }
        State down_sv=edge.traverse(down_su);
        if (VERBOSE)         _log.debug("        result down {}",down_sv);
        if (down_sv == null) {
          continue;
        }
        if (down_sv.exceedsWeightLimit(opt.maxWeight)) {
          if (VERBOSE)           _log.debug("        down result too heavy {}",down_sv);
          continue;
        }
        if (opt.isArriveBy() && down_sv.getTime() < opt.worstTime) {
          if (VERBOSE)           _log.debug("        down result exceeds worst time {} {}",opt.worstTime,down_sv);
          continue;
        }
        if (downspt.add(down_sv)) {
          double weight=down_sv.getWeight();
          if (weight < bestMeetingCost)           downqueue.insert(down_sv,weight);
        }
      }
    }
  }
  if (meeting == null) {
    return null;
  }
 else {
    if (VERBOSE)     _log.debug("meeting point is {}",meeting);
  }
  State upMeet=upspt.getState(meeting);
  State downMeet=downspt.getState(meeting);
  State r=opt.isArriveBy() ? downMeet : upMeet;
  State s=opt.isArriveBy() ? upMeet : downMeet;
  while (s.getBackEdge() != null) {
    r=s.getBackEdge().traverse(r);
    if (r == null)     return null;
    s=s.getBackState();
  }
  s=r.reversedClone();
  while (r.getBackEdge() != null) {
    Edge e=r.getBackEdge();
    if (e instanceof Shortcut)     s=((Shortcut)e).unpackTraverse(s);
 else     s=e.traverse(s);
    if (s == null)     return null;
    r=r.getBackState();
  }
  GraphPath ret=new GraphPath(s,false);
  return ret;
}
