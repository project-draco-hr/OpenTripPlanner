{
  _log.debug("removing non-optimal edges, hopLimit is {}",hopLimit);
  int removed=0;
  for (  Vertex u : core.getVertices()) {
    State su=new State(u,fwdOptions);
    Dijkstra dijkstra=new Dijkstra(core,u,fwdOptions,null,hopLimit);
    BasicShortestPathTree spt=dijkstra.getShortestPathTree(Double.POSITIVE_INFINITY,Integer.MAX_VALUE);
    ArrayList<Edge> toRemove=new ArrayList<Edge>();
    for (    Edge e : filter(core.getOutgoing(u),Edge.class)) {
      if (!isContractable(e)) {
        continue;
      }
      State svSpt=spt.getState(e.getToVertex());
      State sv=e.traverse(su);
      if (sv == null) {
        toRemove.add(e);
        continue;
      }
      if (svSpt != null && sv.getBackState().getVertex() != u && svSpt.getWeight() <= sv.getWeight() + .01) {
        toRemove.add(e);
      }
    }
    for (    Edge e : toRemove) {
      core.removeEdge(e);
    }
    removed+=toRemove.size();
  }
  return removed;
}
