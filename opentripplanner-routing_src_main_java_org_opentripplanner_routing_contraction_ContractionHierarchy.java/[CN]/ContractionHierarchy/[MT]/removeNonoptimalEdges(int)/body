{
  _log.debug("removing non-optimal edges, hopLimit is {}",hopLimit);
  int removed=0;
  for (  GraphVertex gu : graph.getVertices()) {
    Vertex u=gu.vertex;
    State su=new State(u,options);
    Dijkstra dijkstra=new Dijkstra(graph,u,options,null,hopLimit);
    BasicShortestPathTree spt=dijkstra.getShortestPathTree(Double.POSITIVE_INFINITY,Integer.MAX_VALUE);
    ArrayList<DirectEdge> toRemove=new ArrayList<DirectEdge>();
    for (    DirectEdge e : filter(graph.getOutgoing(u),DirectEdge.class)) {
      if (!isContractable(e)) {
        continue;
      }
      State svSpt=spt.getState(e.getToVertex());
      State sv=e.traverse(su);
      if (sv == null) {
        toRemove.add(e);
        continue;
      }
      if (svSpt != null && sv.getBackState().getVertex() != u && svSpt.getWeight() <= sv.getWeight() + .01) {
        toRemove.add(e);
      }
    }
    for (    DirectEdge e : toRemove) {
      gu.removeOutgoing(e);
      graph.getGraphVertex(e.getToVertex()).removeIncoming(e);
    }
    removed+=toRemove.size();
  }
  return removed;
}
