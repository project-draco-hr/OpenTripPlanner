{
  _log.debug("removing non-optimal edges, hopLimit is {}",hopLimit);
  int removed=0;
  for (  Vertex u : core.getVertices()) {
    State su=new State(u,fwdOptions);
    Dijkstra dijkstra=new Dijkstra(core,u,fwdOptions,null,hopLimit);
    BasicShortestPathTree spt=dijkstra.getShortestPathTree(Double.POSITIVE_INFINITY,Integer.MAX_VALUE);
    ArrayList<DirectEdge> toRemove=new ArrayList<DirectEdge>();
    for (    DirectEdge e : filter(core.getOutgoing(u),DirectEdge.class)) {
      if (!isContractable(e)) {
        continue;
      }
      State svSpt=spt.getState(e.getToVertex());
      State sv=e.traverse(su);
      if (sv == null) {
        toRemove.add(e);
        continue;
      }
      if (svSpt != null && sv.getBackState().getVertex() != u && svSpt.getWeight() <= sv.getWeight() + .01) {
        toRemove.add(e);
      }
    }
    for (    DirectEdge e : toRemove) {
      core.removeDirectEdge(e);
    }
    removed+=toRemove.size();
  }
  return removed;
}
