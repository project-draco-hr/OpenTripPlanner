{
  createThreadPool();
  long start=System.currentTimeMillis();
  HashMap<Vertex,Integer> deletedNeighbors=new HashMap<Vertex,Integer>();
  _log.debug("Preparing contraction hierarchy -- this may take quite a while");
  _log.debug("Initializing priority queue");
  BinHeap<Vertex> pq=initPriorityQueue(graph);
  _log.debug("Contracting");
  long lastNotified=System.currentTimeMillis();
  int i=0;
  int totalContractableVertices=pq.size();
  int nContractableEdges=countContractableEdges(graph);
  boolean edgesRemoved=false;
  while (!pq.empty()) {
    if (i > Math.ceil(totalContractableVertices * contractionFactor)) {
      break;
    }
    i+=1;
    Vertex vertex=pq.extract_min();
    _log.trace("contracting vertex " + vertex);
    WitnessSearchResult shortcutsAndSearchSpace;
    if (pq.empty()) {
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
 else {
      while (true) {
        shortcutsAndSearchSpace=getShortcuts(vertex,true);
        int deleted=0;
        if (deletedNeighbors.containsKey(vertex)) {
          deleted=deletedNeighbors.get(vertex);
        }
        double new_prio=getImportance(vertex,shortcutsAndSearchSpace,deleted);
        Double new_min=pq.peek_min_key();
        if (new_prio <= new_min) {
          break;
        }
 else {
          pq.insert(vertex,new_prio);
          vertex=pq.extract_min();
        }
      }
      shortcutsAndSearchSpace=getShortcuts(vertex,false);
    }
    long now=System.currentTimeMillis();
    if (now - lastNotified > 5000) {
      _log.debug("contracted: " + i + " / "+ totalContractableVertices+ " ("+ i / (double)totalContractableVertices + ") total time " + (now - start) / 1000.0 + "sec, average degree " + nContractableEdges / (corev.size() + 0.00001));
      lastNotified=now;
    }
    HashSet<Vertex> neighbors=new HashSet<Vertex>();
    for (    Edge de : vertex.getOutgoing()) {
      Vertex toVertex=de.getToVertex();
      neighbors.add(toVertex);
      nContractableEdges--;
    }
    for (    Edge de : vertex.getIncoming()) {
      Vertex fromVertex=de.getFromVertex();
      neighbors.add(fromVertex);
      nContractableEdges--;
    }
    for (    Vertex n : neighbors) {
      int deleted=0;
      if (deletedNeighbors.containsKey(n)) {
        deleted=deletedNeighbors.get(n);
      }
      deleted+=1;
      deletedNeighbors.put(n,deleted);
      WitnessSearchResult nwsr=getShortcuts(n,true);
      double new_prio=getImportance(n,nwsr,deleted);
      pq.rekey(n,new_prio);
    }
    for (    PotentialShortcut ps : shortcutsAndSearchSpace.shortcuts) {
      ps.make();
      nContractableEdges+=1;
    }
    if (corev.remove(vertex)) {
      chv.add(vertex);
    }
 else {
      _log.warn("attempt to move vertex out of core when it was not still in core.");
    }
    if (corev.size() == 0) {
      continue;
    }
  }
  threadPool.shutdownNow();
  threadPool=null;
}
