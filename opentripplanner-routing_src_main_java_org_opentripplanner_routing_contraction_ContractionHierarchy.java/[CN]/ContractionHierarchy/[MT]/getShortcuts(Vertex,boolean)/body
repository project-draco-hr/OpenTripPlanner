{
  State su=new State(u,backOptions);
  int searchSpace=0;
  ArrayList<State> vs=new ArrayList<State>();
  for (  Edge e : u.getIncoming()) {
    if (!corev.contains(e.getFromVertex()))     continue;
    State sv=e.traverse(su);
    if (sv == null)     continue;
    vs.add(sv);
  }
  su=new State(u,fwdOptions);
  double maxWWeight=0;
  ArrayList<State> ws=new ArrayList<State>();
  for (  Edge e : u.getOutgoing()) {
    if (!corev.contains(e.getToVertex()))     continue;
    State sw=e.traverse(su);
    if (sw == null)     continue;
    ws.add(sw);
    if (sw.exceedsWeightLimit(maxWWeight))     maxWWeight=sw.getWeight();
  }
  List<PotentialShortcut> shortcuts=new ArrayList<PotentialShortcut>();
  ArrayList<Callable<WitnessSearchResult>> tasks=new ArrayList<Callable<WitnessSearchResult>>(vs.size());
  int nodeLimit=simulate ? NODE_LIMIT_SIMULATE : NODE_LIMIT_CONTRACT;
  int hopLimit=simulate ? HOP_LIMIT_SIMULATE : HOP_LIMIT_CONTRACT;
  for (  State v : vs) {
    double weightLimit=v.getWeight() + maxWWeight + 1;
    WitnessSearch task=new WitnessSearch(u,hopLimit,nodeLimit,weightLimit,ws,v);
    tasks.add(task);
  }
  if (threadPool == null) {
    createThreadPool();
  }
  try {
    for (    Future<WitnessSearchResult> future : threadPool.invokeAll(tasks)) {
      WitnessSearchResult wsresult=future.get();
      BasicShortestPathTree spt=wsresult.spt;
      searchSpace+=wsresult.searchSpace;
      shortcuts.addAll(wsresult.shortcuts);
    }
  }
 catch (  Exception e1) {
    throw new RuntimeException(e1);
  }
  return new WitnessSearchResult(shortcuts,null,null,searchSpace);
}
