{
  State su=new State(u,backOptions);
  int searchSpace=0;
  ArrayList<State> vs=new ArrayList<State>();
  for (  Edge e : u.getIncoming()) {
    if (!isContractable(e)) {
      continue;
    }
    State sv=e.traverse(su);
    if (sv == null) {
      continue;
    }
    vs.add(sv);
  }
  su=new State(u,fwdOptions);
  double maxWWeight=0;
  HashSet<Vertex> wvSet=new HashSet<Vertex>();
  ArrayList<State> ws=new ArrayList<State>();
  for (  DirectEdge e : filter(u.getOutgoing(),DirectEdge.class)) {
    if (!isContractable(e)) {
      continue;
    }
    State sw=e.traverse(su);
    if (sw == null) {
      continue;
    }
    wvSet.add(sw.getVertex());
    ws.add(sw);
    if (sw.exceedsWeightLimit(maxWWeight)) {
      maxWWeight=sw.getWeight();
    }
  }
  List<Shortcut> shortcuts=new ArrayList<Shortcut>();
  ArrayList<Callable<WitnessSearchResult>> tasks=new ArrayList<Callable<WitnessSearchResult>>(vs.size());
  int nodeLimit=simulate ? NODE_LIMIT_SIMULATE : NODE_LIMIT_CONTRACT;
  int hopLimit=simulate ? HOP_LIMIT_SIMULATE : HOP_LIMIT_CONTRACT;
  for (  State v : vs) {
    double weightLimit=v.getWeight() + maxWWeight + 1;
    WitnessSearch task=new WitnessSearch(u,hopLimit,nodeLimit,weightLimit,wvSet,ws,v);
    tasks.add(task);
  }
  if (threadPool == null) {
    createThreadPool();
  }
  try {
    for (    Future<WitnessSearchResult> future : threadPool.invokeAll(tasks)) {
      WitnessSearchResult wsresult=future.get();
      BasicShortestPathTree spt=wsresult.spt;
      if (!simulate && spt != null) {
        ArrayList<DirectEdge> toRemove=new ArrayList<DirectEdge>();
        State sv0=new State(wsresult.vertex,fwdOptions);
        for (        DirectEdge e : filter(wsresult.vertex.getOutgoing(),DirectEdge.class)) {
          State sSpt=spt.getState(e.getToVertex());
          if (sSpt == null) {
            continue;
          }
          State sv1=e.traverse(sv0);
          if (sv1 == null) {
            toRemove.add(e);
            continue;
          }
          if (sSpt.getWeight() < sv1.getWeight()) {
            toRemove.add(e);
          }
        }
        Vertex uv=wsresult.vertex;
        for (        DirectEdge e : toRemove) {
          uv.removeOutgoing(e);
          e.getToVertex().removeIncoming(e);
        }
      }
      searchSpace+=wsresult.searchSpace;
      shortcuts.addAll(wsresult.shortcuts);
    }
  }
 catch (  InterruptedException e1) {
    throw new RuntimeException(e1);
  }
catch (  ExecutionException e1) {
    throw new RuntimeException(e1);
  }
  return new WitnessSearchResult(shortcuts,null,null,searchSpace);
}
