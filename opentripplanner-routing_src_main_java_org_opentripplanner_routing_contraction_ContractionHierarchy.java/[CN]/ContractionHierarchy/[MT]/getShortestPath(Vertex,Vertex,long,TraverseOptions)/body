{
  TraverseOptions upOptions=opt.clone();
  TraverseOptions downOptions=opt.clone();
  double minWalkDistance=origin.getDistanceToNearestTransitStop() + target.getDistanceToNearestTransitStop();
  upOptions.maxWalkDistance=Math.max(upOptions.maxWalkDistance,minWalkDistance);
  downOptions.maxWalkDistance=Math.max(downOptions.maxWalkDistance,minWalkDistance);
  upOptions.setArriveBy(false);
  downOptions.setArriveBy(true);
  final boolean VERBOSE=false;
  final int INITIAL_SIZE=1000;
  if (origin == null || target == null) {
    return null;
  }
  if (VERBOSE)   _log.debug("origin {} target {}",origin,target);
  Map<Vertex,ArrayList<Edge>> extraEdges=getExtraEdges(origin,target);
  BasicShortestPathTree upspt=new BasicShortestPathTree();
  BasicShortestPathTree downspt=new BasicShortestPathTree();
  BinHeap<State> upqueue=new BinHeap<State>(INITIAL_SIZE);
  BinHeap<State> downqueue=new BinHeap<State>(INITIAL_SIZE);
  HashSet<Vertex> upclosed=new HashSet<Vertex>(INITIAL_SIZE);
  HashSet<Vertex> downclosed=new HashSet<Vertex>(INITIAL_SIZE);
  State upInit=new State(time,origin,upOptions);
  upspt.add(upInit);
  upqueue.insert(upInit,upInit.getWeight());
  State downInit=new State(time,target,downOptions);
  downspt.add(downInit);
  downqueue.insert(downInit,downInit.getWeight());
  RemainingWeightHeuristic h=opt.remainingWeightHeuristic;
  if (opt.isArriveBy())   h.computeInitialWeight(downInit,origin);
 else   h.computeInitialWeight(upInit,target);
  Vertex meeting=null;
  double bestMeetingCost=Double.POSITIVE_INFINITY;
  boolean done_up=false;
  boolean done_down=false;
  while (!(done_up && done_down)) {
    if (!done_up) {
      if (upqueue.empty()) {
        done_up=true;
        continue;
      }
      State up_su=upqueue.extract_min();
      if (!upspt.visit(up_su))       continue;
      if (up_su.exceedsWeightLimit(bestMeetingCost)) {
        if (VERBOSE)         _log.debug("pruning on up tree (best meeting cost)");
        done_up=true;
        continue;
      }
      Vertex u=up_su.getVertex();
      upclosed.add(u);
      if (VERBOSE)       _log.debug("    extract up {}",u);
      if (downclosed.contains(u) && downspt.getState(u).getWalkDistance() + up_su.getWalkDistance() <= up_su.getOptions().maxWalkDistance) {
        double thisMeetingCost=up_su.getWeight() + downspt.getState(u).getWeight();
        if (VERBOSE)         _log.debug("    meeting at {}",u);
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=u;
        }
        continue;
      }
      GraphVertex gu=graph.getGraphVertex(u);
      if (VERBOSE)       _log.debug("    up main graph vertex {}",gu);
      if (opt.isArriveBy() && gu != null) {
        continue;
      }
      Collection<Edge> outgoing=null;
      if (gu != null) {
        outgoing=gu.getOutgoing();
      }
      gu=up.getGraphVertex(u);
      if (VERBOSE)       _log.debug("    up overlay graph vertex {}",gu);
      if (gu != null) {
        if (outgoing == null) {
          outgoing=gu.getOutgoing();
        }
 else {
          Collection<Edge> upOutgoing=gu.getOutgoing();
          ArrayList<Edge> newOutgoing=new ArrayList<Edge>(outgoing.size() + upOutgoing.size());
          newOutgoing.addAll(outgoing);
          newOutgoing.addAll(upOutgoing);
          outgoing=newOutgoing;
        }
      }
      if (extraEdges.containsKey(u)) {
        List<Edge> newOutgoing=new ArrayList<Edge>();
        if (outgoing != null)         newOutgoing.addAll(outgoing);
        newOutgoing.addAll(extraEdges.get(u));
        outgoing=newOutgoing;
      }
      for (      Edge edge : outgoing) {
        if (VERBOSE)         _log.debug("        edge up {}",edge);
        if (edge instanceof OutEdge) {
          continue;
        }
        State up_sv=edge.traverse(up_su);
        if (up_sv == null) {
          continue;
        }
        Vertex v=up_sv.getVertex();
        if (upclosed.contains(v)) {
          continue;
        }
        if (up_sv.exceedsWeightLimit(opt.maxWeight)) {
          continue;
        }
        if (!opt.isArriveBy() && up_sv.getTime() > opt.worstTime) {
          continue;
        }
        if (upspt.add(up_sv)) {
          double weightEstimate=up_sv.getWeight();
          if (!opt.isArriveBy())           weightEstimate+=h.computeForwardWeight(up_sv,target);
          if (weightEstimate < bestMeetingCost)           upqueue.insert(up_sv,weightEstimate);
        }
      }
    }
    if (!done_down) {
      if (downqueue.empty()) {
        done_down=true;
        continue;
      }
      State down_su=downqueue.extract_min();
      if (!downspt.visit(down_su))       continue;
      if (down_su.exceedsWeightLimit(bestMeetingCost)) {
        done_down=true;
        continue;
      }
      Vertex down_u=down_su.getVertex();
      if (VERBOSE)       _log.debug("    extract down {}",down_u);
      if (upclosed.contains(down_u) && upspt.getState(down_u).getWalkDistance() + down_su.getWalkDistance() <= down_su.getOptions().maxWalkDistance) {
        double thisMeetingCost=down_su.getWeight() + upspt.getState(down_u).getWeight();
        if (VERBOSE)         _log.debug("    meeting at {}",down_u);
        if (thisMeetingCost < bestMeetingCost) {
          bestMeetingCost=thisMeetingCost;
          meeting=down_u;
        }
      }
      downclosed.add(down_u);
      GraphVertex maingu=graph.getGraphVertex(down_u);
      if (!opt.isArriveBy() && maingu != null) {
        continue;
      }
      GraphVertex downgu=down.getGraphVertex(down_u);
      Collection<Edge> incoming=null;
      if (downgu != null) {
        incoming=downgu.getIncoming();
      }
      if (maingu != null) {
        if (incoming == null) {
          incoming=maingu.getIncoming();
        }
 else {
          Collection<Edge> mainIncoming=maingu.getIncoming();
          ArrayList<Edge> newIncoming=new ArrayList<Edge>(incoming.size() + mainIncoming.size());
          newIncoming.addAll(incoming);
          newIncoming.addAll(mainIncoming);
          incoming=newIncoming;
        }
      }
      if (extraEdges.containsKey(down_u)) {
        List<Edge> newIncoming=new ArrayList<Edge>();
        if (incoming != null)         newIncoming.addAll(incoming);
        newIncoming.addAll(extraEdges.get(down_u));
        incoming=newIncoming;
      }
      for (      Edge edge : incoming) {
        if (VERBOSE)         _log.debug("        edge down {}",edge);
        Vertex down_v=edge.getFromVertex();
        if (downclosed.contains(down_v)) {
          continue;
        }
        if (edge instanceof OutEdge) {
          continue;
        }
        State down_sv=edge.traverse(down_su);
        if (VERBOSE)         _log.debug("        result down {}",down_sv);
        if (down_sv == null) {
          continue;
        }
        if (down_sv.exceedsWeightLimit(opt.maxWeight)) {
          if (VERBOSE)           _log.debug("        down result too heavy {}",down_sv);
          continue;
        }
        if (opt.isArriveBy() && down_sv.getTime() < opt.worstTime) {
          if (VERBOSE)           _log.debug("        down result exceeds worst time {} {}",opt.worstTime,down_sv);
          continue;
        }
        if (downspt.add(down_sv)) {
          double weightEstimate=down_sv.getWeight();
          if (opt.isArriveBy())           weightEstimate+=h.computeReverseWeight(down_sv,origin);
          if (weightEstimate < bestMeetingCost)           downqueue.insert(down_sv,weightEstimate);
        }
      }
    }
  }
  if (meeting == null) {
    return null;
  }
 else {
    if (VERBOSE)     _log.debug("meeting point is {}",meeting);
  }
  State upMeet=upspt.getState(meeting);
  State downMeet=downspt.getState(meeting);
  State r=opt.isArriveBy() ? downMeet : upMeet;
  State s=opt.isArriveBy() ? upMeet : downMeet;
  while (s.getBackEdge() != null) {
    r=s.getBackEdge().traverse(r);
    if (r == null)     return null;
    s=s.getBackState();
  }
  s=r.reversedClone();
  while (r.getBackEdge() != null) {
    Edge e=r.getBackEdge();
    if (e instanceof Shortcut)     s=((Shortcut)e).unpackTraverse(s);
 else     s=e.traverse(s);
    if (s == null)     return null;
    r=r.getBackState();
  }
  GraphPath ret=new GraphPath(s,false);
  return ret;
}
