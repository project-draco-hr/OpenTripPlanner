{
  LOG.debug("Looking for/making a vertex near {}",location);
  Coordinate coord=location.getCoordinate();
  StreetVertex intersection=getIntersectionAt(coord,MAX_CORNER_DISTANCE);
  Locale locale;
  if (options == null) {
    locale=new Locale("en");
  }
 else {
    locale=options.getLocale();
  }
  I18NString calculatedName=null;
  if (location.getName() != null) {
    calculatedName=new NonLocalizedString(location.getName());
  }
  if (intersection != null) {
    boolean canEscape=false;
    if (options == null) {
      canEscape=true;
    }
 else {
      TraversalRequirements reqs=new TraversalRequirements(options);
      for (      StreetEdge e : IterableLibrary.filter(options.arriveBy ? intersection.getIncoming() : intersection.getOutgoing(),StreetEdge.class)) {
        if (reqs.canBeTraversed(e)) {
          canEscape=true;
          break;
        }
      }
    }
    if (canEscape) {
      if (!location.hasName()) {
        LOG.debug("found intersection {}. not splitting.",intersection);
        Set<String> uniqueNameSet=new HashSet<String>();
        for (        Edge e : intersection.getOutgoing()) {
          if (e instanceof StreetEdge) {
            uniqueNameSet.add(e.getName(locale));
          }
        }
        List<String> uniqueNames=new ArrayList<String>(uniqueNameSet);
        String fmt=ResourceBundleSingleton.INSTANCE.localize("corner",locale);
        if (uniqueNames.size() > 1) {
          calculatedName=new NonLocalizedString(String.format(fmt,uniqueNames.get(0),uniqueNames.get(1)));
        }
 else         if (uniqueNames.size() == 1) {
          calculatedName=new NonLocalizedString(uniqueNames.get(0));
        }
 else {
          calculatedName=new LocalizedString("unnamedStreed",(String[])null);
        }
      }
      StreetLocation closest=new StreetLocation(graph,"corner " + Math.random(),coord,calculatedName);
      FreeEdge e=new FreeEdge(closest,intersection);
      closest.getExtra().add(e);
      e=new FreeEdge(intersection,closest);
      closest.getExtra().add(e);
      return closest;
    }
  }
  double closestStopDistance=Double.POSITIVE_INFINITY;
  Vertex closestStop=null;
  if (options != null && options.getModes().isTransit()) {
    for (    Vertex v : getLocalTransitStops(coord,1000)) {
      double d=distanceLibrary.distance(v.getCoordinate(),coord);
      if (d < closestStopDistance) {
        closestStopDistance=d;
        closestStop=v;
      }
    }
  }
  LOG.debug(" best stop: {} distance: {}",closestStop,closestStopDistance);
  StreetLocation closestStreet=null;
  CandidateEdgeBundle bundle=getClosestEdges(location,options,extraEdges,null,false);
  CandidateEdge candidate=bundle.best;
  double closestStreetDistance=Double.POSITIVE_INFINITY;
  if (candidate != null) {
    StreetEdge bestStreet=candidate.edge;
    Coordinate nearestPoint=candidate.nearestPointOnEdge;
    closestStreetDistance=distanceLibrary.distance(coord,nearestPoint);
    LOG.debug("best street: {} dist: {}",bestStreet.toString(),closestStreetDistance);
    if (calculatedName == null || "".equals(calculatedName.toString(locale))) {
      calculatedName=new NonLocalizedString(bestStreet.getName(locale));
    }
    String closestName=String.format("%s_%s",calculatedName.toString(locale),location.toString());
    closestStreet=StreetLocation.createStreetLocation(graph,closestName,calculatedName,bundle.toEdgeList(),nearestPoint,coord);
  }
  if (closestStreet == null) {
    LOG.debug("returning only transit stop (no street found)");
    return closestStop;
  }
 else {
    if (closestStop != null) {
      double relativeStopDistance=closestStopDistance / closestStreetDistance;
      if (relativeStopDistance < 1.5) {
        LOG.debug("linking transit stop to street (distances are comparable)");
        closestStreet.addExtraEdgeTo(closestStop);
      }
    }
    LOG.debug("returning split street");
    return closestStreet;
  }
}
