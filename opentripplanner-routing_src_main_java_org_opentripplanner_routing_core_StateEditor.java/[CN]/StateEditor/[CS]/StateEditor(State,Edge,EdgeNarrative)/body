{
  child=parent.clone();
  child.backState=parent;
  child.backEdge=e;
  child.backEdgeNarrative=en;
  child.next=null;
  if (e == null) {
    child.backState=null;
    child.hops=0;
    child.vertex=parent.vertex;
    child.stateData=child.stateData.clone();
  }
 else {
    child.hops=parent.hops + 1;
    if (en.getFromVertex().equals(en.getToVertex()) && parent.vertex.equals(en.getFromVertex())) {
      traversingBackward=parent.getOptions().isArriveBy();
      child.vertex=en.getToVertex();
    }
 else     if (parent.vertex.equals(en.getFromVertex())) {
      traversingBackward=false;
      child.vertex=en.getToVertex();
    }
 else     if (parent.vertex.equals(en.getToVertex())) {
      traversingBackward=true;
      child.vertex=en.getFromVertex();
    }
 else {
      _log.warn("Edge is not connected to parent state: {}",en);
      _log.warn("   from   vertex: {}",en.getFromVertex());
      _log.warn("   to     vertex: {}",en.getToVertex());
      _log.warn("   parent vertex: {}",parent.vertex);
      defectiveTraversal=true;
    }
    if (traversingBackward != parent.getOptions().isArriveBy()) {
      _log.error("Actual traversal direction does not match traversal direction in TraverseOptions.");
      defectiveTraversal=true;
    }
    if (parent.stateData.noThruTrafficState == NoThruTrafficState.INIT && !(e instanceof FreeEdge)) {
      setNoThruTrafficState(NoThruTrafficState.BETWEEN_ISLANDS);
    }
  }
}
