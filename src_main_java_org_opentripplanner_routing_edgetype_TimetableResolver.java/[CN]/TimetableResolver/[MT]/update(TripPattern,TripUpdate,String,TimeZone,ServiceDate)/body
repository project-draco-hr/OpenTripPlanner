{
synchronized (this) {
    if (dirty == null)     throw new ConcurrentModificationException("This TimetableResolver is read-only.");
    Timetable tt=resolve(pattern,serviceDate);
    if (!dirty.contains(tt)) {
      Timetable old=tt;
      tt=new Timetable(tt,serviceDate);
      SortedSet<Timetable> sortedTimetables=timetables.get(pattern);
      if (sortedTimetables == null) {
        sortedTimetables=new TreeSet<Timetable>(new SortedTimetableComparator());
      }
 else {
        SortedSet<Timetable> temp=new TreeSet<Timetable>(new SortedTimetableComparator());
        temp.addAll(sortedTimetables);
        sortedTimetables=temp;
      }
      if (old.serviceDate != null)       sortedTimetables.remove(old);
      sortedTimetables.add(tt);
      timetables.put(pattern,sortedTimetables);
      dirty.add(tt);
    }
    TripTimes updatedTripTimes=tt.createUpdatedTripTimes(tripUpdate,timeZone,serviceDate);
    if (updatedTripTimes != null) {
      String tripId=tripUpdate.getTrip().getTripId();
      int tripIndex=tt.getTripIndex(tripId);
      if (tripIndex == -1) {
        LOG.info("tripId {} not found in pattern.",tripId);
        return false;
      }
      tt.setTripTimes(tripIndex,updatedTripTimes);
      return true;
    }
 else {
      return false;
    }
  }
}
