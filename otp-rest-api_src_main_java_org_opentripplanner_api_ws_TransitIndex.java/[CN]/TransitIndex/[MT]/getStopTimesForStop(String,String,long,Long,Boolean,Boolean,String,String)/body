{
  startTime/=1000;
  if (endTime == null) {
    endTime=startTime + 86400;
  }
 else {
    endTime/=1000;
  }
  if (endTime - startTime > MAX_STOP_TIME_QUERY_INTERVAL) {
    return new TransitError("Max stop time query interval is " + (endTime - startTime) + " > "+ MAX_STOP_TIME_QUERY_INTERVAL);
  }
  TransitIndexService transitIndexService=getGraph(routerId).getService(TransitIndexService.class);
  if (transitIndexService == null) {
    return new TransitError("No transit index found.  Add TransitIndexBuilder to your graph builder configuration and rebuild your graph.");
  }
  Graph graph=getGraph(routerId);
  HashSet<TripType> trips=new HashSet<TripType>();
  StopTimeList result=new StopTimeList();
  result.stopTimes=new ArrayList<StopTime>();
  if (references != null && references.equals(true)) {
    result.routes=new HashSet<Route>();
  }
  for (  String stopAgencyId : getAgenciesIds(stopAgency,routerId)) {
    AgencyAndId stop=new AgencyAndId(stopAgencyId,stopId);
    Edge preBoardEdge=transitIndexService.getPreBoardEdge(stop);
    if (preBoardEdge == null)     continue;
    Vertex boarding=preBoardEdge.getToVertex();
    RoutingRequest options=makeTraverseOptions(startTime,routerId);
    HashMap<Long,Edge> seen=new HashMap();
    OUTER:     for (    Edge e : boarding.getOutgoing()) {
      for (      StopTime st : getStopTimesForBoardEdge(startTime,endTime,options,e,extended)) {
        st.phase="departure";
        if (extended != null && extended.equals(true)) {
          if (routeId != null && !routeId.equals("") && !st.trip.getRoute().getId().getId().equals(routeId))           continue;
          if (references != null && references.equals(true))           result.routes.add(st.trip.getRoute());
          result.stopTimes.add(st);
        }
 else         result.stopTimes.add(st);
        trips.add(st.trip);
        if (seen.containsKey(st.time)) {
          Edge old=seen.get(st.time);
          System.out.println("DUP: " + old);
          getStopTimesForBoardEdge(startTime,endTime,options,e,extended);
        }
        seen.put(st.time,e);
      }
    }
    Edge preAlightEdge=transitIndexService.getPreAlightEdge(stop);
    Vertex alighting=preAlightEdge.getFromVertex();
    for (    Edge e : alighting.getIncoming()) {
      for (      StopTime st : getStopTimesForAlightEdge(startTime,endTime,options,e,extended)) {
        if (!trips.contains(st.trip)) {
          st.phase="arrival";
          if (extended != null && extended.equals(true)) {
            if (references != null && references.equals(true))             result.routes.add(st.trip.getRoute());
            if (routeId != null && !routeId.equals("") && !st.trip.getRoute().getId().getId().equals(routeId))             continue;
            result.stopTimes.add(st);
          }
 else           result.stopTimes.add(st);
        }
      }
    }
  }
  Collections.sort(result.stopTimes,new Comparator<StopTime>(){
    @Override public int compare(    StopTime o1,    StopTime o2){
      if (o1.phase.equals("arrival") && o2.phase.equals("departure"))       return 1;
      if (o1.phase.equals("departure") && o2.phase.equals("arrival"))       return -1;
      return o1.time - o2.time > 0 ? 1 : -1;
    }
  }
);
  return result;
}
