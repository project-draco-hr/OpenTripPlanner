{
  String origin_label=from_label;
  String target_label=to_label;
  Vertex origin=gg.getVertex(origin_label);
  Vertex target=gg.getVertex(target_label);
  if (origin == null) {
    return null;
  }
  ShortestPathTree spt=new ShortestPathTree();
  double distance=origin.distance(target) / MAX_SPEED;
  SPTVertex spt_origin=spt.addVertex(origin,init,0);
  FibHeap pq=new FibHeap(gg.getVertices().size());
  pq.insert(spt_origin,spt_origin.weightSum + distance);
  SPTVertex spt_u, spt_v;
  int i=0;
  while (!pq.empty()) {
    spt_u=(SPTVertex)pq.extract_min();
    if (spt_u.mirror == target)     break;
    for (    Edge edge : spt_u.mirror.outgoing) {
      i++;
      TraverseResult wr=edge.payload.traverse(spt_u.state,options);
      if (wr == null) {
        continue;
      }
      if (wr.weight < 0) {
        throw new NegativeWeightException(String.valueOf(wr.weight));
      }
      distance=edge.tov.distance(target) / MAX_SPEED;
      double new_w=spt_u.weightSum + wr.weight;
      double old_w;
      spt_v=spt.getVertex(edge.tov);
      if (spt_v == null) {
        old_w=Integer.MAX_VALUE;
        spt_v=spt.addVertex(edge.tov,wr.state,new_w);
      }
 else {
        old_w=spt_v.weightSum + distance;
      }
      if (new_w + distance < old_w) {
        spt_v.state=wr.state;
        spt_v.weightSum=new_w;
        if (old_w == Integer.MAX_VALUE) {
          pq.insert(spt_v,new_w + distance);
        }
 else {
          pq.insert_or_dec_key(spt_v,new_w + distance);
        }
        spt_v.setParent(spt_u,edge.payload);
      }
    }
  }
  System.out.println("examined: " + i);
  return spt;
}
