{
  SPTVertex spt_u, spt_v;
  if (targets != null) {
    targets.remove(origin);
  }
  closed.add(taboo);
  while (!queue.empty()) {
    spt_u=(SPTVertex)queue.peek_min();
    Vertex fromv=spt_u.mirror;
    if (nodeLimit-- <= 0) {
      return spt;
    }
    queue.extract_min();
    closed.add(fromv);
    if (targets != null) {
      targets.remove(fromv);
      if (targets.size() == 0) {
        return spt;
      }
    }
    Iterable<Edge> outgoing=graph.getOutgoing(fromv);
    State state=spt_u.state;
    for (    Edge edge : outgoing) {
      if (!(edge instanceof TurnEdge || edge instanceof FreeEdge || edge instanceof Shortcut|| edge instanceof PlainStreetEdge)) {
        continue;
      }
      Vertex toVertex=edge.getToVertex();
      if (closed.contains(toVertex)) {
        continue;
      }
      TraverseResult wr=edge.traverse(state,options);
      if (wr == null) {
        continue;
      }
      if (wr.weight < 0) {
        throw new NegativeWeightException(String.valueOf(wr.weight));
      }
      double new_w=spt_u.weightSum + wr.weight;
      spt_v=spt.addVertex(toVertex,wr.state,new_w,options,spt_u.hops + 1);
      if (spt_v != null) {
        spt_v.setParent(spt_u,edge);
        if (spt_u.hops < hopLimit && new_w < weightLimit) {
          queue.insert_or_dec_key(spt_v,new_w);
        }
      }
      if (neighbors != null && neighbors.containsKey(toVertex)) {
        SPTVertex parent=spt.getVertex(toVertex);
        for (        VertexIngress w : neighbors.get(toVertex)) {
          State newState=wr.state.clone();
          newState.incrementTimeInSeconds((int)w.time);
          double neighborWeight=w.weight + new_w;
          if (neighborWeight < weightLimit) {
            SPTVertex spt_w=spt.addVertex(w.vertex,newState,neighborWeight,options,spt_u.hops + 2);
            if (spt_w != null) {
              spt_w.setParent(parent,w.edge);
              queue.insert_or_dec_key(spt_w,neighborWeight);
            }
          }
        }
      }
    }
  }
  return spt;
}
