{
  SPTVertex spt_u, spt_v;
  HashSet<Vertex> closed=new HashSet<Vertex>();
  FibHeap<SPTVertex> queue=new FibHeap<SPTVertex>(graph.getVertices().size());
  BasicShortestPathTree spt=new BasicShortestPathTree();
  State init=new State();
  SPTVertex spt_origin=spt.addVertex(origin,init,0,options);
  queue.insert(spt_origin,spt_origin.weightSum);
  HashMap<TripPattern,Double> patternCosts=new HashMap<TripPattern,Double>();
  int patternsSeen=0;
  while (!queue.empty()) {
    spt_u=queue.peek_min();
    Vertex fromv=spt_u.mirror;
    queue.extract_min();
    closed.add(fromv);
    if (fromv instanceof TransitStop) {
      Vertex departureVertex=null;
      for (      DirectEdge e : filter(graph.getOutgoing(fromv),DirectEdge.class)) {
        departureVertex=e.getToVertex();
        break;
      }
      for (      Edge e : graph.getOutgoing(departureVertex)) {
        if (e instanceof PatternBoard) {
          TripPattern pattern=((PatternBoard)e).getPattern();
          if (nearbyPatterns.contains(pattern)) {
            Double cost=patternCosts.get(pattern);
            if (cost == null) {
              patternCosts.put(pattern,spt_u.weightSum);
              patternsSeen++;
              if (patternsSeen == nearbyPatterns.size()) {
                return patternCosts;
              }
            }
 else             if (cost > spt_u.weightSum) {
              patternCosts.put(pattern,spt_u.weightSum);
            }
          }
        }
      }
    }
    if (fromv.distance(origin) > LOCAL_STOP_SEARCH_RADIUS) {
      return patternCosts;
    }
    Iterable<Edge> outgoing=graph.getOutgoing(fromv);
    State state=spt_u.state;
    for (    Edge edge : outgoing) {
      TraverseResult wr=edge.traverse(state,options);
      if (wr == null) {
        continue;
      }
      if (wr.weight < 0) {
        throw new NegativeWeightException(String.valueOf(wr.weight));
      }
      EdgeNarrative en=wr.getEdgeNarrative();
      Vertex toVertex=en.getToVertex();
      if (closed.contains(toVertex)) {
        continue;
      }
      double new_w=spt_u.weightSum + wr.weight;
      spt_v=spt.addVertex(toVertex,wr.state,new_w,options,spt_u.hops + 1);
      if (spt_v != null) {
        spt_v.setParent(spt_u,edge,en);
        queue.insert_or_dec_key(spt_v,new_w);
      }
    }
  }
  return patternCosts;
}
