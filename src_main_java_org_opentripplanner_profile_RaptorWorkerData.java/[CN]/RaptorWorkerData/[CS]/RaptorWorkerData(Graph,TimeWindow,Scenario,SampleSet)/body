{
  int totalPatterns=graph.index.patternForId.size();
  int totalStops=graph.index.stopForId.size();
  timetablesForPattern=new ArrayList<RaptorWorkerTimetable>(totalPatterns);
  List<TripPattern> patternForIndex=Lists.newArrayList(totalPatterns);
  TObjectIntMap<TripPattern> indexForPattern=new TObjectIntHashMap<>(totalPatterns,0.75f,-1);
  indexForStop=new TObjectIntHashMap<>(totalStops,0.75f,-1);
  List<Stop> stopForIndex=new ArrayList<>(totalStops);
  Multimap<Stop,TripPattern> patternsForStopObject=HashMultimap.create();
  for (  TripPattern originalPattern : graph.index.patternForId.values()) {
    Collection<TripPattern> patterns=Arrays.asList(originalPattern);
    if (scenario != null && scenario.modifications != null) {
      for (      TripPatternFilter filter : Iterables.filter(scenario.modifications,TripPatternFilter.class)) {
        Collection<TripPattern> modifiedPatterns=Lists.newArrayList();
        for (        TripPattern pattern : patterns) {
          Collection<TripPattern> result=filter.apply(pattern);
          if (result != null)           modifiedPatterns.addAll(result);
        }
        patterns=modifiedPatterns;
      }
    }
    for (    TripPattern pattern : patterns) {
      RaptorWorkerTimetable timetable=RaptorWorkerTimetable.forPattern(graph,pattern,window,scenario);
      if (timetable == null) {
        continue;
      }
      timetablesForPattern.add(timetable);
      indexForPattern.put(pattern,patternForIndex.size());
      patternForIndex.add(pattern);
      patternNames.add(pattern.code);
      TIntList stopIndexesForPattern=new TIntArrayList();
      for (      Stop stop : pattern.getStops()) {
        int stopIndex=indexForStop.get(stop);
        if (stopIndex == -1) {
          stopIndex=indexForStop.size();
          indexForStop.put(stop,stopIndex);
          stopForIndex.add(stop);
          stopNames.add(stop.getName());
        }
        stopIndexesForPattern.add(stopIndex);
        patternsForStopObject.put(stop,pattern);
      }
      stopsForPattern.add(stopIndexesForPattern.toArray());
    }
  }
  for (  Stop stop : stopForIndex) {
    TIntList patterns=new TIntArrayList();
    for (    TripPattern pattern : patternsForStopObject.get(stop)) {
      int patternIndex=indexForPattern.get(pattern);
      if (patternIndex != -1) {
        patterns.add(patternIndex);
      }
    }
    patternsForStop.add(patterns.toArray());
  }
  for (  Stop stop : stopForIndex) {
    TIntList transfers=new TIntArrayList();
    TransitStop tstop=graph.index.stopVertexForStop.get(stop);
    for (    SimpleTransfer simpleTransfer : Iterables.filter(tstop.getOutgoing(),SimpleTransfer.class)) {
      int targetStopIndex=indexForStop.get(((TransitStop)simpleTransfer.getToVertex()).getStop());
      if (targetStopIndex != -1) {
        transfers.add(targetStopIndex);
        transfers.add((int)(simpleTransfer.getDistance()));
      }
    }
    transfersForStop.add(transfers.toArray());
  }
  StopTreeCache stc=graph.index.getStopTreeCache();
  if (sampleSet == null) {
    for (    Stop stop : stopForIndex) {
      TransitStop tstop=graph.index.stopVertexForStop.get(stop);
      targetsForStop.add(stc.distancesForStop.get(tstop));
    }
    nTargets=Vertex.getMaxIndex();
  }
 else {
    TIntObjectMap<List<HalfSample>> sampleIndex=new TIntObjectHashMap<List<HalfSample>>();
    for (int i=0; i < sampleSet.pset.capacity; i++) {
      if (sampleSet.v0s[i] == null)       continue;
      int v0=sampleSet.v0s[i].getIndex();
      List<HalfSample> list;
      if (sampleIndex.containsKey(v0))       list=sampleIndex.get(v0);
 else {
        list=new ArrayList<HalfSample>();
        sampleIndex.put(v0,list);
      }
      list.add(new HalfSample(i,sampleSet.d0s[i]));
      if (sampleSet.v1s[i] != null) {
        int v1=sampleSet.v1s[i].getIndex();
        if (sampleIndex.containsKey(v1))         list=sampleIndex.get(v1);
 else {
          list=new ArrayList<HalfSample>();
          sampleIndex.put(v1,list);
        }
        list.add(new HalfSample(i,sampleSet.d1s[i]));
      }
    }
    TIntList out=new TIntArrayList();
    STOP:     for (    Stop stop : stopForIndex) {
      TransitStop tstop=graph.index.stopVertexForStop.get(stop);
      out.clear();
      int[] distancesForStop=stc.distancesForStop.get(tstop);
      STREET:       for (int i=0; i < distancesForStop.length; i++) {
        int v=distancesForStop[i++];
        int d=distancesForStop[i];
        if (!sampleIndex.containsKey(v))         continue STREET;
        SAMPLE:         for (        HalfSample s : sampleIndex.get(v)) {
          int distance=Math.round(d + s.distance);
          if (distance > stc.maxWalkMeters)           continue;
          out.add(s.index);
          out.add(distance);
        }
      }
      targetsForStop.add(out.toArray());
    }
    nTargets=sampleSet.pset.capacity;
  }
  nStops=stopForIndex.size();
  nPatterns=patternForIndex.size();
}
