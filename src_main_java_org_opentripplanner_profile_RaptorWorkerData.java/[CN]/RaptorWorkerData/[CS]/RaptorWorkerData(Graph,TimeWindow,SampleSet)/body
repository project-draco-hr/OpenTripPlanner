{
  int totalPatterns=graph.index.patternForId.size();
  int totalStops=graph.index.stopForId.size();
  timetablesForPattern=new ArrayList<RaptorWorkerTimetable>(totalPatterns);
  List<TripPattern> patternForIndex=Lists.newArrayList(totalPatterns);
  TObjectIntMap<TripPattern> indexForPattern=new TObjectIntHashMap<>(totalPatterns,0.75f,-1);
  indexForStop=new TObjectIntHashMap<>(totalStops,0.75f,-1);
  List<Stop> stopForIndex=new ArrayList<>(totalStops);
  for (  TripPattern pattern : graph.index.patternForId.values()) {
    RaptorWorkerTimetable timetable=RaptorWorkerTimetable.forPattern(graph,pattern,window);
    if (timetable == null) {
      continue;
    }
    timetablesForPattern.add(timetable);
    indexForPattern.put(pattern,patternForIndex.size());
    patternForIndex.add(pattern);
    patternNames.add(pattern.code);
    TIntList stopIndexesForPattern=new TIntArrayList();
    for (    Stop stop : pattern.getStops()) {
      int stopIndex=indexForStop.get(stop);
      if (stopIndex == -1) {
        stopIndex=indexForStop.size();
        indexForStop.put(stop,stopIndex);
        stopForIndex.add(stop);
        stopNames.add(stop.getName());
      }
      stopIndexesForPattern.add(stopIndex);
    }
    stopsForPattern.add(stopIndexesForPattern.toArray());
  }
  for (  Stop stop : stopForIndex) {
    TIntList patterns=new TIntArrayList();
    for (    TripPattern pattern : graph.index.patternsForStop.get(stop)) {
      int patternIndex=indexForPattern.get(pattern);
      if (patternIndex != -1) {
        patterns.add(patternIndex);
      }
    }
    patternsForStop.add(patterns.toArray());
  }
  for (  Stop stop : stopForIndex) {
    TIntList transfers=new TIntArrayList();
    TransitStop tstop=graph.index.stopVertexForStop.get(stop);
    for (    SimpleTransfer simpleTransfer : Iterables.filter(tstop.getOutgoing(),SimpleTransfer.class)) {
      int targetStopIndex=indexForStop.get(((TransitStop)simpleTransfer.getToVertex()).getStop());
      if (targetStopIndex != -1) {
        transfers.add(targetStopIndex);
        transfers.add((int)(simpleTransfer.getDistance()));
      }
    }
    transfersForStop.add(transfers.toArray());
  }
  StopTreeCache stc=graph.index.getStopTreeCache();
  if (sampleSet == null) {
    for (    Stop stop : stopForIndex) {
      TransitStop tstop=graph.index.stopVertexForStop.get(stop);
      targetsForStop.add(stc.distancesForStop.get(tstop));
    }
    nTargets=Vertex.getMaxIndex();
  }
 else {
    TIntObjectMap<List<HalfSample>> sampleIndex=new TIntObjectHashMap<List<HalfSample>>();
    for (int i=0; i < sampleSet.pset.capacity; i++) {
      if (sampleSet.v0s[i] == null)       continue;
      int v0=sampleSet.v0s[i].getIndex();
      List<HalfSample> list;
      if (sampleIndex.containsKey(v0))       list=sampleIndex.get(v0);
 else {
        list=new ArrayList<HalfSample>();
        sampleIndex.put(v0,list);
      }
      list.add(new HalfSample(i,sampleSet.d0s[i]));
      int v1=sampleSet.v1s[i].getIndex();
      if (sampleIndex.containsKey(v1))       list=sampleIndex.get(v1);
 else {
        list=new ArrayList<HalfSample>();
        sampleIndex.put(v1,list);
      }
      list.add(new HalfSample(i,sampleSet.d1s[i]));
    }
    TIntList out=new TIntArrayList();
    STOP:     for (    Stop stop : stopForIndex) {
      TransitStop tstop=graph.index.stopVertexForStop.get(stop);
      out.clear();
      int[] distancesForStop=stc.distancesForStop.get(tstop);
      STREET:       for (int i=0; i < distancesForStop.length; i++) {
        int v=distancesForStop[i++];
        int d=distancesForStop[i];
        if (!sampleIndex.containsKey(v))         continue STREET;
        SAMPLE:         for (        HalfSample s : sampleIndex.get(v)) {
          out.add(s.index);
          out.add(Math.round(d + s.distance));
        }
      }
      targetsForStop.add(out.toArray());
    }
    nTargets=sampleSet.pset.capacity;
  }
  nStops=stopForIndex.size();
  nPatterns=patternForIndex.size();
}
