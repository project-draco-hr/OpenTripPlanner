{
  CostsAtTime costsAtNextTime=profile.get(originIndex);
  int waitTime=costsAtNextTime.time - timeAtOrigin;
  CostsAtTime toInsert=new CostsAtTime(timeAtOrigin);
  for (  DurationAndDistance atDestination : destinationCosts.costs) {
    double walkDistance=distance + atDestination.distance;
    if (walkDistance > 3218)     continue;
    int walkDuration=duration + atDestination.duration;
    toInsert.forceAdd(walkDuration,walkDistance);
  }
  for (Iterator<DurationAndDistance> costsIt=toInsert.costs.iterator; costsIt.hasNext(); ) {
    DurationAndDistance costs=costsIt.next();
    if (!costsAtNextTime.codominant(costs.duration + waitTime,costs.distance)) {
      costsIt.remove();
    }
  }
  if (toInsert.costs.isEmpty()) {
    return false;
  }
  if (waitTime == 0) {
    costsAtNextTime=profile.get(originIndex);
    for (    DurationAndDistance costs : toInsert.costs) {
      costsAtNextTime.add(costs.duration,costs.distance);
    }
    return true;
  }
 else {
    profile.add(originIndex,toInsert);
    return true;
  }
}
