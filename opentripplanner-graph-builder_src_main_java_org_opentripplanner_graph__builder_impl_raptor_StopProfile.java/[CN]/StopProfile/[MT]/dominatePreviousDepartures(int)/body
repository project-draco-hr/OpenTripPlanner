{
  CostsAtTime inserted=profile.get(originIndex);
  originIndex-=1;
  int timeAtOrigin=inserted.time;
  for (Iterator<DurationAndDistance> costsIt=inserted.costs.iterator(); costsIt.hasNext(); ) {
    DurationAndDistance costs=costsIt.next();
    int index=originIndex;
    BACKWARDSEARCH:     while (index >= 0) {
      boolean shouldContinue=false;
      CostsAtTime costsAtPrevTime=profile.get(index);
      int waitTime=timeAtOrigin - costsAtPrevTime.time;
      int duration=costs.duration + waitTime;
      for (Iterator<DurationAndDistance> it=costsAtPrevTime.costs.iterator(); it.hasNext(); ) {
        DurationAndDistance prevCost=it.next();
        if (prevCost.duration >= duration && prevCost.distance * 1.001 >= costs.distance) {
          it.remove();
          shouldContinue=true;
        }
 else         if (prevCost.duration > duration || prevCost.distance > costs.distance * 1.001) {
          shouldContinue=true;
        }
 else {
          break BACKWARDSEARCH;
        }
      }
      if (costsAtPrevTime.costs.isEmpty()) {
        profile.remove(index);
        originIndex-=1;
      }
      if (shouldContinue) {
        index--;
      }
 else {
        break;
      }
    }
  }
}
