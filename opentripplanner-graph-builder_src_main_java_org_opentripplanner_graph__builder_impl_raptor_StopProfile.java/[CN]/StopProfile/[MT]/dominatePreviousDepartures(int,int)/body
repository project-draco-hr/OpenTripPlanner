{
  CostsAtTime inserted=profile.get(originIndex);
  CostsAtTime costsAtDeparture=new CostsAtTime(inserted.time);
  for (  DurationAndDistance d : inserted.costs) {
    costsAtDeparture.forceAdd(d);
  }
  originIndex-=1;
  int timeAtOrigin=inserted.time;
  int index=originIndex;
  BACKWARDSEARCH:   while (index >= 0) {
    boolean shouldContinue=false;
    CostsAtTime costsAtPrevTime=profile.get(index);
    int waitTime=timeAtOrigin - costsAtPrevTime.time;
    ArrayList<DurationAndDistance> toAdd=new ArrayList<DurationAndDistance>();
    for (Iterator<DurationAndDistance> costsIt=costsAtDeparture.costs.iterator(); costsIt.hasNext(); ) {
      DurationAndDistance costs=costsIt.next();
      int duration=costs.duration + waitTime;
      for (Iterator<DurationAndDistance> it=costsAtPrevTime.costs.iterator(); it.hasNext(); ) {
        DurationAndDistance prevCost=it.next();
        if (prevCost.duration >= duration && prevCost.distance * 1.001 >= costs.distance) {
          toAdd.add(new DurationAndDistance(round,duration,costs.distance));
          it.remove();
          shouldContinue=true;
        }
 else         if (prevCost.duration > duration || prevCost.distance > costs.distance * 1.001) {
          toAdd.add(new DurationAndDistance(round,duration,costs.distance));
          shouldContinue=true;
        }
 else {
          costsIt.remove();
          break BACKWARDSEARCH;
        }
      }
      if (costsAtPrevTime.costs.isEmpty()) {
        profile.remove(index);
      }
 else {
        for (        DurationAndDistance newCosts : toAdd) {
          costsAtPrevTime.forceAdd(newCosts);
        }
      }
      if (shouldContinue) {
        index--;
      }
 else {
        break;
      }
    }
  }
}
