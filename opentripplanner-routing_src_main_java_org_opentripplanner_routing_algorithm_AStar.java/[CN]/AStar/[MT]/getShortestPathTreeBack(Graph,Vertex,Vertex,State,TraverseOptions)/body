{
  if (!options.back) {
    throw new RuntimeException("Reverse paths must set options.back");
  }
  if (origin == null || target == null) {
    return null;
  }
  Vertex tmp=origin;
  origin=target;
  target=tmp;
  Map<Vertex,Edge> extraEdges;
  if (target instanceof StreetLocation) {
    extraEdges=new HashMap<Vertex,Edge>();
    Iterable<Edge> outgoing=target.getOutgoing();
    for (    Edge edge : outgoing) {
      extraEdges.put(edge.getToVertex(),edge);
    }
  }
 else {
    extraEdges=new NullExtraEdges();
  }
  ShortestPathTree spt=new ShortestPathTree();
  double distance=origin.distance(target) / MAX_SPEED;
  SPTVertex spt_origin=spt.addVertex(origin,init,0,options);
  FibHeap pq=new FibHeap(graph.getVertices().size() + extraEdges.size());
  pq.insert(spt_origin,spt_origin.weightSum + distance);
  SPTVertex spt_u, spt_v;
  while (!pq.empty()) {
    spt_u=(SPTVertex)pq.extract_min();
    Vertex tov=spt_u.mirror;
    if (tov == target)     break;
    Iterable<Edge> incoming=tov.getIncoming();
    if (extraEdges.containsKey(tov)) {
      List<Edge> newIncoming=new ArrayList<Edge>();
      for (      Edge edge : tov.getIncoming()) {
        newIncoming.add(edge);
      }
      newIncoming.add(extraEdges.get(tov));
      incoming=newIncoming;
    }
    for (    Edge edge : incoming) {
      TraverseResult wr=edge.traverseBack(spt_u.state,options);
      if (wr == null) {
        continue;
      }
      if (wr.weight < 0) {
        throw new NegativeWeightException(String.valueOf(wr.weight) + " on edge " + edge);
      }
      Vertex fromv=edge.getFromVertex();
      distance=fromv.distance(target) / MAX_SPEED;
      double new_w=spt_u.weightSum + wr.weight;
      spt_v=spt.addVertex(fromv,wr.state,new_w,options);
      if (spt_v != null) {
        spt_v.setParent(spt_u,edge);
        pq.insert_or_dec_key(spt_v,new_w + distance);
      }
    }
  }
  return spt;
}
