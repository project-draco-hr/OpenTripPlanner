{
  if (!options.isArriveBy()) {
    throw new RuntimeException("Reverse paths must call options.setArriveBy(true)");
  }
  if (origin == null || target == null) {
    return null;
  }
  ShortestPathTree spt;
  if (options.modes.getTransit()) {
    spt=new MultiShortestPathTree();
  }
 else {
    spt=new BasicShortestPathTree();
  }
  Vertex tmp=origin;
  origin=target;
  target=tmp;
  options=options.clone();
  options.maxWalkDistance+=origin.getDistanceToNearestTransitStop() + target.getDistanceToNearestTransitStop();
  Map<Vertex,ArrayList<Edge>> extraEdges;
  if (origin instanceof StreetLocation) {
    extraEdges=new HashMap<Vertex,ArrayList<Edge>>();
    Iterable<DirectEdge> extra=((StreetLocation)origin).getExtra();
    for (    DirectEdge edge : extra) {
      Vertex tov=edge.getToVertex();
      ArrayList<Edge> edges=extraEdges.get(tov);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(tov,edges);
      }
      edges.add(edge);
    }
  }
 else {
    extraEdges=new NullExtraEdges();
  }
  if (target instanceof StreetLocation) {
    if (extraEdges instanceof NullExtraEdges) {
      extraEdges=new HashMap<Vertex,ArrayList<Edge>>();
    }
    Iterable<DirectEdge> extra=((StreetLocation)target).getExtra();
    for (    DirectEdge edge : extra) {
      Vertex tov=edge.getToVertex();
      ArrayList<Edge> edges=extraEdges.get(tov);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(tov,edges);
      }
      edges.add(edge);
    }
  }
  final double max_speed=getMaxSpeed(options);
  double distance=origin.distance(target) / max_speed;
  SPTVertex spt_origin=spt.addVertex(origin,init,0,options);
  FibHeap<SPTVertex> pq=new FibHeap<SPTVertex>(graph.getVertices().size() + extraEdges.size());
  pq.insert(spt_origin,spt_origin.weightSum + distance);
  boolean useTransit=options.modes.getTransit();
  HashSet<Vertex> closed=new HashSet<Vertex>(100000);
  SPTVertex spt_u, spt_v;
  while (!pq.empty()) {
    spt_u=pq.extract_min();
    Vertex tov=spt_u.mirror;
    if (tov == target)     break;
    closed.add(tov);
    Collection<Edge> incoming=null;
    if (tov instanceof HasEdges) {
      incoming=extendEdges(incoming,((HasEdges)tov).getOutgoing());
    }
 else {
      GraphVertex gv=graph.getGraphVertex(tov);
      if (gv != null)       incoming=extendEdges(incoming,gv.getIncoming());
    }
    if (extraEdges.containsKey(tov))     incoming=extendEdges(incoming,extraEdges.get(tov));
    if (incoming == null)     incoming=Collections.emptyList();
    for (    Edge edge : incoming) {
      State state=spt_u.state;
      if (edge instanceof DirectEdge && ((DirectEdge)edge).getFromVertex() == target) {
        state=state.clone();
        state.lastEdgeWasStreet=false;
      }
      if (edge instanceof PatternAlight && state.numBoardings > options.maxTransfers) {
        continue;
      }
      TraverseResult wr=edge.traverseBack(state,options);
      while (wr != null) {
        if (wr.weight < 0) {
          throw new NegativeWeightException(String.valueOf(wr.weight) + " on edge " + edge);
        }
        EdgeNarrative er=wr.getEdgeNarrative();
        Vertex fromv=er.getFromVertex();
        double new_w=spt_u.weightSum + wr.weight;
        double euclidianDistance=fromv.distance(target);
        if (useTransit) {
          if (spt_u.state.alightedLocal) {
            distance=options.walkReluctance * euclidianDistance / options.speed;
          }
 else {
            int boardCost;
            if (edge instanceof OnBoardReverseEdge) {
              boardCost=options.boardCost;
            }
 else {
              boardCost=0;
            }
            if (euclidianDistance < target.getDistanceToNearestTransitStop()) {
              distance=options.walkReluctance * euclidianDistance / options.speed;
            }
 else {
              double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + fromv.getDistanceToNearestTransitStop();
              distance=(euclidianDistance - mandatoryWalkDistance) / max_speed + mandatoryWalkDistance * options.walkReluctance / options.speed + boardCost;
              distance=Math.min(distance,options.walkReluctance * euclidianDistance / options.speed);
            }
          }
        }
 else {
          distance=options.walkReluctance * euclidianDistance / max_speed;
        }
        double heuristic_distance=new_w + distance;
        if (heuristic_distance > options.maxWeight || wr.state.getTime() < options.worstTime) {
        }
 else {
          spt_v=spt.addVertex(fromv,wr.state,new_w,options);
          if (spt_v != null) {
            spt_v.setParent(spt_u,edge,er);
            if (!closed.contains(fromv)) {
              pq.insert_or_dec_key(spt_v,heuristic_distance);
            }
          }
        }
        wr=wr.getNextResult();
      }
    }
  }
  return spt;
}
