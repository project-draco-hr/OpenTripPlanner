{
  if (origin == null || target == null) {
    return null;
  }
  ShortestPathTree spt;
  if (options.getModes().getTransit()) {
    spt=new MultiShortestPathTree();
  }
 else {
    spt=new BasicShortestPathTree();
  }
  Map<Vertex,List<Edge>> extraEdges;
  if (origin instanceof StreetLocation) {
    extraEdges=new HashMap<Vertex,List<Edge>>();
    Iterable<DirectEdge> extra=((StreetLocation)origin).getExtra();
    for (    DirectEdge edge : extra) {
      Vertex fromv=edge.getFromVertex();
      List<Edge> edges=extraEdges.get(fromv);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(fromv,edges);
      }
      edges.add(edge);
    }
  }
 else {
    extraEdges=Collections.emptyMap();
  }
  if (target instanceof StreetLocation) {
    if (extraEdges.isEmpty()) {
      extraEdges=new HashMap<Vertex,List<Edge>>();
    }
    Iterable<DirectEdge> extra=((StreetLocation)target).getExtra();
    for (    DirectEdge edge : extra) {
      Vertex fromv=edge.getFromVertex();
      List<Edge> edges=extraEdges.get(fromv);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(fromv,edges);
      }
      edges.add(edge);
    }
  }
  final RemainingWeightHeuristic heuristic=options.remainingWeightHeuristic;
  double initialWeight=heuristic.computeInitialWeight(origin,target,options);
  SPTVertex spt_origin=spt.addVertex(origin,init,0,options);
  FibHeap<SPTVertex> pq=new FibHeap<SPTVertex>(graph.getVertices().size() + extraEdges.size());
  pq.insert(spt_origin,spt_origin.weightSum + initialWeight);
  options=options.clone();
  options.maxWalkDistance+=origin.getDistanceToNearestTransitStop() + target.getDistanceToNearestTransitStop();
  while (!pq.empty()) {
    SPTVertex spt_u=pq.extract_min();
    if (spt_u.state.walkDistance >= options.maxWalkDistance)     continue;
    Vertex fromv=spt_u.mirror;
    if (fromv == target) {
      break;
    }
    Collection<Edge> outgoing=GraphLibrary.getOutgoingEdges(graph,fromv,extraEdges);
    if (fromv instanceof HasEdges) {
      outgoing=extendEdges(outgoing,((HasEdges)fromv).getOutgoing());
    }
 else {
      GraphVertex gv=graph.getGraphVertex(fromv);
      if (gv != null)       outgoing=extendEdges(outgoing,gv.getOutgoing());
    }
    if (extraEdges.containsKey(fromv))     outgoing=extendEdges(outgoing,extraEdges.get(fromv));
    if (fromv instanceof StreetLocation) {
      StreetLocation sl=(StreetLocation)fromv;
      outgoing=extendEdges(outgoing,sl.getExtra());
    }
    if (outgoing == null)     outgoing=Collections.emptyList();
    for (    Edge edge : outgoing) {
      State state=spt_u.state;
      if (edge instanceof PatternBoard && state.numBoardings > options.maxTransfers) {
        continue;
      }
      TraverseResult wr=edge.traverse(state,options);
      while (wr != null) {
        if (wr.weight < 0) {
          throw new NegativeWeightException(String.valueOf(wr.weight));
        }
        EdgeNarrative er=wr.getEdgeNarrative();
        Vertex tov=er.getToVertex();
        double new_w=spt_u.weightSum + wr.weight;
        double remaining_w=heuristic.computeForwardWeight(spt_u,edge,wr,target);
        double heuristic_distance=new_w + remaining_w;
        if (heuristic_distance > options.maxWeight || wr.state.getTime() > options.worstTime) {
        }
 else {
          SPTVertex spt_v=spt.addVertex(tov,wr.state,new_w,options);
          if (spt_v != null) {
            spt_v.setParent(spt_u,edge,er);
            pq.insert_or_dec_key(spt_v,heuristic_distance);
          }
        }
        wr=wr.getNextResult();
      }
    }
  }
  return spt;
}
