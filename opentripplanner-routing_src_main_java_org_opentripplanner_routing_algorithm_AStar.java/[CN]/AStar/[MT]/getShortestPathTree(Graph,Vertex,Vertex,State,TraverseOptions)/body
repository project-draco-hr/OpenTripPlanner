{
  if (origin == null || target == null) {
    return null;
  }
  ShortestPathTree spt;
  if (options.modes.getTransit()) {
    spt=new MultiShortestPathTree();
  }
 else {
    spt=new BasicShortestPathTree();
  }
  Map<Vertex,ArrayList<Edge>> extraEdges;
  if (origin instanceof StreetLocation) {
    extraEdges=new HashMap<Vertex,ArrayList<Edge>>();
    Iterable<Edge> extra=((StreetLocation)origin).getExtra();
    for (    Edge edge : extra) {
      Vertex fromv=edge.getFromVertex();
      ArrayList<Edge> edges=extraEdges.get(fromv);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(fromv,edges);
      }
      edges.add(edge);
    }
  }
 else {
    extraEdges=new NullExtraEdges();
  }
  if (target instanceof StreetLocation) {
    if (extraEdges instanceof NullExtraEdges) {
      extraEdges=new HashMap<Vertex,ArrayList<Edge>>();
    }
    Iterable<Edge> extra=((StreetLocation)target).getExtra();
    for (    Edge edge : extra) {
      Vertex fromv=edge.getFromVertex();
      ArrayList<Edge> edges=extraEdges.get(fromv);
      if (edges == null) {
        edges=new ArrayList<Edge>();
        extraEdges.put(fromv,edges);
      }
      edges.add(edge);
    }
  }
  final double max_speed=getMaxSpeed(options);
  double distance=origin.fastDistance(target) / max_speed;
  SPTVertex spt_origin=spt.addVertex(origin,init,0,options);
  FibHeap<SPTVertex> pq=new FibHeap<SPTVertex>(graph.getVertices().size() + extraEdges.size());
  pq.insert(spt_origin,spt_origin.weightSum + distance);
  boolean useTransit=options.modes.getTransit();
  HashSet<Vertex> closed=new HashSet<Vertex>(100000);
  while (!pq.empty()) {
    SPTVertex spt_u=pq.extract_min();
    Vertex fromv=spt_u.mirror;
    if (fromv == target) {
      break;
    }
    closed.add(fromv);
    GraphVertex gv=graph.getGraphVertex(fromv);
    Collection<Edge> outgoing;
    if (gv == null) {
      outgoing=new ArrayList<Edge>(1);
    }
 else {
      outgoing=gv.getOutgoing();
    }
    if (extraEdges.containsKey(fromv)) {
      List<Edge> newOutgoing=new ArrayList<Edge>();
      for (      Edge edge : outgoing)       newOutgoing.add(edge);
      newOutgoing.addAll(extraEdges.get(fromv));
      outgoing=newOutgoing;
    }
    if (fromv instanceof StreetLocation) {
      StreetLocation sl=(StreetLocation)fromv;
      List<Edge> extra=sl.getExtra();
      if (extra.size() > 0) {
        List<Edge> newOutgoing=new ArrayList<Edge>(outgoing.size() + extra.size());
        for (        Edge edge : outgoing)         newOutgoing.add(edge);
        newOutgoing.addAll(extra);
        outgoing=newOutgoing;
      }
    }
    for (    Edge edge : outgoing) {
      State state=spt_u.state;
      Vertex tov=edge.getToVertex();
      if (tov == target) {
        state=state.clone();
        state.lastEdgeWasStreet=false;
        state.justTransferred=spt_u.state.justTransferred;
      }
 else       if (edge instanceof OutEdge) {
        continue;
      }
      if (edge instanceof PatternBoard && state.numBoardings > options.maxTransfers) {
        continue;
      }
      TraverseResult wr=edge.traverse(state,options);
      if (wr == null) {
        wr=edge.traverse(state,options);
        continue;
      }
      if (wr.weight < 0) {
        throw new NegativeWeightException(String.valueOf(wr.weight));
      }
      double new_w=spt_u.weightSum + wr.weight;
      distance=tov.fastDistance(target) / max_speed;
      if (useTransit) {
        int boardCost;
        if (edge instanceof PatternHop || edge instanceof PatternBoard || edge instanceof PatternDwell|| edge instanceof PatternInterlineDwell|| edge instanceof Board|| edge instanceof Hop) {
          boardCost=0;
        }
 else {
          boardCost=options.boardCost;
        }
        distance=Math.min(distance + boardCost,options.walkReluctance * tov.fastDistance(target) / options.speed);
      }
      double heuristic_distance=new_w + distance;
      if (heuristic_distance > options.maxWeight || wr.state.getTime() > options.worstTime) {
        continue;
      }
      SPTVertex spt_v=spt.addVertex(tov,wr.state,new_w,options);
      if (spt_v != null) {
        spt_v.setParent(spt_u,edge);
        if (!closed.contains(tov)) {
          pq.insert_or_dec_key(spt_v,heuristic_distance);
        }
      }
    }
  }
  return spt;
}
