{
  final double AVG_TRANSIT_SPEED=25;
  double cutoff=(origin.distance(target) * 1.5) / AVG_TRANSIT_SPEED;
  cutoff+=options.getMaxWalkDistance() * options.walkReluctance;
  if (target != this.target || cutoff > this.cutoff) {
    LOG.debug("recalc");
    this.target=target;
    this.cutoff=cutoff;
    this.nVertices=AbstractVertex.getMaxIndex();
    weights=new double[nVertices];
    Arrays.fill(weights,Double.POSITIVE_INFINITY);
    BinHeap<Vertex> q=new BinHeap<Vertex>();
    long t0=System.currentTimeMillis();
    if (target instanceof StreetLocation) {
      for (      Edge de : ((StreetLocation)target).getExtra()) {
        Vertex gv;
        if (options.isArriveBy()) {
          gv=de.getToVertex();
        }
 else {
          gv=de.getFromVertex();
        }
        int gvi=gv.getIndex();
        if (gv == target)         continue;
        if (gvi >= nVertices)         continue;
        weights[gvi]=0;
        q.insert(gv,0);
      }
    }
 else {
      int i=target.getIndex();
      weights[i]=0;
      q.insert(target,0);
    }
    while (!q.empty()) {
      double uw=q.peek_min_key();
      Vertex u=q.extract_min();
      if (uw > cutoff)       break;
      int ui=u.getIndex();
      if (uw > weights[ui])       continue;
      Iterable<Edge> edges;
      if (options.isArriveBy())       edges=u.getOutgoing();
 else       edges=u.getIncoming();
      for (      Edge e : edges) {
        Vertex v=options.isArriveBy() ? e.getToVertex() : e.getFromVertex();
        double ew=timeNotWeight ? e.timeLowerBound(options) : e.weightLowerBound(options);
        if (ew < 0) {
          LOG.error("negative edge weight {} qt {}",ew,e);
          continue;
        }
        double vw=uw + ew;
        int vi=v.getIndex();
        if (weights[vi] > vw) {
          weights[vi]=vw;
          q.insert(v,vw);
        }
      }
    }
    LOG.info("End SSSP ({} msec)",System.currentTimeMillis() - t0);
  }
}
