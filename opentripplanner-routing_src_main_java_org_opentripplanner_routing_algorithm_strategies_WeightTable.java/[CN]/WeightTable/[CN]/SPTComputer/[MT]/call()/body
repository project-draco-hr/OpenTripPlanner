{
  int oi=stopIndices.get(origin);
  BinHeap<State> heap;
  try {
    heap=(BinHeap<State>)heapPool.borrowObject();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  BasicShortestPathTree spt=new BasicShortestPathTree(500000);
  State s0=new State(origin,options);
  spt.add(s0);
  heap.insert(s0,s0.getWeight());
  while (!heap.empty()) {
    double w=heap.peek_min_key();
    State u=heap.extract_min();
    if (!spt.visit(u))     continue;
    Vertex uVertex=u.getVertex();
    if (w > MAX_WEIGHT)     break;
    if (uVertex instanceof TransitStop) {
      int di=stopIndices.get(uVertex);
      table[oi][di]=(float)w;
    }
    for (    Edge e : uVertex.getOutgoing()) {
      if (!(e instanceof PreBoardEdge)) {
        State v=e.optimisticTraverse(u);
        if (v != null && spt.add(v))         heap.insert(v,v.getWeight());
      }
    }
  }
  heap.reset();
  spt=new BasicShortestPathTree(50000);
  Queue<Vertex> q=new ArrayDeque<Vertex>(100);
  q.add(origin);
  while (!q.isEmpty()) {
    Vertex u=q.poll();
    for (    Edge e : u.getOutgoing()) {
      if (e instanceof PatternBoard) {
        Vertex v=((PatternBoard)e).getToVertex();
        stopIndices.put(v,oi);
        StateEditor se=(new State(u,options)).edit(e);
        se.incrementWeight(OPTIMISTIC_BOARD_COST);
        s0=se.makeState();
        spt.add(s0);
        heap.insert(s0,s0.getWeight());
      }
 else       if (e instanceof FreeEdge) {
        Vertex v=((FreeEdge)e).getToVertex();
        stopIndices.put(v,oi);
        q.add(v);
      }
    }
  }
  while (!heap.empty()) {
    double w=heap.peek_min_key();
    State u=heap.extract_min();
    if (!spt.visit(u))     continue;
    Vertex uVertex=u.getVertex();
    if (uVertex instanceof TransitStop) {
      int di=stopIndices.get(uVertex);
      if (table[oi][di] > w) {
        table[oi][di]=(float)w;
      }
      continue;
    }
    for (    Edge e : uVertex.getOutgoing()) {
      State v=e.optimisticTraverse(u);
      if (v != null && spt.add(v))       heap.insert(v,v.getWeight());
    }
  }
  heapPool.returnObject(heap);
  incrementCount();
  return null;
}
