{
  ArrayList<TransitStop> stopVertices;
  LOG.debug("Number of vertices: " + g.getVertices().size());
  stopVertices=new ArrayList<TransitStop>();
  for (  GraphVertex gv : g.getVertices())   if (gv.vertex instanceof TransitStop)   stopVertices.add((TransitStop)gv.vertex);
  int nStops=stopVertices.size();
  stopIndices=new IdentityHashMap<GenericVertex,Integer>(nStops);
  for (int i=0; i < nStops; i++)   stopIndices.put(stopVertices.get(i),i);
  LOG.debug("Number of stops: " + nStops);
  table=new float[nStops][nStops];
  for (  float[] row : table)   Arrays.fill(row,Float.POSITIVE_INFINITY);
  LOG.debug("Performing search at each transit stop.");
  int nThreads=Runtime.getRuntime().availableProcessors();
  LOG.debug("number of threads: " + nThreads);
  ArrayBlockingQueue<Runnable> taskQueue=new ArrayBlockingQueue<Runnable>(nStops);
  ThreadPoolExecutor threadPool=new ThreadPoolExecutor(nThreads,nThreads,10,TimeUnit.SECONDS,taskQueue);
  GenericObjectPool heapPool=new GenericObjectPool(new PoolableBinHeapFactory<State>(g.getVertices().size()),nThreads);
  TraverseOptions options=new TraverseOptions();
  options.speed=maxWalkSpeed;
  final double MAX_WEIGHT=60 * 60 * options.walkReluctance;
  final double OPTIMISTIC_BOARD_COST=options.boardCost;
  ArrayList<Callable<Void>> tasks=new ArrayList<Callable<Void>>();
  for (  TransitStop origin : stopVertices) {
    SPTComputer task=new SPTComputer(heapPool,options,MAX_WEIGHT,OPTIMISTIC_BOARD_COST,origin);
    tasks.add(task);
  }
  try {
    threadPool.invokeAll(tasks);
    threadPool.shutdown();
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  floyd();
}
