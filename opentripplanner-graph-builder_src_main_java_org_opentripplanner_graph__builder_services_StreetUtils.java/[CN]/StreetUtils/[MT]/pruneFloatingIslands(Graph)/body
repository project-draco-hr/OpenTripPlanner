{
  _log.debug("pruning");
  Map<Vertex,HashSet<Vertex>> subgraphs=new HashMap<Vertex,HashSet<Vertex>>();
  Map<Vertex,ArrayList<Vertex>> neighborsForVertex=new HashMap<Vertex,ArrayList<Vertex>>();
  TraverseOptions options=new TraverseOptions(new TraverseModeSet(TraverseMode.WALK));
  for (  Vertex gv : graph.getVertices()) {
    if (!(gv instanceof EndpointVertex)) {
      continue;
    }
    State s0=new State(gv,options);
    for (    Edge e : gv.getOutgoing()) {
      GenericVertex in=(GenericVertex)gv;
      if (!(e instanceof StreetEdge)) {
        continue;
      }
      State s1=e.traverse(s0);
      if (s1 == null) {
        continue;
      }
      GenericVertex out=(GenericVertex)s1.getVertex();
      ArrayList<Vertex> vertexList=neighborsForVertex.get(in);
      if (vertexList == null) {
        vertexList=new ArrayList<Vertex>();
        neighborsForVertex.put(in,vertexList);
      }
      vertexList.add(out);
      vertexList=neighborsForVertex.get(out);
      if (vertexList == null) {
        vertexList=new ArrayList<Vertex>();
        neighborsForVertex.put(out,vertexList);
      }
      vertexList.add(in);
    }
  }
  ArrayList<HashSet<Vertex>> islands=new ArrayList<HashSet<Vertex>>();
  for (  Vertex gv : graph.getVertices()) {
    if (!(gv instanceof EndpointVertex)) {
      continue;
    }
    Vertex vertex=gv;
    if (subgraphs.containsKey(vertex)) {
      continue;
    }
    if (!neighborsForVertex.containsKey(vertex)) {
      continue;
    }
    HashSet<Vertex> subgraph=computeConnectedSubgraph(neighborsForVertex,vertex);
    for (    Vertex subnode : subgraph) {
      subgraphs.put(subnode,subgraph);
    }
    islands.add(subgraph);
  }
  for (  HashSet<Vertex> island : islands) {
    if (island.size() < 20) {
      _log.warn("Depedestrianizing or deleting floating island at " + island.iterator().next());
      for (      Vertex vertex : island) {
        depedestrianizeOrRemove(graph,vertex);
      }
    }
  }
}
