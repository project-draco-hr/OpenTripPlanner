{
  _log.debug("converting to edge-based graph");
  ArrayList<DirectEdge> turns=new ArrayList<DirectEdge>(endpoints.size());
  for (  Vertex v : endpoints) {
    Vertex gv=graph.getVertex(v.getLabel());
    if (gv == null) {
      continue;
    }
    if (gv != v) {
      throw new IllegalStateException("Vertex in graph is not the same one at endpoint.");
    }
    for (    Edge e : gv.getIncoming()) {
      PlainStreetEdge pse=(PlainStreetEdge)e;
      boolean replaced=false;
      StreetVertex v1=getStreetVertexForEdge(graph,pse);
      TurnRestriction restriction=null;
      if (restrictions != null) {
        restriction=restrictions.get(pse);
      }
      for (      Edge e2 : graph.getOutgoing(v)) {
        StreetVertex v2=getStreetVertexForEdge(graph,(PlainStreetEdge)e2);
        TurnEdge turn=new TurnEdge(v1,v2);
        if (restriction != null) {
          if (restriction.type == TurnRestrictionType.NO_TURN && restriction.to == e2) {
            turn.setRestrictedModes(restriction.modes);
          }
 else           if (restriction.type == TurnRestrictionType.ONLY_TURN && restriction.to != e2) {
            turn.setRestrictedModes(restriction.modes);
          }
        }
        if (v1 != v2 && !v1.getEdgeId().equals(v2.getEdgeId())) {
          turns.add(turn);
          replaced=true;
        }
      }
      if (!replaced) {
        pse.setFromVertex(v1);
        turns.add(pse);
      }
    }
  }
  for (  Vertex v : endpoints) {
    graph.removeVertexAndEdges(v);
  }
  for (  DirectEdge e : turns) {
    graph.addEdge(e);
  }
}
