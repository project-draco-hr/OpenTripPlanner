{
  Coordinate c=new Coordinate(lon,lat);
  Envelope env=new Envelope(c);
  double xscale=Math.cos(c.y * Math.PI / 180);
  env.expandBy(searchRadiusLat / xscale,searchRadiusLat);
  @SuppressWarnings("unchecked") Collection<Vertex> vertices=graph.streetIndex.getVerticesForEnvelope(env);
  final TIntDoubleMap distances=new TIntDoubleHashMap();
  for (  Vertex v : vertices) {
    if (!(v instanceof OsmVertex))     continue;
    double dx=(lon - v.getLon()) * xscale;
    double dy=lat - v.getLat();
    distances.put(v.getIndex(),dx * dx + dy * dy);
  }
  Collection<Vertex> osmVertices=Collections2.filter(vertices,new Predicate<Vertex>(){
    @Override public boolean apply(    Vertex input){
      if (!(input instanceof OsmVertex && distances.get(input.getIndex()) < searchRadiusLat * searchRadiusLat))       return false;
      for (      StreetEdge e : Iterables.filter(input.getOutgoing(),StreetEdge.class)) {
        if (e.canTraverse(new TraverseModeSet(TraverseMode.WALK)))         return true;
      }
      return false;
    }
  }
);
  List<Vertex> sorted=new ArrayList<Vertex>(osmVertices);
  Collections.sort(sorted,new Comparator<Vertex>(){
    @Override public int compare(    Vertex o1,    Vertex o2){
      double d1=distances.get(o1.getIndex());
      double d2=distances.get(o2.getIndex());
      if (d1 < d2)       return -1;
 else       if (d1 > d2)       return 1;
 else       return 0;
    }
  }
);
  if (sorted.size() > 2 && distances.get(sorted.get(2).getIndex()) - distances.get(sorted.get(1).getIndex()) < EPSILON) {
    return getSample(lon + 1e-6,lat + 1e-6);
  }
 else   if (sorted.isEmpty()) {
    return null;
  }
 else {
    Vertex v0=sorted.get(0);
    Vertex v1=sorted.size() > 1 ? sorted.get(1) : null;
    double d0=v0 != null ? SphericalDistanceLibrary.distance(v0.getLat(),v0.getLon(),lat,lon) : 0;
    double d1=v1 != null ? SphericalDistanceLibrary.distance(v1.getLat(),v1.getLon(),lat,lon) : 0;
    return new Sample(v0,(int)d0,v1,(int)d1);
  }
}
