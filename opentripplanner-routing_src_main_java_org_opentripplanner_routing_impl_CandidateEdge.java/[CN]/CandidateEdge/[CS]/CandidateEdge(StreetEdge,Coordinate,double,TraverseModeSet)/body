{
  preference=pref;
  platform=calcPlatform(mode);
  edge=e;
  LineString edgeGeom=edge.getGeometry();
  CoordinateSequence coordSeq=edgeGeom.getCoordinateSequence();
  int numCoords=coordSeq.size();
  int bestSeg=0;
  double bestDist2=Double.POSITIVE_INFINITY;
  double bestFrac=0;
  nearestPointOnEdge=new Coordinate();
  double xscale=Math.cos(p.y * Math.PI / 180);
  for (int seg=0; seg < numCoords - 1; seg++) {
    double x0=coordSeq.getX(seg);
    double y0=coordSeq.getY(seg);
    double x1=coordSeq.getX(seg + 1);
    double y1=coordSeq.getY(seg + 1);
    double frac=GeometryUtils.segmentFraction(x0,y0,x1,y1,p.x,p.y,xscale);
    double x=x0 + frac * (x1 - x0);
    double y=y0 + frac * (y1 - y0);
    double dx=(x - p.x) * xscale;
    double dy=y - p.y;
    double dist2=dx * dx + dy * dy;
    if (dist2 < bestDist2) {
      nearestPointOnEdge.x=x;
      nearestPointOnEdge.y=y;
      bestFrac=frac;
      bestSeg=seg;
      bestDist2=dist2;
    }
  }
  distance=Math.sqrt(bestDist2);
  if (bestSeg == 0 && Math.abs(bestFrac) < 0.000001) {
    endwiseVertex=(StreetVertex)edge.getFromVertex();
  }
 else   if (bestSeg == numCoords - 2 && Math.abs(bestFrac - 1.0) < 0.000001) {
    endwiseVertex=(StreetVertex)edge.getToVertex();
  }
 else {
    endwiseVertex=null;
  }
  score=calcScore();
  double xd=nearestPointOnEdge.x - p.x;
  double yd=nearestPointOnEdge.y - p.y;
  directionToEdge=Math.atan2(yd,xd);
  int edgeSegmentIndex=bestSeg;
  Coordinate c0=coordSeq.getCoordinate(edgeSegmentIndex);
  Coordinate c1=coordSeq.getCoordinate(edgeSegmentIndex + 1);
  xd=c1.x - c1.y;
  yd=c1.y - c0.y;
  directionOfEdge=Math.atan2(yd,xd);
  double absDiff=Math.abs(directionToEdge - directionOfEdge);
  directionDifference=Math.min(2 * Math.PI - absDiff,absDiff);
  if (Double.isNaN(directionToEdge) || Double.isNaN(directionOfEdge) || Double.isNaN(directionDifference)) {
    StreetVertexIndexServiceImpl._log.warn("direction to/of edge is NaN (0 length?): {}",edge);
  }
}
