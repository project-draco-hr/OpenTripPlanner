{
  rr=rr.clone();
  rr.setMaxWalkDistance(3000);
  if (fromTarget)   rr.setArriveBy(!rr.isArriveBy());
  List<State> stopStates=Lists.newArrayList();
  ShortestPathTree spt=new BasicShortestPathTree(rr);
  OTPPriorityQueue<State> pq=new BinHeap<State>();
  Vertex initVertex=fromTarget ? rr.rctx.target : rr.rctx.origin;
  State initState=new State(initVertex,rr);
  pq.insert(initState,0);
  while (!pq.empty()) {
    double w=pq.peek_min_key();
    State s=pq.extract_min();
    Vertex v=s.getVertex();
    int vi=v.getIndex();
    if (!fromTarget)     w=0;
    if (weights[vi] > w)     weights[vi]=w;
    if (v instanceof TransitStop) {
      stopStates.add(s);
      continue;
    }
    for (    Edge e : rr.arriveBy ? v.getIncoming() : v.getOutgoing()) {
      State s1=e.traverse(s);
      if (s1 == null)       continue;
      if (spt.add(s1)) {
        pq.insert(s1,s1.getWeight());
      }
    }
  }
  LOG.debug("hit stops: {}",stopStates);
  return stopStates;
}
