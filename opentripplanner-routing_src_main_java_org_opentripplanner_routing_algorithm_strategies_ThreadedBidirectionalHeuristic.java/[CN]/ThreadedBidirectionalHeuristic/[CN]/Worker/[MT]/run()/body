{
  LOG.debug("recalc");
  cutoff=options.maxWeight;
  BinHeap<Vertex> q=new BinHeap<Vertex>();
  long t0=System.currentTimeMillis();
  if (target instanceof StreetLocation) {
    for (    Edge de : ((StreetLocation)target).getExtra()) {
      Vertex gv;
      if (options.isArriveBy()) {
        gv=de.getToVertex();
      }
 else {
        gv=de.getFromVertex();
      }
      int gvi=gv.getIndex();
      if (gv == target)       continue;
      if (gvi >= weights.length)       continue;
      weights[gvi]=0;
      q.insert(gv,0);
    }
  }
 else {
    int i=target.getIndex();
    weights[i]=0;
    q.insert(target,0);
  }
  while (!q.empty()) {
    double uw=q.peek_min_key();
    Vertex u=q.extract_min();
    maxFound=uw;
    if (uw > cutoff)     break;
    if (u == origin) {
      LOG.debug("hit origin.");
    }
    int ui=u.getIndex();
    if (uw > weights[ui])     continue;
    Iterable<Edge> edges;
    if (options.isArriveBy())     edges=u.getOutgoing();
 else     edges=u.getIncoming();
    for (    Edge e : edges) {
      Vertex v=options.isArriveBy() ? e.getToVertex() : e.getFromVertex();
      double ew=e.weightLowerBound(options);
      if (ew < 0) {
        LOG.error("negative edge weight {} qt {}",ew,e);
        continue;
      }
      double vw=uw + ew;
      int vi=v.getIndex();
      if (weights[vi] > vw) {
        weights[vi]=vw;
        q.insert(v,vw);
      }
    }
  }
  LOG.info("End SSSP ({} msec)",System.currentTimeMillis() - t0);
}
