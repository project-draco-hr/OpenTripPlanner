{
  OutputStream out=response.getOutputStream();
  String uri=request.getDecodedRequestURI();
  response.setContentType("application/gzip");
  try {
    String[] coords=uri.split("/")[1].split("[,;]");
    double minLat=Double.parseDouble(coords[0]);
    double minLon=Double.parseDouble(coords[1]);
    double maxLat=Double.parseDouble(coords[2]);
    double maxLon=Double.parseDouble(coords[3]);
    if (minLat >= maxLat || minLon >= maxLon) {
      throw new IllegalArgumentException();
    }
    if (request.getMethod() == Method.HEAD) {
      response.setStatus(HttpStatus.OK_200);
      return;
    }
    boolean buildings=coords.length > 4 && "buildings".equalsIgnoreCase(coords[4]);
    VexPbfParser.WebMercatorTile minTile=new VexPbfParser.WebMercatorTile(minLat,minLon);
    VexPbfParser.WebMercatorTile maxTile=new VexPbfParser.WebMercatorTile(maxLat,maxLon);
    int minX=minTile.xtile;
    int minY=maxTile.ytile;
    int maxX=maxTile.xtile;
    int maxY=minTile.ytile;
    OutputStream zipOut=new GZIPOutputStream(out);
    OSMTextOutput tout=new OSMTextOutput(zipOut,parser.osm);
    for (int x=minX; x <= maxX; x++) {
      SortedSet<Tuple3<Integer,Integer,Long>> xSubset=parser.osm.index.subSet(new Tuple3(x,minY,null),true,new Tuple3(x,maxY,Fun.HI),true);
      for (      Tuple3<Integer,Integer,Long> item : xSubset) {
        long wayId=item.c;
        tout.printWay(wayId);
      }
    }
    zipOut.close();
    response.setStatus(HttpStatus.OK_200);
  }
 catch (  Exception ex) {
    response.setStatus(HttpStatus.BAD_REQUEST_400);
    out.write("URI format: /min_lat,min_lon,max_lat,max_lon (all in decimal degrees)\n".getBytes());
    ex.printStackTrace();
  }
 finally {
    out.close();
  }
}
