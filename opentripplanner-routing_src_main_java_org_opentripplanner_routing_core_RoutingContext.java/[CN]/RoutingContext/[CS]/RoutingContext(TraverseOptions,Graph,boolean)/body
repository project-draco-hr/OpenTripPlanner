{
  opt=traverseOptions;
  opt.rctx=this;
  this.graph=graph;
  fromVertex=graph.streetIndex.getVertexForPlace(opt.getFromPlace(),opt);
  toVertex=graph.streetIndex.getVertexForPlace(opt.getToPlace(),opt,fromVertex);
  origin=opt.arriveBy ? toVertex : fromVertex;
  target=opt.arriveBy ? fromVertex : toVertex;
  checkEndpointVertices();
  findIntermediateVertices();
  CalendarServiceData csData=graph.getService(CalendarServiceData.class);
  if (csData != null) {
    calendarService=new CalendarServiceImpl();
    calendarService.setData(csData);
  }
 else {
    calendarService=null;
  }
  transferTable=graph.getTransferTable();
  if (useServiceDays)   setServiceDays();
  if (opt.batch)   remainingWeightHeuristic=new TrivialRemainingWeightHeuristic();
 else   remainingWeightHeuristic=heuristicFactory.getInstanceForSearch(opt);
  if (opt.getModes().isTransit() && !graph.transitFeedCovers(opt.dateTime)) {
    throw new TransitTimesException();
  }
}
