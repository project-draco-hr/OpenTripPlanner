{
  clearCachedData();
  Collection<Trip> trips=_dao.getAllTrips();
  HashMap<StopPattern,TripPattern> patterns=new HashMap<StopPattern,TripPattern>();
  int index=0;
  HashMap<String,ArrayList<EncodedTrip>> tripsByBlock=new HashMap<String,ArrayList<EncodedTrip>>();
  for (  Trip trip : trips) {
    if (index % 100 == 0)     _log.debug("trips=" + index + "/"+ trips.size());
    index++;
    List<StopTime> stopTimes=_dao.getStopTimesForTrip(trip);
    if (stopTimes.isEmpty())     continue;
    StopPattern stopPattern=stopPatternfromTrip(trip,_dao);
    TripPattern tripPattern=patterns.get(stopPattern);
    int lastStop=stopTimes.size() - 1;
    TraverseMode mode=GtfsLibrary.getTraverseMode(trip.getRoute());
    int departureTime=-1, prevDepartureTime=-1;
    int numInterpStops=-1, firstInterpStop=-1;
    int interpStep=0;
    if (tripPattern == null) {
      tripPattern=new TripPattern(trip,stopTimes);
      int patternIndex=-1;
      for (int i=0; i < lastStop; i++) {
        StopTime st0=stopTimes.get(i);
        Stop s0=st0.getStop();
        StopTime st1=stopTimes.get(i + 1);
        Stop s1=st1.getStop();
        int dwellTime=st0.getDepartureTime() - st0.getArrivalTime();
        Vertex startJourneyDepart=graph.addVertex(id(s0.getId()) + "_" + id(trip.getId())+ "_D",s0.getLon(),s0.getLat());
        Vertex endJourneyArrive=graph.addVertex(id(s1.getId()) + "_" + id(trip.getId())+ "_A",s1.getLon(),s1.getLat());
        Vertex startJourneyArrive;
        if (i != 0) {
          startJourneyArrive=graph.addVertex(id(s0.getId()) + "_" + id(trip.getId())+ "_A",s0.getLon(),s0.getLat());
          PatternDwell dwell=new PatternDwell(startJourneyArrive,startJourneyDepart,i,tripPattern);
          graph.addEdge(dwell);
        }
        PatternHop hop=new PatternHop(startJourneyDepart,endJourneyArrive,s0,s1,i,tripPattern);
        hop.setGeometry(getHopGeometry(trip.getShapeId(),st0,st1,startJourneyDepart,endJourneyArrive));
        prevDepartureTime=departureTime;
        departureTime=st0.getDepartureTime();
        int arrivalTime=st1.getArrivalTime();
        if (arrivalTime == -1 || departureTime == -1) {
          if (numInterpStops == -1) {
            int j;
            for (j=i + 1; j < lastStop + 1; ++j) {
              StopTime st=stopTimes.get(j);
              if (st.getDepartureTime() != -1) {
                break;
              }
            }
            if (j == lastStop + 1) {
              throw new RuntimeException("Could not interpolate arrival/departure time on stop " + i + " on trip "+ trip);
            }
            StopTime st=stopTimes.get(j);
            numInterpStops=j - i - 1;
            firstInterpStop=i + 1;
            interpStep=(st.getArrivalTime() - departureTime) / (numInterpStops + 2);
          }
          if (i >= firstInterpStop) {
            departureTime=prevDepartureTime + interpStep * (i + 1 - firstInterpStop);
          }
          if (i < firstInterpStop + numInterpStops - 1) {
            arrivalTime=departureTime + interpStep;
          }
          if (i == firstInterpStop + numInterpStops - 1) {
            numInterpStops=-1;
          }
        }
        int runningTime=arrivalTime - departureTime;
        patternIndex=tripPattern.addHop(i,0,departureTime,runningTime,arrivalTime,dwellTime);
        graph.addEdge(hop);
        Vertex startStation=graph.getVertex(id(s0.getId()));
        Vertex endStation=graph.getVertex(id(s1.getId()));
        PatternBoard boarding=new PatternBoard(startStation,startJourneyDepart,tripPattern,i,mode);
        graph.addEdge(boarding);
        graph.addEdge(new PatternAlight(endJourneyArrive,endStation,tripPattern,i,mode));
      }
      patterns.put(stopPattern,tripPattern);
      String blockId=trip.getBlockId();
      if (blockId != null && !blockId.equals("")) {
        ArrayList<EncodedTrip> blockTrips=tripsByBlock.get(blockId);
        if (blockTrips == null) {
          blockTrips=new ArrayList<EncodedTrip>();
          tripsByBlock.put(blockId,blockTrips);
        }
        blockTrips.add(new EncodedTrip(trip,patternIndex,tripPattern));
      }
    }
 else {
      int insertionPoint=tripPattern.getDepartureTimeInsertionPoint(stopTimes.get(0).getDepartureTime());
      if (insertionPoint < 0) {
        _log.warn("duplicate first departure time for trip " + trip.getId() + ".  This will be handled correctly but inefficiently.");
        createSimpleHops(graph,trip,stopTimes);
      }
 else {
        boolean simple=false;
        for (int i=0; i < lastStop; i++) {
          StopTime st0=stopTimes.get(i);
          StopTime st1=stopTimes.get(i + 1);
          int dwellTime=st0.getDepartureTime() - st0.getArrivalTime();
          int runningTime=st1.getArrivalTime() - st0.getDepartureTime();
          try {
            tripPattern.addHop(i,insertionPoint,st0.getDepartureTime(),runningTime,st1.getArrivalTime(),dwellTime);
          }
 catch (          TripOvertakingException e) {
            _log.warn("trip " + trip.getId() + " overtakes another trip with the same stops.  This will be handled correctly but inefficiently.");
            for (i=i - 1; i >= 0; --i) {
              tripPattern.removeHop(i,insertionPoint);
            }
            createSimpleHops(graph,trip,stopTimes);
            simple=true;
            break;
          }
        }
        if (!simple) {
          String blockId=trip.getBlockId();
          if (blockId != null && !blockId.equals("")) {
            ArrayList<EncodedTrip> blockTrips=tripsByBlock.get(blockId);
            if (blockTrips == null) {
              blockTrips=new ArrayList<EncodedTrip>();
              tripsByBlock.put(blockId,blockTrips);
            }
            blockTrips.add(new EncodedTrip(trip,0,tripPattern));
          }
        }
      }
    }
  }
  for (  ArrayList<EncodedTrip> blockTrips : tripsByBlock.values()) {
    HashMap<Stop,EncodedTrip> starts=new HashMap<Stop,EncodedTrip>();
    for (    EncodedTrip encoded : blockTrips) {
      Trip trip=encoded.trip;
      List<StopTime> stopTimes=_dao.getStopTimesForTrip(trip);
      Stop start=stopTimes.get(0).getStop();
      starts.put(start,encoded);
    }
    for (    EncodedTrip encoded : blockTrips) {
      Trip trip=encoded.trip;
      List<StopTime> stopTimes=_dao.getStopTimesForTrip(trip);
      StopTime endTime=stopTimes.get(stopTimes.size() - 1);
      Stop end=endTime.getStop();
      if (starts.containsKey(end)) {
        EncodedTrip nextTrip=starts.get(end);
        Vertex arrive=graph.addVertex(id(end.getId()) + "_" + id(trip.getId())+ "_A",end.getLon(),end.getLat());
        Vertex depart=graph.addVertex(id(end.getId()) + "_" + id(nextTrip.trip.getId())+ "_D",end.getLon(),end.getLat());
        PatternDwell dwell=new PatternDwell(arrive,depart,nextTrip.patternIndex,encoded.pattern);
        graph.addEdge(dwell);
        List<StopTime> nextStopTimes=_dao.getStopTimesForTrip(nextTrip.trip);
        StopTime startTime=nextStopTimes.get(0);
        int dwellTime=startTime.getDepartureTime() - startTime.getArrivalTime();
        encoded.pattern.setDwellTime(stopTimes.size() - 2,encoded.patternIndex,dwellTime);
      }
    }
  }
  loadTransfers(graph);
  clearCachedData();
}
