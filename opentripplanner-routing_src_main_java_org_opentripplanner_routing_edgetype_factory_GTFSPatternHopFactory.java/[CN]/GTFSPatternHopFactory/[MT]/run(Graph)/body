{
  clearCachedData();
  Collection<Trip> trips=_dao.getAllTrips();
  HashMap<StopPattern2,TripPattern> patterns=new HashMap<StopPattern2,TripPattern>();
  int index=0;
  for (  Trip trip : trips) {
    if (index % 100 == 0)     _log.debug("trips=" + index + "/"+ trips.size());
    index++;
    List<StopTime> stopTimes=_dao.getStopTimesForTrip(trip);
    if (stopTimes.isEmpty())     continue;
    StopPattern2 stopPattern=stopPatternfromTrip(trip,_dao);
    TripPattern tripPattern=patterns.get(stopPattern);
    int lastStop=stopTimes.size() - 1;
    if (tripPattern == null) {
      tripPattern=new TripPattern(trip,stopTimes);
      for (int i=0; i < lastStop; i++) {
        StopTime st0=stopTimes.get(i);
        Stop s0=st0.getStop();
        StopTime st1=stopTimes.get(i + 1);
        Stop s1=st1.getStop();
        int dwellTime=st0.getDepartureTime() - st0.getArrivalTime();
        int runningTime=st1.getArrivalTime() - st0.getDepartureTime();
        Vertex startJourneyDepart=graph.addVertex(id(s0.getId()) + "_" + id(trip.getId())+ "_D",s0.getLon(),s0.getLat());
        Vertex endJourneyArrive=graph.addVertex(id(s1.getId()) + "_" + id(trip.getId())+ "_A",s1.getLon(),s1.getLat());
        Vertex startJourneyArrive;
        if (i != 0) {
          startJourneyArrive=graph.addVertex(id(s0.getId()) + "_" + id(trip.getId())+ "_A",s0.getLon(),s0.getLat());
          PatternDwell dwell=new PatternDwell(startJourneyArrive,startJourneyDepart,i,tripPattern);
          graph.addEdge(dwell);
        }
        PatternHop hop=new PatternHop(startJourneyDepart,endJourneyArrive,s0,s1,i,tripPattern);
        hop.setGeometry(getHopGeometry(trip.getShapeId(),st0,st1,startJourneyDepart,endJourneyArrive));
        tripPattern.addHop(i,0,st0.getDepartureTime(),runningTime,st0.getArrivalTime(),dwellTime);
        graph.addEdge(hop);
        Vertex startStation=graph.getVertex(id(s0.getId()));
        Vertex endStation=graph.getVertex(id(s1.getId()));
        PatternBoard boarding=new PatternBoard(startStation,startJourneyDepart,tripPattern,i);
        graph.addEdge(boarding);
        graph.addEdge(new PatternAlight(endJourneyArrive,endStation,tripPattern,i + 1));
      }
      patterns.put(stopPattern,tripPattern);
    }
 else {
      int insertionPoint=tripPattern.getDepartureTimeInsertionPoint(stopTimes.get(0).getDepartureTime());
      if (insertionPoint < 0) {
        _log.warn("duplicate first departure time for trip " + trip.getId() + ".  This will be handled correctly but inefficiently.");
        createSimpleHops(graph,trip,stopTimes);
      }
 else {
        for (int i=0; i < lastStop; i++) {
          StopTime st0=stopTimes.get(i);
          StopTime st1=stopTimes.get(i + 1);
          int dwellTime=st0.getDepartureTime() - st0.getArrivalTime();
          int runningTime=st1.getArrivalTime() - st0.getDepartureTime();
          try {
            tripPattern.addHop(i,insertionPoint,st0.getDepartureTime(),runningTime,st0.getArrivalTime(),dwellTime);
          }
 catch (          TripOvertakingException e) {
            _log.warn("trip " + trip.getId() + "overtakes another trip with the same stops.  This will be handled correctly but inefficiently.");
            for (; i >= 0; --i) {
              tripPattern.removeHop(i,insertionPoint);
            }
            createSimpleHops(graph,trip,stopTimes);
            break;
          }
        }
      }
    }
  }
  loadTransfers(graph);
  clearCachedData();
}
