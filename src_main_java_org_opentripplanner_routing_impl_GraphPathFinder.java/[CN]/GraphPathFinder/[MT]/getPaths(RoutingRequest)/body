{
  if (options == null) {
    LOG.error("PathService was passed a null routing request.");
    return null;
  }
  SPTService sptService=new GenericAStar();
  if (options.rctx == null) {
    options.setRoutingContext(graph);
    options.rctx.pathParsers=new PathParser[]{new Parser()};
  }
  LOG.debug("rreq={}",options);
  RemainingWeightHeuristic heuristic;
  if (options.disableRemainingWeightHeuristic) {
    heuristic=new TrivialRemainingWeightHeuristic();
  }
 else   if (options.modes.isTransit()) {
    heuristic=new InterleavedBidirectionalHeuristic(options.rctx.graph);
  }
 else {
    heuristic=new EuclideanRemainingWeightHeuristic();
  }
  options.rctx.remainingWeightHeuristic=heuristic;
  options.setMaxTransfers(4);
  options.longDistance=true;
  if (options.maxWalkDistance == Double.MAX_VALUE)   options.maxWalkDistance=DEFAULT_MAX_WALK;
  if (options.maxWalkDistance > CLAMP_MAX_WALK)   options.maxWalkDistance=CLAMP_MAX_WALK;
  long searchBeginTime=System.currentTimeMillis();
  LOG.debug("BEGIN SEARCH");
  List<GraphPath> paths=Lists.newArrayList();
  Set<AgencyAndId> bannedTrips=Sets.newHashSet();
  while (paths.size() < options.numItineraries && paths.size() < timeouts.length) {
    double timeout=searchBeginTime + (timeouts[paths.size()] * 1000) - System.currentTimeMillis();
    ShortestPathTree spt=sptService.getShortestPathTree(options,timeout);
    if (spt == null) {
      LOG.warn("SPT was null.");
      return null;
    }
    if (options.rctx.aborted)     break;
    List<GraphPath> newPaths=spt.getPaths();
    if (newPaths.isEmpty())     break;
    for (    GraphPath path : newPaths) {
      for (      State state : path.states) {
        AgencyAndId tripId=state.getTripId();
        if (tripId != null)         options.banTrip(tripId);
      }
    }
    paths.addAll(newPaths);
    LOG.debug("we have {} paths",paths.size());
  }
  LOG.debug("END SEARCH ({} msec)",System.currentTimeMillis() - searchBeginTime);
  Collections.sort(paths,new PathWeightComparator());
  return paths;
}
