{
  MultiCalendarServiceImpl service=new MultiCalendarServiceImpl();
  GtfsStopContext stopContext=new GtfsStopContext();
  try {
    int bundleIndex=0;
    for (    GtfsBundle gtfsBundle : _gtfsBundles.getBundles()) {
      bundleIndex+=1;
      GtfsMutableRelationalDao dao=new GtfsRelationalDaoImpl();
      GtfsContext context=GtfsLibrary.createContext(dao,service);
      GTFSPatternHopFactory hf=new GTFSPatternHopFactory(context);
      hf.setStopContext(stopContext);
      hf.setFareServiceFactory(_fareServiceFactory);
      if (generateFeedIds && gtfsBundle.getDefaultAgencyId() == null) {
        gtfsBundle.setDefaultAgencyId("FEED#" + bundleIndex);
      }
      loadBundle(gtfsBundle,graph,dao);
      CalendarServiceDataFactoryImpl csfactory=new CalendarServiceDataFactoryImpl();
      csfactory.setGtfsDao(dao);
      CalendarServiceData data=csfactory.createData();
      service.addData(data,dao);
      hf.setDefaultStreetToStopTime(gtfsBundle.getDefaultStreetToStopTime());
      hf.run(graph);
      if (gtfsBundle.doesTransfersTxtDefineStationPaths()) {
        hf.createStationTransfers(graph);
      }
      if (gtfsGraphBuilders != null) {
        for (        GraphBuilderWithGtfsDao builder : gtfsGraphBuilders) {
          builder.setDao(dao);
          builder.buildGraph(graph);
          builder.setDao(null);
        }
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  CalendarServiceData data=service.getData();
  graph.putService(CalendarServiceData.class,data);
  graph.updateTransitFeedValidity(data);
}
