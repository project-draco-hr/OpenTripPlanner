{
  HashMap<Vertex,Double> distances=new HashMap<Vertex,Double>();
  BinHeap<Vertex> queue=new BinHeap<Vertex>();
  for (  Vertex v : region) {
    queue.insert(v,0);
    distances.put(v,0.0);
  }
  HashSet<Vertex> closed=new HashSet<Vertex>();
  while (!queue.empty()) {
    Vertex u=queue.extract_min();
    if (closed.contains(u))     continue;
    closed.add(u);
    double distance=distances.get(u);
    for (    Edge e : u.getOutgoing()) {
      if (!((e instanceof StreetEdge) || (e instanceof StreetTransitLink)))       continue;
      double edgeDistance=e.getDistance() + distance;
      Vertex v=e.getToVertex();
      Double originalDistance=distances.get(v);
      if (originalDistance == null || originalDistance > edgeDistance) {
        distances.put(v,edgeDistance);
        queue.insert(v,edgeDistance);
      }
      if (v instanceof TransitStop) {
        RaptorStop stop=data.raptorStopsForStopId.get(((TransitStop)v).getStopId());
        if (stop == null)         continue;
        for (        RaptorRoute route : data.routesForStop[stop.index]) {
          for (          RaptorStop stopOnRoute : route.stops) {
            Vertex stopVertex=stopOnRoute.stopVertex;
            originalDistance=distances.get(stopVertex);
            if (originalDistance == null || originalDistance > edgeDistance) {
              distances.put(stopVertex,edgeDistance);
              queue.insert(stopVertex,edgeDistance);
            }
          }
        }
      }
    }
  }
  final double[] minWalk=regions.minWalk[regionIndex];
  Arrays.fill(minWalk,Double.MAX_VALUE);
  for (  Map.Entry<Vertex,Double> entry : distances.entrySet()) {
    Vertex v=entry.getKey();
    double distance=entry.getValue();
    int toRegion=v.getGroupIndex();
    if (toRegion == -1) {
      System.out.println("Warning: no region for " + v);
      continue;
    }
    if (minWalk[toRegion] > distance) {
      minWalk[toRegion]=distance;
    }
  }
}
