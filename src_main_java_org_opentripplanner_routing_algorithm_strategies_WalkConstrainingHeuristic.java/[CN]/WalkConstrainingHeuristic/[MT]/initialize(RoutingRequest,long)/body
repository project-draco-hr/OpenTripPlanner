{
  Vertex target=options.rctx.target;
  if (target == this.target) {
    LOG.debug("Reusing existing heuristic, the target vertex has not changed.");
    return;
  }
  this.graph=options.rctx.graph;
  long start=System.currentTimeMillis();
  this.target=target;
  this.options=options;
  options.softWalkLimiting=false;
  options.softPreTransitLimiting=false;
  LOG.debug("initializing heuristic computation thread");
  streetVerticesNearOrigin=streetSearch(options,false,abortTime);
  if (streetVerticesNearOrigin == null) {
    return;
  }
  LOG.debug("end forward street search {} ms",System.currentTimeMillis() - start);
  streetVerticesNearDestination=streetSearch(options,true,abortTime);
  if (streetVerticesNearDestination == null) {
    return;
  }
  LOG.debug("end backward street search {} ms",System.currentTimeMillis() - start);
  options.setMaxWalkDistance(Double.POSITIVE_INFINITY);
  options.setMaxPreTransitTime(Integer.MAX_VALUE);
  LOG.debug("initialized SSSP");
  options.rctx.debugOutput.finishedPrecalculating();
}
