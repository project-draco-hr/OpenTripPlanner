{
  if (!options.hasIntermediatePlaces()) {
    LOG.debug("No intermediates places given, calling underlying path service.");
    return chainedPathService.getPaths(options);
  }
  Graph graph=graphService.getGraph(options.routerId);
  long time=options.dateTime;
  options.setRoutingContext(graph);
  options.rctx.pathParsers=new PathParser[]{new BasicPathParser(),new NoThruTrafficPathParser()};
  Vertex fromVertex=options.rctx.fromVertex;
  Vertex toVertex=options.rctx.toVertex;
  if (options.intermediatesEffectivelyOrdered()) {
    LOG.debug("Intermediates are ordered.");
    List<Vertex> vertices=options.rctx.intermediateVertices;
    vertices.add(toVertex);
    options.clearIntermediatePlaces();
    List<GraphPath> paths=new ArrayList<GraphPath>();
    Vertex previousVertex=fromVertex;
    for (    Vertex v : vertices) {
      options.dateTime=time;
      options.setRoutingContext(graph,previousVertex,v);
      List<GraphPath> partialPaths=chainedPathService.getPaths(options);
      if (partialPaths == null || partialPaths.size() == 0)       return null;
      GraphPath path=partialPaths.get(0);
      paths.add(path);
      previousVertex=v;
      time=path.getEndTime();
    }
    return Arrays.asList(joinPaths(paths));
  }
  LOG.debug("Intermediates are not ordered: attempting to optimize ordering.");
  Map<Vertex,HashMap<Vertex,GraphPath>> paths=new HashMap<Vertex,HashMap<Vertex,GraphPath>>();
  HashMap<Vertex,GraphPath> firstLegPaths=new HashMap<Vertex,GraphPath>();
  paths.put(fromVertex,firstLegPaths);
  @SuppressWarnings("unchecked") List<Vertex> intermediates=(List<Vertex>)options.rctx.intermediateVertices.clone();
  for (  Vertex v : intermediates) {
    options.dateTime=time;
    options.setRoutingContext(graph,fromVertex,v);
    List<GraphPath> partialPaths=chainedPathService.getPaths(options);
    if (partialPaths == null || partialPaths.size() == 0)     return null;
    firstLegPaths.put(v,partialPaths.get(0));
    HashMap<Vertex,GraphPath> outPaths=new HashMap<Vertex,GraphPath>();
    paths.put(v,outPaths);
    for (    Vertex tv : intermediates) {
      if (v == tv)       continue;
      options.setRoutingContext(graph,v,tv);
      List<GraphPath> morePaths=chainedPathService.getPaths(options);
      if (!morePaths.isEmpty()) {
        outPaths.put(tv,morePaths.get(0));
      }
    }
    options.setRoutingContext(graph,v,toVertex);
    List<GraphPath> lastPaths=chainedPathService.getPaths(options);
    if (!lastPaths.isEmpty())     outPaths.put(toVertex,lastPaths.get(0));
  }
  HashSet<Vertex> verticesCopy=new HashSet<Vertex>();
  verticesCopy.addAll(intermediates);
  return Arrays.asList(TSPPathFinder.findShortestPath(toVertex,fromVertex,paths,verticesCopy,time,options));
}
