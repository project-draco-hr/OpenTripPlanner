{
  double weight;
  if (options.wheelchairAccessible) {
    weight=slopeSpeedEffectiveLength / options.speed;
  }
 else   if (options.getModes().contains(TraverseMode.BICYCLE)) {
switch (options.optimizeFor) {
case SAFE:
      weight=bicycleSafetyEffectiveLength / options.speed;
    break;
case GREENWAYS:
  weight=bicycleSafetyEffectiveLength / options.speed;
if (bicycleSafetyEffectiveLength / length <= GREENWAY_SAFETY_FACTOR) {
  weight*=0.66;
}
break;
case FLAT:
double speedOverhead=SPEED_OVERHEAD * WORK_NORMALIZATION_FACTOR * length* (options.speed - DEFAULT_BICYCLE_SPEED);
weight=length / options.speed + slopeWorkCost + speedOverhead;
break;
case QUICK:
weight=slopeSpeedEffectiveLength / options.speed;
break;
case TRIANGLE:
double quick=slopeSpeedEffectiveLength / options.speed;
double safety=bicycleSafetyEffectiveLength / options.speed;
speedOverhead=SPEED_OVERHEAD * WORK_NORMALIZATION_FACTOR * length* (options.speed - DEFAULT_BICYCLE_SPEED);
double slope=slopeWorkCost + speedOverhead;
weight=quick * options.triangleTimeFactor + slope * options.triangleSlopeFactor + safety * options.triangleSafetyFactor;
default :
weight=length / options.speed;
}
}
 else {
weight=time;
}
weight*=options.walkReluctance;
return weight;
}
