{
  MultiCalendarServiceImpl service=new MultiCalendarServiceImpl();
  GtfsStopContext stopContext=new GtfsStopContext();
  try {
    int bundleIndex=0;
    for (    GtfsBundle gtfsBundle : _gtfsBundles.getBundles()) {
      bundleIndex+=1;
      if (cacheDirectory != null && gtfsBundle.getCacheDirectory() == null)       gtfsBundle.setCacheDirectory(cacheDirectory);
      if (useCached != null && gtfsBundle.getUseCached() == null)       gtfsBundle.setUseCached(useCached);
      GtfsMutableRelationalDao dao=new GtfsRelationalDaoImpl();
      GtfsContext context=GtfsLibrary.createContext(dao,service);
      GTFSPatternHopFactory hf=new GTFSPatternHopFactory(context);
      hf.setStopContext(stopContext);
      hf.setFareServiceFactory(_fareServiceFactory);
      hf.setMaxStopToShapeSnapDistance(gtfsBundle.getMaxStopToShapeSnapDistance());
      hf.setDeleteUselessDwells(deleteUselessDwells);
      loadBundle(gtfsBundle,graph,dao);
      CalendarServiceDataFactoryImpl csfactory=new CalendarServiceDataFactoryImpl();
      csfactory.setGtfsDao(dao);
      CalendarServiceData data=csfactory.createData();
      service.addData(data,dao);
      hf.setDefaultStreetToStopTime(gtfsBundle.getDefaultStreetToStopTime());
      hf.run(graph);
      if (gtfsBundle.doesTransfersTxtDefineStationPaths()) {
        hf.createTransfersTxtTransfers();
      }
      if (gtfsBundle.isLinkStopsToParentStations()) {
        hf.linkStopsToParentStations(graph);
      }
      if (gtfsBundle.isParentStationTransfers()) {
        hf.createParentStationTransfers();
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  CalendarServiceData data=service.getData();
  graph.putService(CalendarServiceData.class,data);
  graph.updateTransitFeedValidity(data);
}
