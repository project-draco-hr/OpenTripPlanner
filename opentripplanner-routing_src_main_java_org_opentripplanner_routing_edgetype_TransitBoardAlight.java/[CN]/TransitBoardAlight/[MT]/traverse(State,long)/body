{
  RoutingContext rctx=state0.getContext();
  RoutingRequest options=state0.getOptions();
  TraverseMode mode=state0.getNonTransitMode(options);
  boolean offTransit=!((boarding || options.isArriveBy()) && !(boarding && options.isArriveBy()));
  if (offTransit) {
    int type;
    if (state0.getBackEdge() instanceof TransitBoardAlight) {
      return null;
    }
    EdgeNarrative en=new TransitNarrative(state0.getTripTimes().trip,this);
    StateEditor s1=state0.edit(this,en);
    if (boarding)     type=getPattern().getBoardType(stopIndex);
 else     type=getPattern().getAlightType(stopIndex);
    if (TransitUtils.handleBoardAlightType(s1,type)) {
      return null;
    }
    s1.setTripId(null);
    s1.setLastAlightedTime(state0.getTime());
    s1.setPreviousStop(fromv);
    s1.setLastPattern(this.getPattern());
    if (arrivalTimeAtStop > 0) {
      int wait=(int)Math.abs(state0.getTime() - arrivalTimeAtStop);
      s1.incrementTimeInSeconds(wait);
      s1.incrementWeight(wait * options.waitAtBeginningFactor);
      s1.setInitialWaitTime(wait);
    }
    if (options.isReverseOptimizing())     s1.incrementWeight(options.getBoardCost(mode));
    if (options.isReverseOptimizeOnTheFly()) {
      int thisDeparture=state0.getTripTimes().getDepartureTime(stopIndex);
      int numTrips=getPattern().getNumTrips();
      int nextDeparture;
      s1.setLastNextArrivalDelta(Integer.MAX_VALUE);
      for (int tripIndex=0; tripIndex < numTrips; tripIndex++) {
        nextDeparture=getPattern().getDepartureTime(stopIndex,tripIndex);
        if (nextDeparture > thisDeparture) {
          s1.setLastNextArrivalDelta(nextDeparture - thisDeparture);
          break;
        }
      }
    }
    return s1.makeState();
  }
 else {
    int wait, type;
    TripTimes tripTimes;
    if (state0.getLastPattern() == this.getPattern()) {
      return null;
    }
    if (!options.getModes().get(modeMask)) {
      return null;
    }
    long current_time=state0.getTime();
    int bestWait=-1;
    TripTimes bestTripTimes=null;
    int serviceId=getPattern().getServiceId();
    for (    ServiceDay sd : rctx.serviceDays) {
      int secondsSinceMidnight=sd.secondsSinceMidnight(current_time);
      if (sd.serviceIdRunning(serviceId)) {
        if (boarding)         tripTimes=getPattern().getNextTrip(stopIndex,secondsSinceMidnight,mode == TraverseMode.BICYCLE,options);
 else         tripTimes=getPattern().getPreviousTrip(stopIndex,secondsSinceMidnight,mode == TraverseMode.BICYCLE,options);
        if (tripTimes != null) {
          if (boarding)           wait=(int)(sd.time(tripTimes.getDepartureTime(stopIndex)) - current_time);
 else           wait=(int)(current_time - sd.time(tripTimes.getArrivalTime(stopIndex)));
          if (wait < 0)           _log.error("negative wait time on board");
          if (bestWait < 0 || wait < bestWait) {
            bestWait=wait;
            bestTripTimes=tripTimes;
          }
        }
      }
    }
    if (bestWait < 0) {
      return null;
    }
    Trip trip=bestTripTimes.getTrip();
    if (options.bannedRoutes != null) {
      Route route=trip.getRoute();
      RouteSpec spec=new RouteSpec(route.getId().getAgencyId(),GtfsLibrary.getRouteName(route));
      if (options.bannedRoutes.contains(spec)) {
        return null;
      }
    }
    long preferences_penalty=0;
    if (options.preferredRoutes != null && options.preferredRoutes.size() > 0) {
      Route route=trip.getRoute();
      RouteSpec spec=new RouteSpec(route.getId().getAgencyId(),GtfsLibrary.getRouteName(route));
      if (!options.preferredRoutes.contains(spec)) {
        preferences_penalty+=options.useAnotherThanPreferredRoutesPenalty;
      }
    }
    if (options.unpreferredRoutes != null && options.unpreferredRoutes.size() > 0) {
      Route route=trip.getRoute();
      RouteSpec spec=new RouteSpec(route.getId().getAgencyId(),GtfsLibrary.getRouteName(route));
      if (options.unpreferredRoutes.contains(spec)) {
        preferences_penalty+=options.useUnpreferredRoutesPenalty;
      }
    }
    EdgeNarrative en=new TransitNarrative(trip,this);
    StateEditor s1=state0.edit(this,en);
    if (boarding)     type=getPattern().getBoardType(stopIndex);
 else     type=getPattern().getAlightType(stopIndex);
    if (TransitUtils.handleBoardAlightType(s1,type)) {
      return null;
    }
    s1.setTripTimes(bestTripTimes);
    s1.incrementTimeInSeconds(bestWait);
    s1.incrementNumBoardings();
    s1.setTripId(trip.getId());
    s1.setZone(getPattern().getZone(stopIndex));
    s1.setRoute(trip.getRoute().getId());
    double wait_cost=bestWait;
    if (state0.getNumBoardings() == 0 && !options.isReverseOptimizing()) {
      wait_cost*=options.waitAtBeginningFactor;
      s1.setInitialWaitTime(bestWait);
    }
 else {
      wait_cost*=options.waitReluctance;
    }
    s1.incrementWeight(preferences_penalty);
    if (options.isReverseOptimizing())     s1.incrementWeight(wait_cost);
 else     s1.incrementWeight(wait_cost + options.getBoardCost(mode));
    if (options.isReverseOptimizeOnTheFly() && !options.isReverseOptimizing() && state0.getNumBoardings() > 0 && state0.getLastNextArrivalDelta() <= bestWait && state0.getLastNextArrivalDelta() > -1) {
      State optimized=s1.makeState().optimizeOrReverse(true,true);
      if (optimized == null)       _log.error("Null optimized state. This shouldn't happen");
      return optimized;
    }
    return s1.makeState();
  }
}
