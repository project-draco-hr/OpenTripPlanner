{
  TraverseOptions options=new TraverseOptions(new TraverseModeSet(TraverseMode.WALK));
  options.setMaxWalkDistance(Double.MAX_VALUE);
  options.walkReluctance=1.0;
  options.setWalkSpeed(1.0);
  State u, v;
  HashSet<Vertex> closed=new HashSet<Vertex>();
  BinHeap<State> queue=new BinHeap<State>(50);
  BasicShortestPathTree spt=new BasicShortestPathTree();
  State init=new State(origin,options);
  spt.add(init);
  queue.insert(init,init.getWeight());
  while (!queue.empty()) {
    u=queue.extract_min();
    Vertex fromv=u.getVertex();
    closed.add(fromv);
    Iterable<Edge> outgoing=fromv.getOutgoing();
    for (    Edge edge : outgoing) {
      v=edge.traverse(u);
      if (v == null)       continue;
      double dw=v.getWeight() - u.getWeight();
      if (dw < 0) {
        throw new NegativeWeightException(String.valueOf(dw));
      }
      Vertex toVertex=v.getVertex();
      if (closed.contains(toVertex)) {
        continue;
      }
      double new_w=v.getWeight();
      if (toVertex instanceof TurnVertex) {
        TurnVertex sv=(TurnVertex)toVertex;
        if (sv.getDistanceToNearestTransitStop() <= new_w) {
          continue;
        }
        sv.setDistanceToNearestTransitStop(new_w);
      }
      if (spt.add(v))       queue.insert(v,new_w);
    }
  }
}
