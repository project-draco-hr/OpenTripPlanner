{
  HashSet<Edge> turns=new HashSet<Edge>();
  turns.add(left);
  turns.add(leftBack);
  Alert alert=Alert.createSimpleAlerts("This is the alert");
  Set<Alert> alerts=new HashSet<>();
  alerts.add(alert);
  graph.streetNotesService.addNote(left,alert);
  graph.streetNotesService.addNote(leftBack,alert);
  StreetLocation start=StreetLocation.createStreetLocation(graph,"start","start",filter(turns,StreetEdge.class),new LinearLocation(0,0.4).getCoordinate(left.getGeometry()));
  RoutingRequest req=new RoutingRequest();
  req.setMaxWalkDistance(Double.MAX_VALUE);
  State traversedOne=new State((Vertex)start,req);
  State currentState;
  for (  Edge e : start.getOutgoing()) {
    currentState=e.traverse(traversedOne);
    if (currentState != null) {
      traversedOne=currentState;
      break;
    }
  }
  assertEquals(alerts,graph.streetNotesService.getNotes(traversedOne));
  assertNotSame(left,traversedOne.getBackEdge().getFromVertex());
  assertNotSame(leftBack,traversedOne.getBackEdge().getFromVertex());
  Alert wheelchairAlert=Alert.createSimpleAlerts("This is the wheelchair alert");
  Set<Alert> wheelchairAlerts=new HashSet<>();
  wheelchairAlerts.add(wheelchairAlert);
  graph.streetNotesService.removeNotes(left);
  graph.streetNotesService.removeNotes(leftBack);
  graph.streetNotesService.addNote(left,wheelchairAlert,StreetNotesService.WHEELCHAIR_MATCHER);
  graph.streetNotesService.addNote(leftBack,wheelchairAlert,StreetNotesService.WHEELCHAIR_MATCHER);
  req.setWheelchairAccessible(true);
  start=StreetLocation.createStreetLocation(graph,"start","start",filter(turns,StreetEdge.class),new LinearLocation(0,0.4).getCoordinate(left.getGeometry()));
  traversedOne=new State((Vertex)start,req);
  for (  Edge e : start.getOutgoing()) {
    currentState=e.traverse(traversedOne);
    if (currentState != null) {
      traversedOne=currentState;
      break;
    }
  }
  assertEquals(wheelchairAlerts,graph.streetNotesService.getNotes(traversedOne));
  assertNotSame(left,traversedOne.getBackEdge().getFromVertex());
  assertNotSame(leftBack,traversedOne.getBackEdge().getFromVertex());
}
