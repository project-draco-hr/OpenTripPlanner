{
  LOG.info("access modes: {}",request.accessModes);
  LOG.info("egress modes: {}",request.egressModes);
  LOG.info("direct modes: {}",request.directModes);
  this.window=new TimeWindow(request.fromTime,request.toTime,graph.index.servicesRunning(request.date));
  long searchBeginTime=System.currentTimeMillis();
  long abortTime=searchBeginTime + TIMEOUT * 1000;
  LOG.info("Finding access/egress paths.");
  Multimap<TransitStop,ProfileState> touchedStops=findInitialStops(false);
  LOG.info("Found {} initial stops",touchedStops.size());
  ROUNDS:   for (int round=0; round < MAX_ROUNDS; round++) {
    long roundStart=System.currentTimeMillis();
    LOG.info("Begin round {}; {} stops to explore",round,touchedStops.size());
    Multimap<TransitStop,ProfileState> previousStops=touchedStops;
    touchedStops=ArrayListMultimap.create();
    Set<TripPattern> patternsToExplore=Sets.newHashSet();
    Map<TripPattern,TransitStop> optimalBoardingLocation=null;
    TObjectIntMap<TripPattern> minBoardTime=null;
    if (round == 0) {
      minBoardTime=new TObjectIntHashMap<TripPattern>(100,.75f,Integer.MAX_VALUE);
      optimalBoardingLocation=Maps.newHashMap();
    }
    for (    TransitStop tstop : previousStops.keySet()) {
      Collection<TripPattern> patterns=graph.index.patternsForStop.get(tstop.getStop());
      patternsToExplore.addAll(patterns);
      if (round == 0) {
        for (        TripPattern tp : patterns) {
          ProfileState exemplar=previousStops.get(tstop).iterator().next();
          if (exemplar.lowerBound < minBoardTime.get(tp)) {
            minBoardTime.put(tp,exemplar.lowerBound);
            optimalBoardingLocation.put(tp,tstop);
          }
        }
      }
    }
    LOG.info("Exploring {} patterns",patternsToExplore.size());
    PATTERNS:     for (    final TripPattern pattern : patternsToExplore) {
      STOPS:       for (int i=0; i < pattern.stopVertices.length; i++) {
        if (!previousStops.containsKey(pattern.stopVertices[i]))         continue STOPS;
        if (round == 0 && optimalBoardingLocation.get(pattern) != pattern.stopVertices[i])         continue STOPS;
        Collection<ProfileState> statesToPropagate=nondominated(previousStops.get(pattern.stopVertices[i]));
        statesToPropagate=Collections2.filter(statesToPropagate,new Predicate<ProfileState>(){
          @Override public boolean apply(          ProfileState input){
            return !input.patterns.contains(pattern) && (input.targetPatterns == null || input.targetPatterns.contains(pattern));
          }
        }
);
        if (statesToPropagate.isEmpty())         continue STOPS;
        int minWaitTime=Integer.MAX_VALUE;
        int maxWaitTime=Integer.MIN_VALUE;
        for (        FrequencyEntry freq : pattern.scheduledTimetable.frequencyEntries) {
          if (freq.exactTimes) {
            throw new IllegalStateException("Exact times not yet supported in profile routing.");
          }
          int overlap=window.overlap(freq.startTime,freq.endTime,freq.tripTimes.serviceCode);
          if (overlap > 0) {
            if (freq.headway > maxWaitTime)             maxWaitTime=freq.headway;
            minWaitTime=0;
          }
        }
        DESTSTOPS:         for (int j=i + 1; j < pattern.stopVertices.length; j++) {
          int minRideTime=Integer.MAX_VALUE;
          int maxRideTime=Integer.MIN_VALUE;
          for (          TripTimes tripTimes : pattern.scheduledTimetable.tripTimes) {
            int depart=tripTimes.getDepartureTime(i);
            int arrive=tripTimes.getArrivalTime(j);
            if (window.includes(depart) && window.includes(arrive) && window.servicesRunning.get(tripTimes.serviceCode)) {
              int t=arrive - depart;
              if (t < minRideTime)               minRideTime=t;
              if (t > maxRideTime)               maxRideTime=t;
            }
          }
          for (          FrequencyEntry freq : pattern.scheduledTimetable.frequencyEntries) {
            TripTimes tt=freq.tripTimes;
            int overlap=window.overlap(freq.startTime,freq.endTime,tt.serviceCode);
            if (overlap == 0)             continue;
            int depart=tt.getDepartureTime(i);
            int arrive=tt.getArrivalTime(j);
            int t=arrive - depart;
            if (t < minRideTime)             minRideTime=t;
            if (t > maxRideTime)             maxRideTime=t;
          }
          for (          ProfileState ps : statesToPropagate) {
            ProfileState ps2=ps.propagate(minWaitTime + minRideTime,maxWaitTime + maxRideTime);
            ps2.stop=pattern.stopVertices[j];
            ps2.accessType=Type.TRANSIT;
            ps2.clearPatterns();
            ps2.patterns.add(pattern);
            touchedStops.put(ps2.stop,ps2);
          }
        }
      }
    }
    LOG.info("Round completed, merging similar states");
    Set<TransitStop> touchedStopVertices=new HashSet<TransitStop>(touchedStops.keySet());
    for (    TransitStop tstop : touchedStopVertices) {
      Collection<ProfileState> pss=nondominated(touchedStops.get(tstop));
      if (pss.isEmpty())       continue;
      Map<ProfileState,ProfileState> foundStates=Maps.newHashMap();
      for (Iterator<ProfileState> it=pss.iterator(); it.hasNext(); ) {
        ProfileState ps=it.next();
        if (foundStates.containsKey(ps.previous)) {
          it.remove();
          foundStates.get(ps.previous).mergeIn(ps);
        }
 else         foundStates.put(ps.previous,ps);
      }
    }
    for (    Entry<TransitStop,ProfileState> e : touchedStops.entries()) {
      retainedStates.put(e.getKey(),e.getValue());
    }
    if (round == MAX_ROUNDS - 1) {
      LOG.info("Finished round {} in {} seconds",round,(System.currentTimeMillis() - roundStart) / 1000);
      break ROUNDS;
    }
    LOG.info("Finding transfers . . .");
    Set<TransitStop> touchedStopKeys=new HashSet<TransitStop>(touchedStops.keySet());
    for (    TransitStop tstop : touchedStopKeys) {
      List<Tuple2<TransitStop,Integer>> accessTimes=Lists.newArrayList();
      for (      Edge e : tstop.getOutgoing()) {
        if (e instanceof SimpleTransfer) {
          SimpleTransfer t=(SimpleTransfer)e;
          int time=(int)(t.getDistance() / request.walkSpeed);
          accessTimes.add(new Tuple2((TransitStop)e.getToVertex(),time));
        }
      }
      Collection<ProfileState> statesAtStop=nondominated(touchedStops.get(tstop));
      minBoardTime=new TObjectIntHashMap<TripPattern>(1000,.75f,Integer.MAX_VALUE);
      Map<TripPattern,ProfileState> optimalBoardState=Maps.newHashMap();
      List<ProfileState> xferStates=Lists.newArrayList();
      for (      ProfileState ps : statesAtStop) {
        for (        Tuple2<TransitStop,Integer> atime : accessTimes) {
          ProfileState ps2=ps.propagate(atime.b);
          ps2.accessType=Type.TRANSFER;
          ps2.stop=atime.a;
          for (          TripPattern patt : graph.index.patternsForStop.get(tstop.getStop())) {
            if (atime.b < minBoardTime.get(patt)) {
              minBoardTime.put(patt,atime.b);
              optimalBoardState.put(patt,ps2);
            }
          }
          xferStates.add(ps2);
        }
      }
      for (      Entry<TripPattern,ProfileState> e : optimalBoardState.entrySet()) {
        ProfileState ps=e.getValue();
        if (ps.targetPatterns == null)         ps.targetPatterns=Sets.newHashSet();
        ps.targetPatterns.add(e.getKey());
      }
      for (      ProfileState ps : xferStates) {
        if (ps.targetPatterns != null && !ps.targetPatterns.isEmpty()) {
          touchedStops.put(ps.stop,ps);
        }
      }
    }
    LOG.info("Finished round {} in {} seconds",round,(System.currentTimeMillis() - roundStart) / 1000);
  }
  LOG.info("Finished profile routing in {} seconds",(System.currentTimeMillis() - searchBeginTime) / 1000);
  makeSurfaces();
}
