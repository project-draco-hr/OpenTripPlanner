{
  try {
    FeatureSource<SimpleFeatureType,SimpleFeature> featureSource=_featureSourceFactory.getFeatureSource();
    CoordinateReferenceSystem sourceCRS=featureSource.getInfo().getCRS();
    Hints hints=new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER,Boolean.TRUE);
    CRSAuthorityFactory factory=ReferencingFactoryFinder.getCRSAuthorityFactory("EPSG",hints);
    CoordinateReferenceSystem worldCRS=factory.createCoordinateReferenceSystem("EPSG:4326");
    DefaultQuery query=new DefaultQuery();
    query.setCoordinateSystem(sourceCRS);
    query.setCoordinateSystemReproject(worldCRS);
    FeatureCollection<SimpleFeatureType,SimpleFeature> features=featureSource.getFeatures(query);
    HashMap<Coordinate,TreeSet<String>> coordinateToStreetNames=getCoordinatesToStreetNames(features);
    features=featureSource.getFeatures(query);
    HashMap<String,HashMap<Coordinate,Integer>> intersectionNameToId=new HashMap<String,HashMap<Coordinate,Integer>>();
    SimpleFeatureConverter<String> streetIdConverter=_schema.getIdConverter();
    SimpleFeatureConverter<String> streetNameConverter=_schema.getNameConverter();
    SimpleFeatureConverter<P2<StreetTraversalPermission>> permissionConverter=_schema.getPermissionConverter();
    HashMap<Coordinate,P2<EndpointVertex>> intersectionsByLocation=new HashMap<Coordinate,P2<EndpointVertex>>();
    SimpleFeatureConverter<P2<Double>> safetyConverter=_schema.getBicycleSafetyConverter();
    SimpleFeatureConverter<Boolean> slopeOverrideCoverter=_schema.getSlopeOverrideConverter();
    SimpleFeatureConverter<Boolean> featureSelector=_schema.getFeatureSelector();
    HashSet<Object> seen=new HashSet<Object>();
    List<SimpleFeature> featureList=new ArrayList<SimpleFeature>();
    Iterator<SimpleFeature> it2=features.iterator();
    while (it2.hasNext()) {
      SimpleFeature feature=it2.next();
      if (featureSelector != null && !featureSelector.convert(feature)) {
        continue;
      }
      featureList.add(feature);
    }
    features.close(it2);
    for (    SimpleFeature feature : featureList) {
      LineString geom=toLineString((Geometry)feature.getDefaultGeometry());
      Object o=streetIdConverter.convert(feature);
      String id="" + o;
      if (o != null && seen.contains(id)) {
        continue;
      }
      seen.add(id);
      String name=streetNameConverter.convert(feature);
      Coordinate[] coordinates=geom.getCoordinates();
      Coordinate startCoordinate=new Coordinate(Math.round(coordinates[0].x * 1048576) / 1048576.0,Math.round(coordinates[0].y * 1048576) / 1048576.0);
      Coordinate endCoordinate=new Coordinate(Math.round(coordinates[coordinates.length - 1].x * 1048576) / 1048576.0,Math.round(coordinates[coordinates.length - 1].y * 1048576) / 1048576.0);
      String startIntersectionName=getIntersectionName(coordinateToStreetNames,intersectionNameToId,startCoordinate);
      if (startIntersectionName == "null") {
        log.warn("No intersection name for " + name);
      }
      String endIntersectionName=getIntersectionName(coordinateToStreetNames,intersectionNameToId,endCoordinate);
      P2<EndpointVertex> startIntersection=intersectionsByLocation.get(startCoordinate);
      if (startIntersection == null) {
        EndpointVertex in=new EndpointVertex(startIntersectionName + " in",startCoordinate.x,startCoordinate.y,startIntersectionName);
        EndpointVertex out=new EndpointVertex(startIntersectionName + " out",startCoordinate.x,startCoordinate.y,startIntersectionName);
        in=(EndpointVertex)graph.addVertex(in);
        out=(EndpointVertex)graph.addVertex(out);
        startIntersection=new P2<EndpointVertex>(in,out);
        intersectionsByLocation.put(startCoordinate,startIntersection);
      }
      P2<EndpointVertex> endIntersection=intersectionsByLocation.get(endCoordinate);
      if (endIntersection == null) {
        EndpointVertex in=new EndpointVertex(endIntersectionName + " in",endCoordinate.x,endCoordinate.y,endIntersectionName);
        EndpointVertex out=new EndpointVertex(endIntersectionName + " out",endCoordinate.x,endCoordinate.y,endIntersectionName);
        in=(EndpointVertex)graph.addVertex(in);
        out=(EndpointVertex)graph.addVertex(out);
        endIntersection=new P2<EndpointVertex>(in,out);
        intersectionsByLocation.put(endCoordinate,endIntersection);
      }
      double length=0;
      for (int i=0; i < coordinates.length - 1; ++i) {
        length+=JTS.orthodromicDistance(coordinates[i],coordinates[i + 1],worldCRS);
      }
      StreetVertex street=new StreetVertex(id,geom,name,length,false);
      graph.addVertex(street);
      coordinates=geom.getCoordinates();
      Coordinate[] coordinatesCopy=Arrays.asList(coordinates).toArray(new Coordinate[0]);
      Collections.reverse(Arrays.asList(coordinatesCopy));
      LineString reversed=new GeometryFactory().createLineString(coordinatesCopy);
      StreetVertex backStreet=new StreetVertex(id,reversed,name,length,true);
      graph.addVertex(backStreet);
      graph.addEdge(new OutEdge(street,endIntersection.getFirst()));
      graph.addEdge(new FreeEdge(startIntersection.getSecond(),street));
      graph.addEdge(new FreeEdge(endIntersection.getSecond(),backStreet));
      graph.addEdge(new OutEdge(backStreet,startIntersection.getFirst()));
      boolean slopeOverride=slopeOverrideCoverter.convert(feature);
      street.setSlopeOverride(slopeOverride);
      backStreet.setSlopeOverride(slopeOverride);
      P2<StreetTraversalPermission> permissions=permissionConverter.convert(feature);
      street.setTraversalPermission(permissions.getFirst());
      backStreet.setTraversalPermission(permissions.getSecond());
      P2<Double> effectiveLength;
      if (safetyConverter != null) {
        effectiveLength=safetyConverter.convert(feature);
        if (effectiveLength != null) {
          street.setBicycleSafetyEffectiveLength(effectiveLength.getFirst() * length);
          backStreet.setBicycleSafetyEffectiveLength(effectiveLength.getSecond() * length);
        }
      }
    }
    for (    P2<EndpointVertex> vertices : intersectionsByLocation.values()) {
      Vertex in=vertices.getFirst();
      Vertex out=vertices.getSecond();
      for (      Edge e : graph.getIncoming(in)) {
        StreetVertex v1=(StreetVertex)e.getFromVertex();
        for (        Edge e2 : graph.getOutgoing(out)) {
          StreetVertex v2=(StreetVertex)e2.getToVertex();
          if (v1 != v2 && v1.getEdgeId() != v2.getEdgeId()) {
            graph.addEdge(new TurnEdge(v1,v2));
          }
        }
      }
    }
    features.close(it2);
    StreetUtils.unify(graph,intersectionsByLocation.values());
  }
 catch (  Exception ex) {
    throw new IllegalStateException("error loading shapefile street data",ex);
  }
}
