{
  try {
    FeatureSource<SimpleFeatureType,SimpleFeature> featureSource=_featureSourceFactory.getFeatureSource();
    CoordinateReferenceSystem sourceCRS=featureSource.getInfo().getCRS();
    Hints hints=new Hints(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER,Boolean.TRUE);
    CRSAuthorityFactory factory=ReferencingFactoryFinder.getCRSAuthorityFactory("EPSG",hints);
    CoordinateReferenceSystem worldCRS=factory.createCoordinateReferenceSystem("EPSG:4326");
    DefaultQuery query=new DefaultQuery();
    query.setCoordinateSystem(sourceCRS);
    query.setCoordinateSystemReproject(worldCRS);
    FeatureCollection<SimpleFeatureType,SimpleFeature> features=featureSource.getFeatures(query);
    HashMap<Coordinate,TreeSet<String>> coordinateToStreetNames=getCoordinatesToStreetNames(features);
    features=featureSource.getFeatures(query);
    HashMap<String,HashMap<Coordinate,Integer>> intersectionNameToId=new HashMap<String,HashMap<Coordinate,Integer>>();
    SimpleFeatureConverter<String> streetIdConverter=_schema.getIdConverter();
    SimpleFeatureConverter<String> streetNameConverter=_schema.getNameConverter();
    SimpleFeatureConverter<P2<StreetTraversalPermission>> permissionConverter=_schema.getPermissionConverter();
    HashMap<Coordinate,ArrayList<Edge>> edgesByLocation=new HashMap<Coordinate,ArrayList<Edge>>();
    SimpleFeatureConverter<Double> safetyConverter=_schema.getBicycleSafetyConverter();
    Iterator<SimpleFeature> it2=features.iterator();
    while (it2.hasNext()) {
      SimpleFeature feature=it2.next();
      LineString geom=toLineString((Geometry)feature.getDefaultGeometry());
      Object o=streetIdConverter.convert(feature);
      String id="" + o;
      String name=streetNameConverter.convert(feature);
      Coordinate[] coordinates=geom.getCoordinates();
      Coordinate startCoordinate=new Coordinate(Math.round(coordinates[0].x * 1048576) / 1048576.0,Math.round(coordinates[0].y * 1048576) / 1048576.0);
      Coordinate endCoordinate=new Coordinate(Math.round(coordinates[coordinates.length - 1].x * 1048576) / 1048576.0,Math.round(coordinates[coordinates.length - 1].y * 1048576) / 1048576.0);
      String startIntersectionName=getIntersectionName(coordinateToStreetNames,intersectionNameToId,startCoordinate);
      if (startIntersectionName == "null") {
        System.out.println(name);
      }
      String endIntersectionName=getIntersectionName(coordinateToStreetNames,intersectionNameToId,endCoordinate);
      String uid="_" + Math.random();
      Vertex startCorner=new GenericVertex(startIntersectionName + uid,startCoordinate.x,startCoordinate.y,startIntersectionName,Intersection.class);
      startCorner=graph.addVertex(startCorner);
      Vertex endCorner=new GenericVertex(endIntersectionName + uid,endCoordinate.x,endCoordinate.y,endIntersectionName,Intersection.class);
      endCorner=graph.addVertex(endCorner);
      double length=JTS.orthodromicDistance(coordinates[0],coordinates[coordinates.length - 1],worldCRS);
      Street street=new Street(startCorner,endCorner,id,name,length);
      street.setGeometry(geom);
      graph.addEdge(street);
      Street backStreet=new Street(endCorner,startCorner,id,name,length);
      backStreet.setGeometry(geom.reverse());
      graph.addEdge(backStreet);
      ArrayList<Edge> startEdges=edgesByLocation.get(startCoordinate);
      if (startEdges == null) {
        startEdges=new ArrayList<Edge>();
        edgesByLocation.put(startCoordinate,startEdges);
      }
      startEdges.add(street);
      startEdges.add(backStreet);
      ArrayList<Edge> endEdges=edgesByLocation.get(endCoordinate);
      if (endEdges == null) {
        endEdges=new ArrayList<Edge>();
        edgesByLocation.put(endCoordinate,endEdges);
      }
      endEdges.add(street);
      endEdges.add(backStreet);
      P2<StreetTraversalPermission> pair=permissionConverter.convert(feature);
      street.setTraversalPermission(pair.getFirst());
      backStreet.setTraversalPermission(pair.getSecond());
      double effectiveLength=safetyConverter.convert(feature) * length;
      street.setBicycleSafetyEffectiveLength(effectiveLength);
      backStreet.setBicycleSafetyEffectiveLength(effectiveLength);
    }
    for (    ArrayList<Edge> edges : edgesByLocation.values()) {
      for (      Edge in : edges) {
        Vertex tov=in.getToVertex();
        Coordinate c=tov.getCoordinate();
        ArrayList<Edge> outEdges=edgesByLocation.get(c);
        if (outEdges != null) {
          for (          Edge out : outEdges) {
            if (tov != out.getFromVertex() && out instanceof Street && out.getFromVertex().getCoordinate().equals(c)) {
              graph.addEdge(new Turn(in,out));
            }
          }
        }
      }
    }
    features.close(it2);
  }
 catch (  Exception ex) {
    throw new IllegalStateException("error loading shapefile street data",ex);
  }
}
