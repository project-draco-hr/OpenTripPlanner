{
  int time=serviceDay.secondsSinceMidnight(s0.getTimeSeconds());
  boolean haveBicycle=s0.getNonTransitMode() == TraverseMode.BICYCLE;
  TripTimes bestTrip=null;
  int index;
  Stop currentStop=pattern.getStop(stopIndex);
  int bestTime=boarding ? Integer.MAX_VALUE : Integer.MIN_VALUE;
  for (  TripTimes tt : tripTimes) {
    if (!serviceDay.serviceRunning(tt.serviceCode))     continue;
    if (boarding) {
      int depTime=tt.getDepartureTime(stopIndex);
      if (depTime < 0)       continue;
      if (depTime >= time && depTime < bestTime && tt.tripAcceptable(s0,currentStop,serviceDay,haveBicycle,stopIndex,boarding)) {
        bestTrip=tt;
        bestTime=depTime;
      }
    }
 else {
      int arvTime=tt.getArrivalTime(stopIndex);
      if (arvTime < 0)       continue;
      if (arvTime <= time && arvTime > bestTime && tt.tripAcceptable(s0,currentStop,serviceDay,haveBicycle,stopIndex,boarding)) {
        bestTrip=tt;
        bestTime=arvTime;
      }
    }
  }
  FrequencyEntry bestFreq=null;
  for (  FrequencyEntry freq : frequencyEntries) {
    TripTimes tt=freq.tripTimes;
    if (!serviceDay.serviceRunning(tt.serviceCode))     continue;
    LOG.debug("  running freq {}",freq);
    if (boarding) {
      int depTime=freq.nextDepartureTime(stopIndex,time);
      if (depTime < 0)       continue;
      if (depTime >= time && depTime < bestTime && tt.tripAcceptable(s0,currentStop,serviceDay,haveBicycle,stopIndex,boarding)) {
        bestFreq=freq;
        bestTime=depTime;
      }
    }
 else {
      int arvTime=freq.prevArrivalTime(stopIndex,time);
      if (arvTime < 0)       continue;
      if (arvTime <= time && arvTime > bestTime && tt.tripAcceptable(s0,currentStop,serviceDay,haveBicycle,stopIndex,boarding)) {
        bestFreq=freq;
        bestTime=arvTime;
      }
    }
  }
  if (bestFreq != null) {
    bestTrip=bestFreq.tripTimes.timeShift(stopIndex,bestTime,boarding);
  }
  return bestTrip;
}
