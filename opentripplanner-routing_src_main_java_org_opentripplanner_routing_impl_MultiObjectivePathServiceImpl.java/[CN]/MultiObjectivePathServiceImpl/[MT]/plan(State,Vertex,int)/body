{
  Date targetTime=new Date(origin.getTime() * 1000);
  TraverseOptions options=origin.getOptions();
  if (_graphService.getCalendarService() != null)   options.setCalendarService(_graphService.getCalendarService());
  options.setTransferTable(_graphService.getGraph().getTransferTable());
  options.setServiceDays(targetTime.getTime() / 1000);
  if (options.getModes().getTransit() && !_graphService.getGraph().transitFeedCovers(targetTime)) {
    throw new TransitTimesException();
  }
  Graph graph=_graphService.getGraph();
  RemainingWeightHeuristic heuristic=_remainingWeightHeuristicFactory.getInstanceForSearch(options,target);
  LOG.debug("Applied A* heuristic: {}",options.remainingWeightHeuristic);
  List<State> returnStates=new LinkedList<State>();
  final ExtraEdgesStrategy extraEdgesStrategy=options.extraEdgesStrategy;
  Map<Vertex,List<Edge>> extraEdges=new HashMap<Vertex,List<Edge>>();
  if (options.isArriveBy()) {
    extraEdgesStrategy.addIncomingEdgesForOrigin(extraEdges,origin.getVertex());
    extraEdgesStrategy.addIncomingEdgesForTarget(extraEdges,target);
  }
 else {
    extraEdgesStrategy.addOutgoingEdgesForOrigin(extraEdges,origin.getVertex());
    extraEdgesStrategy.addOutgoingEdgesForTarget(extraEdges,target);
  }
  if (extraEdges.isEmpty())   extraEdges=Collections.emptyMap();
  BinHeap<State> pq=new BinHeap<State>();
  HashSet<Vertex> closed=new HashSet<Vertex>();
  List<State> boundingStates=new ArrayList<State>();
  HashMap<Vertex,List<State>> states=new HashMap<Vertex,List<State>>();
  pq.reset();
  pq.insert(origin,0);
  heuristic.computeInitialWeight(origin,target);
  long startTime=System.currentTimeMillis();
  long endTime=startTime + (int)(_timeouts[0] * 1000);
  QUEUE:   while (!pq.empty()) {
    if (System.currentTimeMillis() > endTime) {
      LOG.debug("timeout at {} msec",System.currentTimeMillis() - startTime);
      break QUEUE;
    }
    Double su_hweight=pq.peek_min_key();
    State su=pq.extract_min();
    for (    State bs : boundingStates) {
      if (eDominates(bs,su))       continue QUEUE;
    }
    Vertex u=su.getVertex();
    if (u.equals(target)) {
      boundingStates.add(su);
      returnStates.add(su);
      if (!options.getModes().getTransit())       break QUEUE;
      if (returnStates.size() >= _maxPaths)       break QUEUE;
      if (returnStates.size() < _timeouts.length) {
        endTime=startTime + (int)(_timeouts[returnStates.size()] * 1000);
        LOG.debug("{} path, set timeout to {}",returnStates.size(),_timeouts[returnStates.size()] * 1000);
      }
      continue QUEUE;
    }
    Collection<Edge> edges;
    if (options.isArriveBy())     edges=GraphLibrary.getIncomingEdges(graph,u,extraEdges);
 else     edges=GraphLibrary.getOutgoingEdges(graph,u,extraEdges);
    EDGE:     for (    Edge e : edges) {
      State new_sv=e.traverse(su);
      if (new_sv == null)       continue;
      double h=heuristic.computeForwardWeight(new_sv,target);
      for (      State bs : boundingStates) {
        if (eDominates(bs,new_sv))         continue;
      }
      Vertex v=new_sv.getVertex();
      List<State> old_states=states.get(v);
      if (old_states == null) {
        old_states=new LinkedList<State>();
        states.put(v,old_states);
      }
 else {
        for (        State old_sv : old_states) {
          if (eDominates(old_sv,new_sv))           continue EDGE;
        }
        Iterator<State> iter=old_states.iterator();
        while (iter.hasNext()) {
          State old_sv=iter.next();
          if (eDominates(new_sv,old_sv)) {
            iter.remove();
          }
        }
      }
      old_states.add(new_sv);
      pq.insert(new_sv,new_sv.getWeight() + h);
    }
  }
  List<GraphPath> paths=new LinkedList<GraphPath>();
  for (  State s : returnStates)   paths.add(new GraphPath(s,true));
  return paths;
}
