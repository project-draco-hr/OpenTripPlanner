{
  TraverseOptions options=origin.getOptions();
  if (_graphService.getCalendarService() != null)   options.setCalendarService(_graphService.getCalendarService());
  options.setTransferTable(_graphService.getGraph().getTransferTable());
  options.setServiceDays(origin.getTime());
  if (options.getModes().getTransit() && !_graphService.getGraph().transitFeedCovers(new Date(origin.getTime() * 1000))) {
    throw new TransitTimesException();
  }
  RemainingWeightHeuristic heuristic=new BidirectionalRemainingWeightHeuristic(_graphService.getGraph());
  List<State> returnStates=new LinkedList<State>();
  final ExtraEdgesStrategy extraEdgesStrategy=options.extraEdgesStrategy;
  OverlayGraph extraEdges=new OverlayGraph();
  extraEdgesStrategy.addEdgesFor(extraEdges,origin.getVertex());
  extraEdgesStrategy.addEdgesFor(extraEdges,target);
  BinHeap<State> pq=new BinHeap<State>();
  List<State> boundingStates=new ArrayList<State>();
  HashMap<Vertex,List<State>> states=new HashMap<Vertex,List<State>>();
  pq.reset();
  pq.insert(origin,0);
  heuristic.computeInitialWeight(origin,target);
  long startTime=System.currentTimeMillis();
  long endTime=startTime + (int)(_timeouts[0] * 1000);
  QUEUE:   while (!pq.empty()) {
    if (System.currentTimeMillis() > endTime) {
      LOG.debug("timeout at {} msec",System.currentTimeMillis() - startTime);
      break QUEUE;
    }
    State su=pq.extract_min();
    for (    State bs : boundingStates) {
      if (eDominates(bs,su)) {
        continue QUEUE;
      }
    }
    Vertex u=su.getVertex();
    if (u.equals(target)) {
      boundingStates.add(su);
      returnStates.add(su);
      if (!options.getModes().getTransit())       break QUEUE;
      if (returnStates.size() >= _maxPaths)       break QUEUE;
      if (returnStates.size() < _timeouts.length) {
        endTime=startTime + (int)(_timeouts[returnStates.size()] * 1000);
        LOG.debug("{} path, set timeout to {}",returnStates.size(),_timeouts[returnStates.size()] * 1000);
      }
      continue QUEUE;
    }
    EDGE:     for (    Edge e : u.getEdges(extraEdges,null,options.isArriveBy())) {
      State new_sv=e.traverse(su);
      if (new_sv == null)       continue;
      double h=heuristic.computeForwardWeight(new_sv,target);
      for (      State bs : boundingStates) {
        if (eDominates(bs,new_sv)) {
          continue EDGE;
        }
      }
      Vertex v=new_sv.getVertex();
      List<State> old_states=states.get(v);
      if (old_states == null) {
        old_states=new LinkedList<State>();
        states.put(v,old_states);
      }
 else {
        for (        State old_sv : old_states) {
          if (eDominates(old_sv,new_sv)) {
            continue EDGE;
          }
        }
        Iterator<State> iter=old_states.iterator();
        while (iter.hasNext()) {
          State old_sv=iter.next();
          if (eDominates(new_sv,old_sv)) {
            iter.remove();
          }
        }
      }
      old_states.add(new_sv);
      pq.insert(new_sv,new_sv.getWeight() + h);
    }
  }
  List<GraphPath> paths=new LinkedList<GraphPath>();
  for (  State s : returnStates)   paths.add(new GraphPath(s,true));
  return paths;
}
