{
  if (!closed) {
    closeSamples();
    closed=true;
  }
  Queue<ZSamplePoint<TZ,IsoLineUserData>> processQ=new ArrayDeque<ZSamplePoint<TZ,IsoLineUserData>>(sampleGrid.size());
  for (  ZSamplePoint<TZ,IsoLineUserData> A : sampleGrid) {
    A.getU().hProcessed=false;
    A.getU().vProcessed=false;
    processQ.add(A);
  }
  if (debug)   generateDebugGeometry(z0);
  List<LinearRing> rings=new ArrayList<LinearRing>();
  while (!processQ.isEmpty()) {
    ZSamplePoint<TZ,IsoLineUserData> A=processQ.remove();
    IsoLineUserData uA=A.getU();
    if (uA.hProcessed && uA.vProcessed)     continue;
    boolean horizontal=!uA.hProcessed;
    if (horizontal) {
      uA.hProcessed=true;
    }
 else {
      uA.vProcessed=true;
    }
    if (!(uA.vProcessed && uA.hProcessed)) {
      processQ.add(A);
    }
    ZSamplePoint<TZ,IsoLineUserData> B=horizontal ? A.right() : A.up();
    boolean ok=B != null;
    int cut=0;
    if (ok) {
      cut=zFunc.cut(A.getZ(),B.getZ(),z0);
      ok=(cut != 0);
    }
    if (!ok) {
      continue;
    }
    List<Coordinate> polyPoints=new ArrayList<Coordinate>();
    Direction direction=horizontal ? (cut > 0 ? Direction.UP : Direction.DOWN) : (cut > 0 ? Direction.LEFT : Direction.RIGHT);
    while (true) {
      Coordinate cA=getCoordinate(A.getX(),A.getY());
      Coordinate cB=getCoordinate(B.getX(),B.getY());
      double k=zFunc.interpolate(A.getZ(),B.getZ(),z0);
      Coordinate cC=new Coordinate(cA.x * (1.0 - k) + cB.x * k,cA.y * (1.0 - k) + cB.y * k);
      polyPoints.add(cC);
      horizontal=direction == Direction.UP || direction == Direction.DOWN;
      if (horizontal) {
        A.getU().hProcessed=true;
      }
 else {
        A.getU().vProcessed=true;
      }
      ZSamplePoint<TZ,IsoLineUserData> C, D;
      Direction d1, d2;
      boolean invertAB;
switch (direction) {
default :
case UP:
        d1=Direction.LEFT;
      d2=Direction.RIGHT;
    B=A.right();
  C=B.up();
D=A.up();
invertAB=false;
break;
case DOWN:
d1=Direction.LEFT;
d2=Direction.RIGHT;
B=A.right();
C=B.down();
D=A.down();
invertAB=true;
break;
case LEFT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up();
C=B.left();
D=A.left();
invertAB=true;
break;
case RIGHT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up();
C=B.right();
D=A.right();
invertAB=false;
break;
}
boolean ok1=D != null && zFunc.cut(A.getZ(),D.getZ(),z0) != 0 && (horizontal ? (invertAB ? !D.getU().vProcessed : !A.getU().vProcessed) : (invertAB ? !D.getU().hProcessed : !A.getU().hProcessed));
boolean ok2=C != null && zFunc.cut(B.getZ(),C.getZ(),z0) != 0 && (horizontal ? (invertAB ? !C.getU().vProcessed : !B.getU().vProcessed) : (invertAB ? !C.getU().hProcessed : !B.getU().hProcessed));
boolean ok3=C != null && D != null && zFunc.cut(C.getZ(),D.getZ(),z0) != 0 && (horizontal ? !D.getU().hProcessed : !D.getU().vProcessed);
if (ok1 && ok2) {
double dA=Math.max(Math.abs(cA.x - cC.x),Math.abs(cA.y - cC.y));
double dB=Math.max(Math.abs(cB.x - cC.x),Math.abs(cB.y - cC.y));
if (dA <= dB) {
ZSamplePoint<TZ,IsoLineUserData> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
}
 else if (ok1) {
ZSamplePoint<TZ,IsoLineUserData> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else if (ok2) {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
 else if (ok3) {
A=D;
B=C;
}
 else {
break;
}
}
polyPoints.add(polyPoints.get(0));
if (polyPoints.size() > 5) {
LinearRing ring=geometryFactory.createLinearRing(polyPoints.toArray(new Coordinate[polyPoints.size()]));
rings.add(ring);
}
}
List<Polygon> retval=punchHoles(rings);
return geometryFactory.createGeometryCollection(retval.toArray(new Geometry[retval.size()]));
}
