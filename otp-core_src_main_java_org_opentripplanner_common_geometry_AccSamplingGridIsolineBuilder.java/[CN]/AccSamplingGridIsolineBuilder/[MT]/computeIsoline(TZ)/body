{
  if (!closed) {
    closeSamples();
    closed=true;
  }
  Queue<GridSample<TZ>> processQ=new ArrayDeque<GridSample<TZ>>(allSamples.size());
  for (  GridSample<TZ> A : allSamples) {
    A.hProcessed=false;
    A.vProcessed=false;
    processQ.add(A);
  }
  if (debug)   generateDebugGeometry(z0);
  List<LinearRing> rings=new ArrayList<LinearRing>();
  while (!processQ.isEmpty()) {
    GridSample<TZ> A=processQ.remove();
    if (A.hProcessed && A.vProcessed)     continue;
    boolean horizontal=!A.hProcessed;
    if (horizontal) {
      A.hProcessed=true;
    }
 else {
      A.vProcessed=true;
    }
    if (!(A.vProcessed && A.hProcessed)) {
      processQ.add(A);
    }
    GridSample<TZ> B=horizontal ? A.right : A.up;
    boolean ok=B != null;
    int cut=0;
    if (ok) {
      cut=zFunc.cut(A.z,B.z,z0);
      ok=(cut != 0);
    }
    if (!ok) {
      continue;
    }
    List<Coordinate> polyPoints=new ArrayList<Coordinate>();
    Direction direction=horizontal ? (cut > 0 ? Direction.UP : Direction.DOWN) : (cut > 0 ? Direction.LEFT : Direction.RIGHT);
    while (true) {
      Coordinate cA=getCoordinate(A.x,A.y);
      Coordinate cB=getCoordinate(B.x,B.y);
      double k=zFunc.interpolate(A.z,B.z,z0);
      Coordinate cC=new Coordinate(cA.x * (1.0 - k) + cB.x * k,cA.y * (1.0 - k) + cB.y * k);
      polyPoints.add(cC);
      horizontal=direction == Direction.UP || direction == Direction.DOWN;
      if (horizontal) {
        A.hProcessed=true;
      }
 else {
        A.vProcessed=true;
      }
      GridSample<TZ> C, D;
      Direction d1, d2;
      boolean invertAB;
switch (direction) {
default :
case UP:
        d1=Direction.LEFT;
      d2=Direction.RIGHT;
    B=A.right;
  C=B.up;
D=A.up;
invertAB=false;
break;
case DOWN:
d1=Direction.LEFT;
d2=Direction.RIGHT;
B=A.right;
C=B.down;
D=A.down;
invertAB=true;
break;
case LEFT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up;
C=B.left;
D=A.left;
invertAB=true;
break;
case RIGHT:
d1=Direction.DOWN;
d2=Direction.UP;
B=A.up;
C=B.right;
D=A.right;
invertAB=false;
break;
}
boolean ok1=D != null && zFunc.cut(A.z,D.z,z0) != 0 && (horizontal ? (invertAB ? !D.vProcessed : !A.vProcessed) : (invertAB ? !D.hProcessed : !A.hProcessed));
boolean ok2=C != null && zFunc.cut(B.z,C.z,z0) != 0 && (horizontal ? (invertAB ? !C.vProcessed : !B.vProcessed) : (invertAB ? !C.hProcessed : !B.hProcessed));
boolean ok3=C != null && D != null && zFunc.cut(C.z,D.z,z0) != 0 && (horizontal ? !D.hProcessed : !D.vProcessed);
if (ok1 && ok2) {
double dA=Math.max(Math.abs(cA.x - cC.x),Math.abs(cA.y - cC.y));
double dB=Math.max(Math.abs(cB.x - cC.x),Math.abs(cB.y - cC.y));
if (dA <= dB) {
GridSample<TZ> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
}
 else if (ok1) {
GridSample<TZ> oA=A;
A=invertAB ? D : A;
B=invertAB ? oA : D;
direction=d1;
}
 else if (ok2) {
A=invertAB ? C : B;
B=invertAB ? B : C;
direction=d2;
}
 else if (ok3) {
A=D;
B=C;
}
 else {
break;
}
}
polyPoints.add(polyPoints.get(0));
if (polyPoints.size() > 5) {
LinearRing ring=geometryFactory.createLinearRing(polyPoints.toArray(new Coordinate[polyPoints.size()]));
rings.add(ring);
}
}
List<Polygon> retval=punchHoles(rings);
return geometryFactory.createGeometryCollection(retval.toArray(new Geometry[retval.size()]));
}
