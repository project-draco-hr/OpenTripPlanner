{
  Set<RaptorStop> visitedLastRound=cur.visitedLastRound;
  Set<RaptorRoute> routesToVisit=new HashSet<RaptorRoute>();
  for (  RaptorStop stop : visitedLastRound) {
    for (    RaptorRoute route : data.routesForStop[stop.index]) {
      routesToVisit.add(route);
    }
  }
  cur.visitedLastRound=new HashSet<RaptorStop>();
  List<RaptorState>[] statesByStop=cur.getStates();
  int boardSlack=nBoardings == 1 ? options.getBoardSlack() : (options.getTransferSlack() - options.getAlightSlack());
  List<RaptorState> createdStates=new ArrayList<RaptorState>();
  System.out.println("Round " + nBoardings);
  final double distanceToNearestTransitStop=options.rctx.target.getDistanceToNearestTransitStop();
  for (  RaptorRoute route : routesToVisit) {
    List<RaptorState> boardStates=new ArrayList<RaptorState>();
    boolean started=false;
    for (int stopNo=0; stopNo < route.getNStops(); ++stopNo) {
      RaptorStop stop=route.stops[stopNo];
      if (!started && !visitedLastRound.contains(stop))       continue;
      started=true;
      List<RaptorState> states=statesByStop[stop.index];
      List<RaptorState> newStates=new ArrayList<RaptorState>();
      if (states == null) {
        states=new ArrayList<RaptorState>();
        statesByStop[stop.index]=states;
      }
      CONTINUE:       for (      RaptorState boardState : boardStates) {
        RaptorState newState=new RaptorState();
        ServiceDay sd=boardState.serviceDay;
        int alightTime=route.getAlightTime(boardState.patternIndex,boardState.tripIndex,stopNo);
        newState.arrivalTime=(int)sd.time(alightTime);
        newState.arrivalTime+=options.getAlightSlack();
        newState.boardStop=boardState.boardStop;
        newState.boardStopSequence=boardState.boardStopSequence;
        newState.route=route;
        newState.patternIndex=boardState.patternIndex;
        newState.tripIndex=boardState.tripIndex;
        newState.nBoardings=boardState.nBoardings;
        newState.walkDistance=boardState.walkDistance;
        newState.parent=boardState.parent;
        newState.stop=stop;
        for (        RaptorState oldState : states) {
          if (eDominates(oldState,newState)) {
            continue CONTINUE;
          }
        }
        for (        RaptorState oldState : newStates) {
          if (oldState != newState && eDominates(oldState,newState)) {
            continue CONTINUE;
          }
        }
        Iterator<RaptorState> it=states.iterator();
        while (it.hasNext()) {
          RaptorState oldState=it.next();
          if (eDominates(newState,oldState)) {
            it.remove();
          }
        }
        it=newStates.iterator();
        while (it.hasNext()) {
          RaptorState oldState=it.next();
          if (eDominates(newState,oldState)) {
            it.remove();
          }
        }
        cur.visitedLastRound.add(stop);
        cur.visitedEver.add(stop);
        newStates.add(newState);
        StopNearTarget nearTarget=cur.stopsNearTarget.get(stop);
        if (nearTarget != null) {
          RaptorState bound=new RaptorState();
          bound.arrivalTime=newState.arrivalTime + nearTarget.time;
          bound.walkDistance=newState.walkDistance + nearTarget.walkDistance;
          if (bound.walkDistance <= options.maxWalkDistance) {
            bound.nBoardings=newState.nBoardings;
            bound.stop=stop;
            for (            RaptorState oldBound : cur.boundingStates) {
              if (eDominates(oldBound,bound)) {
                continue CONTINUE;
              }
            }
            cur.boundingStates.add(bound);
          }
        }
      }
      if (newStates.size() > 10) {
      }
      if (stopNo < route.getNStops() - 1) {
        if (stop.stopVertex.isLocal() && nBoardings > 1) {
          continue;
        }
        TRYBOARD:         for (        RaptorState oldState : states) {
          if (oldState.nBoardings != nBoardings - 1)           continue;
          if (oldState.route == route)           continue;
          RaptorBoardSpec boardSpec=route.getTripIndex(options,oldState.arrivalTime + boardSlack,stopNo);
          if (boardSpec == null)           continue;
          RaptorState boardState=new RaptorState();
          boardState.nBoardings=nBoardings;
          boardState.boardStop=stop;
          boardState.boardStopSequence=stopNo;
          boardState.arrivalTime=boardSpec.departureTime;
          boardState.patternIndex=boardSpec.patternIndex;
          boardState.tripIndex=boardSpec.tripIndex;
          boardState.parent=oldState;
          boardState.serviceDay=boardSpec.serviceDay;
          boardState.route=route;
          boardState.walkDistance=oldState.walkDistance;
          for (          RaptorState state : newStates) {
            if (eDominates(state,boardState)) {
              continue TRYBOARD;
            }
          }
          for (          RaptorState state : states) {
            if (state != oldState && eDominates(state,boardState)) {
              continue TRYBOARD;
            }
          }
          boardStates.add(boardState);
        }
      }
      createdStates.addAll(newStates);
      states.addAll(newStates);
    }
  }
  ShortestPathTree spt;
  GenericDijkstra dijkstra=new GenericDijkstra(walkOptions);
  if (nBoardings == 0) {
    State start=new MaxWalkState(options.rctx.origin,walkOptions);
    spt=dijkstra.getShortestPathTree(start);
    RoutingRequest reversedWalkOptions=walkOptions.clone();
    reversedWalkOptions.setArriveBy(true);
    GenericDijkstra destDijkstra=new GenericDijkstra(reversedWalkOptions);
    start=new MaxWalkState(options.rctx.target,reversedWalkOptions);
    ShortestPathTree targetSpt=destDijkstra.getShortestPathTree(start);
    for (    State state : targetSpt.getAllStates()) {
      final Vertex vertex=state.getVertex();
      if (!(vertex instanceof TransitStop))       continue;
      RaptorStop stop=data.raptorStopsForStopId.get(((TransitStop)vertex).getStopId());
      if (stop == null) {
        continue;
      }
      cur.addStopNearTarget(stop,state.getWalkDistance(),(int)state.getElapsedTime());
    }
  }
 else {
    final List<State> startPoints=new ArrayList<State>();
    STARTWALK:     for (    RaptorState state : createdStates) {
      if (false) {
        double maxWalk=options.getMaxWalkDistance() - state.walkDistance - distanceToNearestTransitStop;
        CHECK:         for (        T2<Double,RaptorStop> nearby : data.nearbyStops[state.stop.index]) {
          double distance=nearby.getFirst();
          RaptorStop stop=nearby.getSecond();
          if (distance > maxWalk) {
            continue STARTWALK;
          }
          double minWalk=distance + state.walkDistance;
          int minArrive=(int)(state.arrivalTime + distance / options.getSpeedUpperBound());
          if (statesByStop[stop.index] == null) {
            break CHECK;
          }
          for (          RaptorState other : statesByStop[stop.index]) {
            if (other.nBoardings == nBoardings - 1 && (other.walkDistance > minWalk || other.arrivalTime > minArrive)) {
              break CHECK;
            }
          }
        }
      }
      Vertex stopVertex=state.stop.stopVertex;
      Vertex dest=options.rctx.target;
      double minWalk=distanceToNearestTransitStop;
      double targetDistance=distanceLibrary.fastDistance(dest.getCoordinate(),stopVertex.getCoordinate());
      double minTime=(targetDistance - minWalk) / MAX_TRANSIT_SPEED + minWalk / options.getSpeedUpperBound();
      if (targetDistance + state.walkDistance > options.getMaxWalkDistance()) {
        if (state.stop.stopVertex.isLocal())         continue;
        minTime+=boardSlack;
      }
      state.arrivalTime+=minTime;
      state.walkDistance+=minWalk;
      for (      RaptorState bound : cur.boundingStates) {
        if (bound == state) {
          break;
        }
        if (eDominates(bound,state)) {
          state.arrivalTime-=minTime;
          state.walkDistance-=minWalk;
          continue STARTWALK;
        }
      }
      state.arrivalTime-=minTime;
      state.walkDistance-=minWalk;
      if (minWalk + state.walkDistance > options.getMaxWalkDistance()) {
        continue;
      }
      StateEditor dijkstraState=new MaxWalkState.MaxWalkStateEditor(walkOptions,stopVertex);
      dijkstraState.setNumBoardings(state.nBoardings);
      dijkstraState.setWalkDistance(state.walkDistance);
      dijkstraState.setTime(state.arrivalTime);
      dijkstraState.setExtension("raptorParent",state);
      dijkstraState.setOptions(walkOptions);
      dijkstraState.incrementWeight(state.arrivalTime - options.dateTime);
      startPoints.add(dijkstraState.makeState());
    }
    if (startPoints.size() == 0) {
      System.out.println("warning: no walk in round " + nBoardings);
      return;
    }
    System.out.println("walk starts: " + startPoints.size() + " / "+ cur.visitedEver.size());
    dijkstra.setPriorityQueueFactory(new PrefilledPriorityQueueFactory(startPoints.subList(1,startPoints.size())));
    dijkstra.setShortestPathTreeFactory(new ShortestPathTreeFactory(){
      @Override public ShortestPathTree create(      RoutingRequest options){
        ShortestPathTree result;
        if (cur.spt == null) {
          result=new MultiShortestPathTree(options);
        }
 else {
          result=cur.spt;
        }
        for (        State state : startPoints.subList(1,startPoints.size())) {
          result.add(state);
        }
        return result;
      }
    }
);
    final TargetBound bounder=new TargetBound(options,cur.dijkstraBoundingStates);
    dijkstra.setSearchTerminationStrategy(bounder);
    dijkstra.setSkipTraverseResultStrategy(bounder);
    spt=dijkstra.getShortestPathTree(startPoints.get(0));
    if (!bounder.bounders.isEmpty()) {
      cur.dijkstraBoundingStates=bounder.bounders;
    }
    if (cur.spt == null)     cur.spt=spt;
  }
  final List<? extends State> targetStates=spt.getStates(walkOptions.rctx.target);
  if (targetStates != null) {
    TARGET:     for (    State targetState : targetStates) {
      RaptorState state=new RaptorState();
      RaptorState parent=(RaptorState)targetState.getExtension("raptorParent");
      state.parent=parent;
      state.walkDistance=targetState.getWalkDistance();
      state.arrivalTime=(int)targetState.getTime();
      if (parent != null) {
        state.nBoardings=parent.nBoardings;
        state.waitingTime=parent.waitingTime;
      }
      state.walkPath=targetState;
      for (      RaptorState oldState : cur.getTargetStates()) {
        if (eDominates(oldState,state)) {
          continue TARGET;
        }
      }
      cur.addTargetState(state);
      System.out.println("TARGET: " + state);
    }
  }
  SPTSTATE:   for (  State state : spt.getAllStates()) {
    final Vertex vertex=state.getVertex();
    if (!(vertex instanceof TransitStop))     continue;
    RaptorStop stop=data.raptorStopsForStopId.get(((TransitStop)vertex).getStopId());
    if (stop == null) {
      continue;
    }
    List<RaptorState> states=statesByStop[stop.index];
    if (states == null) {
      states=new ArrayList<RaptorState>();
      statesByStop[stop.index]=states;
    }
    double minWalk=distanceToNearestTransitStop;
    RaptorState baseState=(RaptorState)state.getExtension("raptorParent");
    RaptorState newState=new RaptorState();
    if (baseState != null) {
      newState.nBoardings=baseState.nBoardings;
    }
    newState.walkDistance=state.getWalkDistance();
    newState.arrivalTime=(int)state.getTime();
    newState.walkPath=state;
    newState.parent=baseState;
    newState.stop=stop;
    for (    RaptorState oldState : states) {
      if (eDominates(oldState,newState)) {
        continue SPTSTATE;
      }
    }
    double targetDistance=distanceLibrary.fastDistance(options.rctx.target.getCoordinate(),vertex.getCoordinate());
    double minTime=(targetDistance - minWalk) / MAX_TRANSIT_SPEED + minWalk / options.getSpeedUpperBound();
    if (targetDistance > options.maxWalkDistance - state.getWalkDistance())     minTime+=boardSlack;
    for (    RaptorState oldState : cur.getTargetStates()) {
      if (oldState.arrivalTime <= newState.arrivalTime + minTime && oldState.walkDistance <= newState.walkDistance + minWalk)       continue SPTSTATE;
      if ((oldState.arrivalTime - options.dateTime) * 3 <= (newState.arrivalTime + minTime - options.dateTime))       continue SPTSTATE;
    }
    cur.visitedLastRound.add(stop);
    cur.visitedEver.add(stop);
    states.add(newState);
  }
  for (int stop=0; stop < statesByStop.length; ++stop) {
    cur.setStates(stop,statesByStop[stop]);
  }
}
