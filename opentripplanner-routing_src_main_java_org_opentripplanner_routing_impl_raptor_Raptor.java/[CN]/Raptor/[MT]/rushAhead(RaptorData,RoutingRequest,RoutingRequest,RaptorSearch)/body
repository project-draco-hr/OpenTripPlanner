{
  List<Integer> startRegions=getRegionsForVertex(data.regionData,options.rctx.fromVertex);
  int startRegion;
  if (startRegions.size() == 1) {
    startRegion=startRegions.get(0);
  }
 else {
    log.debug("Trip start spans regions, not using rush-ahead optimization");
    return 0;
  }
  List<Integer> endRegions=getRegionsForVertex(data.regionData,options.rctx.toVertex);
  int endRegion;
  if (endRegions.size() == 1) {
    endRegion=endRegions.get(0);
  }
 else {
    log.debug("Trip end spans regions, not using rush-ahead optimization");
    return 0;
  }
  RaptorData trimmedData=new RaptorData();
  trimmedData.raptorStopsForStopId=new HashMap<AgencyAndId,RaptorStop>();
  HashSet<RaptorStop> stops=data.regionData.stops[startRegion][endRegion];
  for (  RaptorStop stop : stops) {
    trimmedData.raptorStopsForStopId.put(stop.stopVertex.getStopId(),stop);
  }
  trimmedData.regionData=data.regionData;
  trimmedData.routes=data.regionData.routes[startRegion][endRegion];
  trimmedData.stops=data.stops;
  trimmedData.routesForStop=data.routesForStop;
  walkOptions.setMaxWalkDistance(6000);
  if (trimmedData.routes.size() == 0) {
    log.debug("No cached routes, so not using rush-ahead optimization");
    return 0;
  }
  RaptorSearch rushSearch=new RaptorSearch(trimmedData,options);
  int bestElapsedTime=Integer.MAX_VALUE;
  int round;
  for (round=0; round < options.getMaxTransfers() + 2; round++) {
    round(trimmedData,options,walkOptions,rushSearch,round);
    if (search.getTargetStates().size() > 0) {
      int oldBest=bestElapsedTime;
      for (      RaptorState state : search.getTargetStates()) {
        final int elapsedTime=(int)Math.abs(state.arrivalTime - options.dateTime);
        if (elapsedTime < bestElapsedTime) {
          bestElapsedTime=elapsedTime;
        }
      }
      int improvement=oldBest - bestElapsedTime;
      if (improvement < 600)       break;
    }
  }
  for (  RaptorState state : rushSearch.getTargetStates()) {
    search.bounder.addBounder(state.walkPath);
    search.addTargetState(state);
  }
  walkOptions.setMaxWalkDistance(options.getMaxWalkDistance());
  return round;
}
