{
  final double radiusDeg=SphericalDistanceLibrary.metersToDegrees(MAX_SEARCH_RADIUS_METERS);
  Envelope env=new Envelope(vertex.getCoordinate());
  final double xscale=Math.cos(vertex.getLat() * Math.PI / 180);
  env.expandBy(radiusDeg / xscale,radiusDeg);
  double duplicateDeg=SphericalDistanceLibrary.metersToDegrees(DUPLICATE_WAY_EPSILON_METERS);
  final TraverseModeSet traverseModeSet;
  if (traverseMode == TraverseMode.BICYCLE) {
    traverseModeSet=new TraverseModeSet(traverseMode,TraverseMode.WALK);
  }
 else {
    traverseModeSet=new TraverseModeSet(traverseMode);
  }
  List<StreetEdge> candidateEdges=new ArrayList<StreetEdge>(Collections2.filter(idx.query(env),new Predicate<StreetEdge>(){
    @Override public boolean apply(    StreetEdge edge){
      return edge.canTraverse(traverseModeSet) && edge.getToVertex().getIncoming().contains(edge);
    }
  }
));
  final TIntDoubleMap distances=new TIntDoubleHashMap();
  for (  StreetEdge e : candidateEdges) {
    distances.put(e.getId(),distance(vertex,e,xscale));
  }
  Collections.sort(candidateEdges,new Comparator<StreetEdge>(){
    @Override public int compare(    StreetEdge o1,    StreetEdge o2){
      double diff=distances.get(o1.getId()) - distances.get(o2.getId());
      if (diff < 0)       return -1;
      if (diff > 0)       return 1;
      return 0;
    }
  }
);
  if (candidateEdges.isEmpty() || distances.get(candidateEdges.get(0).getId()) > radiusDeg)   return false;
  List<StreetEdge> bestEdges=Lists.newArrayList();
  int i=0;
  do {
    bestEdges.add(candidateEdges.get(i++));
  }
 while (i < candidateEdges.size() && distances.get(candidateEdges.get(i).getId()) - distances.get(candidateEdges.get(i - 1).getId()) < duplicateDeg);
  for (  StreetEdge edge : bestEdges) {
    link(vertex,edge,xscale);
  }
  return true;
}
