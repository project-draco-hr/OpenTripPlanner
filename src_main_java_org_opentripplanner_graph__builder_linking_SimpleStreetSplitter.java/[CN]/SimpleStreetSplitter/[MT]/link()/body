{
  idx=new HashGridSpatialIndex<StreetEdge>();
  for (  StreetEdge se : Iterables.filter(graph.getEdges(),StreetEdge.class)) {
    idx.insert(se.getGeometry().getEnvelopeInternal(),se);
  }
  STOPS:   for (  final TransitStop tstop : Iterables.filter(graph.getVertices(),TransitStop.class)) {
    final double radiusDeg=SphericalDistanceLibrary.metersToDegrees(MAX_SEARCH_RADIUS_METERS);
    Envelope env=new Envelope(tstop.getCoordinate());
    final double xscale=Math.cos(tstop.getLat() * Math.PI / 180);
    env.expandBy(radiusDeg / xscale,radiusDeg);
    double duplicateDeg=SphericalDistanceLibrary.metersToDegrees(DUPLICATE_WAY_EPSILON_METERS);
    List<StreetEdge> candidateEdges=new ArrayList<StreetEdge>(Collections2.filter(idx.query(env),new Predicate<StreetEdge>(){
      @Override public boolean apply(      StreetEdge edge){
        return edge.canTraverse(new TraverseModeSet(TraverseMode.WALK)) && edge.getToVertex().getIncoming().contains(edge);
      }
    }
));
    final TIntDoubleMap distances=new TIntDoubleHashMap();
    for (    StreetEdge e : candidateEdges) {
      distances.put(e.getId(),distance(tstop,e,xscale));
    }
    Collections.sort(candidateEdges,new Comparator<StreetEdge>(){
      @Override public int compare(      StreetEdge o1,      StreetEdge o2){
        double diff=distances.get(o1.getId()) - distances.get(o2.getId());
        if (diff < 0)         return -1;
        if (diff > 0)         return 1;
        return 0;
      }
    }
);
    if (candidateEdges.isEmpty() || distances.get(candidateEdges.get(0).getId()) > radiusDeg)     continue STOPS;
    double bestDist=distances.get(candidateEdges.get(0).getId());
    List<StreetEdge> bestEdges=Lists.newArrayList();
    for (    StreetEdge e : candidateEdges) {
      if (distances.get(e.getId()) > bestDist + duplicateDeg)       break;
      bestEdges.add(e);
    }
    for (    StreetEdge edge : bestEdges) {
      link(tstop,edge,xscale);
    }
  }
}
