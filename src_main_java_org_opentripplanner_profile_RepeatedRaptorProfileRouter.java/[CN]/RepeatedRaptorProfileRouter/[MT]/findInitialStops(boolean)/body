{
  double lat=dest ? request.toLat : request.fromLat;
  double lon=dest ? request.toLon : request.fromLon;
  QualifiedModeSet modes=dest ? request.egressModes : request.accessModes;
  RoutingRequest rr=new RoutingRequest(modes);
  rr.batch=true;
  rr.from=new GenericLocation(lat,lon);
  rr.to=rr.from;
  rr.setRoutingContext(graph);
  rr.rctx.pathParsers=new PathParser[]{new InitialStopSearchPathParser()};
  rr.dateTime=request.date.toDateMidnight(DateTimeZone.forTimeZone(graph.getTimeZone())).getMillis() / 1000 + request.fromTime;
  if (rr.modes.contains(TraverseMode.BICYCLE)) {
    rr.dominanceFunction=new DominanceFunction.EarliestArrival();
    rr.worstTime=rr.dateTime + request.maxBikeTime * 60;
  }
 else {
    rr.maxWalkDistance=2000;
    rr.softWalkLimiting=false;
    rr.dominanceFunction=new DominanceFunction.LeastWalk();
  }
  AStar astar=new AStar();
  rr.longDistance=true;
  rr.setNumItineraries(1);
  ShortestPathTree spt=astar.getShortestPathTree(rr,5);
  TObjectIntMap<TransitStop> accessTimes=new TObjectIntHashMap<TransitStop>();
  for (  TransitStop tstop : graph.index.stopVertexForStop.values()) {
    State s=spt.getState(tstop);
    if (s != null) {
      accessTimes.put(tstop,(int)(s.getWalkDistance() / request.walkSpeed));
    }
  }
  this.walkOnlySpt=spt;
  rr.cleanup();
  return accessTimes;
}
