{
  LOG.info("Propagating from transit stops to the street network...");
  StopTreeCache stopTreeCache=graph.index.getStopTreeCache();
  stopTreeCache.distancesForVertex.forEachEntry(new TIntObjectProcedure<TIntIntMap>(){
    @Override public boolean execute(    int vidx,    TIntIntMap distancesToTransitStops){
      Vertex v=graph.getVertexById(vidx);
      int[] bestTravelTimeAtMinute=new int[iterations];
      Arrays.fill(bestTravelTimeAtMinute,Integer.MAX_VALUE);
      for (TIntIntIterator it=distancesToTransitStops.iterator(); it.hasNext(); ) {
        it.advance();
        int tsidx=it.key();
        int[] timesAtStop=timesAtStops.get(tsidx);
        if (timesAtStop == null)         continue;
        for (int i=0; i < timesAtStop.length; i++) {
          int time=timesAtStop[i];
          if (time == Integer.MAX_VALUE)           continue;
          time+=it.value() / request.walkSpeed;
          if (time < bestTravelTimeAtMinute[i])           bestTravelTimeAtMinute[i]=time;
        }
      }
      int min=Integer.MAX_VALUE;
      int max=Integer.MIN_VALUE;
      long sum=0;
      int count=0;
      for (      int time : bestTravelTimeAtMinute) {
        if (time == Integer.MAX_VALUE)         continue;
        if (time < min)         min=time;
        if (time > max)         max=time;
        sum+=time;
        count++;
      }
      if (count == 0)       return true;
      int avg=(int)(sum / count);
      int existingMin=timeSurfaceRangeSet.min.times.get(v);
      if (existingMin == TimeSurface.UNREACHABLE || min < existingMin)       timeSurfaceRangeSet.min.times.put(v,min);
      int existingMax=timeSurfaceRangeSet.max.times.get(v);
      if (existingMax == TimeSurface.UNREACHABLE || max < existingMax)       timeSurfaceRangeSet.max.times.put(v,max);
      int existingAvg=timeSurfaceRangeSet.avg.times.get(v);
      if (existingAvg == TimeSurface.UNREACHABLE || avg < existingAvg)       timeSurfaceRangeSet.avg.times.put(v,avg);
      return true;
    }
  }
);
  LOG.info("Done with propagation.");
}
