{
  TraverseOptions options=origin.getOptions();
  ContractionHierarchySet hierarchies=_graphService.getContractionHierarchySet();
  ContractionHierarchy hierarchy=null;
  if (hierarchies != null)   hierarchy=hierarchies.getHierarchy(options);
  int tries=0;
  while (tries < MAX_TRIES) {
    if (options.remainingWeightHeuristic != null) {
      options.remainingWeightHeuristic.reset();
    }
    tries+=1;
    LOG.debug("try number {} ; max walk distance = {}",tries,options.getMaxWalkDistance());
    if (hierarchy == null) {
      LOG.debug("No contraction hierarchies for this mode, falling back on A*.");
      GenericAStar aStar=getAStarInstance(options);
      Graph _graph=_graphService.getGraph();
      ShortestPathTree spt=aStar.getShortestPathTree(_graph,origin,target);
      if (spt == null) {
        return null;
      }
      List<GraphPath> paths=spt.getPaths(target,true);
      if (paths == null || paths.isEmpty()) {
        options.setMaxWalkDistance(options.getMaxWalkDistance() * 2);
        continue;
      }
 else {
        return paths;
      }
    }
    LOG.debug("Contraction hierarchies exist for this mode, using them.");
    Vertex fromVertex=options.isArriveBy() ? target : origin.getVertex();
    Vertex toVertex=options.isArriveBy() ? origin.getVertex() : target;
    GraphPath path=hierarchy.getShortestPath(fromVertex,toVertex,origin.getTime(),options);
    if (path == null) {
      options.setMaxWalkDistance(options.getMaxWalkDistance() * 2);
      continue;
    }
 else {
      return Arrays.asList(path);
    }
  }
  return Collections.emptyList();
}
