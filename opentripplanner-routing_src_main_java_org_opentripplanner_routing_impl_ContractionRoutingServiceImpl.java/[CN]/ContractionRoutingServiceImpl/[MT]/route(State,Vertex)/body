{
  TraverseOptions options=origin.getOptions();
  ContractionHierarchySet hierarchies=_graphService.getContractionHierarchySet();
  ContractionHierarchy hierarchy=null;
  hierarchy=hierarchies.getHierarchy(options);
  int tries=0;
  while (tries < MAX_TRIES) {
    if (options.remainingWeightHeuristic != null) {
      options.remainingWeightHeuristic.reset();
    }
    tries+=1;
    if (hierarchy == null) {
      GenericAStar aStar=getAStarInstance(options);
      Graph _graph=hierarchies.getGraph();
      ShortestPathTree spt=aStar.getShortestPathTree(_graph,origin,target);
      if (spt == null) {
        return Collections.emptyList();
      }
      List<GraphPath> paths=spt.getPaths(target,true);
      if (paths == null || paths.isEmpty()) {
        options.maxWalkDistance*=2;
        continue;
      }
 else {
        return paths;
      }
    }
    Vertex fromVertex=options.isArriveBy() ? target : origin.getVertex();
    Vertex toVertex=options.isArriveBy() ? origin.getVertex() : target;
    GraphPath path=hierarchy.getShortestPath(fromVertex,toVertex,origin.getTime(),options);
    if (path == null) {
      options.maxWalkDistance*=2;
      continue;
    }
 else {
      return Arrays.asList(path);
    }
  }
  return Collections.emptyList();
}
