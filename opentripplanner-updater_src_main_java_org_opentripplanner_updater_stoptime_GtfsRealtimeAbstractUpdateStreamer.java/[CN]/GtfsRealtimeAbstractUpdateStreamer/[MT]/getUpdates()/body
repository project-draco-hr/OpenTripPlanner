{
  GtfsRealtime.FeedMessage feed=getFeedMessage();
  if (feed == null)   return null;
  GtfsRealtime.FeedHeader header=feed.getHeader();
  long timestamp=header.getTimestamp();
  List<org.opentripplanner.routing.trippattern.TripUpdate> updates=new ArrayList<org.opentripplanner.routing.trippattern.TripUpdate>();
  for (  GtfsRealtime.FeedEntity entity : feed.getEntityList()) {
    if (!entity.hasTripUpdate()) {
      continue;
    }
    GtfsRealtime.TripUpdate tripUpdate=entity.getTripUpdate();
    GtfsRealtime.TripDescriptor descriptor=tripUpdate.getTrip();
    String trip=descriptor.getTripId();
    AgencyAndId tripId=new AgencyAndId(defaultAgencyId,trip);
    ServiceDate serviceDate=new ServiceDate();
    if (descriptor.hasStartDate()) {
      try {
        Date date=ymdParser.parse(descriptor.getStartDate());
        serviceDate=new ServiceDate(date);
      }
 catch (      ParseException e) {
        LOG.warn("Failed to parse startDate in gtfs-rt feed: ",e);
      }
    }
    GtfsRealtime.TripDescriptor.ScheduleRelationship sr;
    if (tripUpdate.getTrip().hasScheduleRelationship()) {
      sr=tripUpdate.getTrip().getScheduleRelationship();
    }
 else {
      sr=GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED;
    }
switch (sr) {
case SCHEDULED:
      updates.add(getUpdateForScheduledTrip(tripId,tripUpdate,timestamp,serviceDate));
    break;
case CANCELED:
  updates.add(getUpdateForCanceledTrip(tripId,timestamp,serviceDate));
break;
case ADDED:
updates.add(getUpdateForAddedTrip(tripId,tripUpdate,timestamp,serviceDate));
break;
case UNSCHEDULED:
LOG.warn("ScheduleRelationship.UNSCHEDULED trips are currently not handled.");
break;
case REPLACEMENT:
LOG.warn("ScheduleRelationship.REPLACEMENT trips are currently not handled.");
break;
}
}
return updates;
}
