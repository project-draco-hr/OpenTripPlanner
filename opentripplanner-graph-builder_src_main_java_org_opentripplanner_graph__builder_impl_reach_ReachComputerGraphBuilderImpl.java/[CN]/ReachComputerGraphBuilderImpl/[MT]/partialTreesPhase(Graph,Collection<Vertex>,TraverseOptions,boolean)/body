{
  log.info("Partial trees phase at epsilon = " + epsilon);
  GenericDijkstra dijkstra=new GenericDijkstra(graph,options);
  if (!transitStops) {
    dijkstra.setSearchTerminationStrategy(new PartialTreesPhaseTerminationCondition());
  }
  dijkstra.setShortestPathTreeFactory(new ShortestPathTreeFactory(){
    @Override public ShortestPathTree create(){
      ReachMiniSPT spt=new ReachMiniSPT(epsilon);
      return spt;
    }
  }
);
  dijkstra.setPriorityQueueFactory(new OTPPriorityQueueFactory(){
    @SuppressWarnings("unchecked") public OTPPriorityQueue<State> create(    int maxSize){
      int size=(int)epsilon;
      int graphSize=graph.getVertices().size();
      if (graphSize < size) {
        size=graphSize;
      }
      OTPPriorityQueue<State> pq=new BinHeap<State>(size);
      return pq;
    }
  }
);
  HashMap<Edge,Double> reachEstimateForEdge=new HashMap<Edge,Double>();
  int i=0;
  long dijkstraTime=0;
  long heightTime=0;
  for (  final Vertex v : streetVertices) {
    i+=1;
    final ReachState initialState=new ReachState(v,options);
    long startTime=System.currentTimeMillis();
    ReachMiniSPT spt=(ReachMiniSPT)dijkstra.getShortestPathTree(initialState);
    spt.computeChildren();
    long endTime=System.currentTimeMillis();
    dijkstraTime+=endTime - startTime;
    if (i % 100 == 0) {
      log.info("partial trees: " + i + " / "+ streetVertices.size()+ " dij time "+ (dijkstraTime / 1000.0)+ " height time "+ (heightTime / 1000.0));
      dijkstraTime=0;
      heightTime=0;
    }
    for (    ReachState state : spt.getInnerCircle()) {
      for (      ReachState child : state.getChildren()) {
        Edge edge=child.getBackEdge();
        if (edge == null) {
          continue;
        }
        Double edgeInPenalty=inPenalty.get(v);
        if (edgeInPenalty == null) {
          edgeInPenalty=0.0;
        }
        double depth=child.getWeight() + edgeInPenalty;
        startTime=System.currentTimeMillis();
        double height=spt.getHeight(child,outPenalty) + child.getWeightDelta();
        endTime=System.currentTimeMillis();
        heightTime+=endTime - startTime;
        double reach=depth;
        if (reach > height) {
          reach=height;
        }
        MapUtils.addToMaxMap(reachEstimateForEdge,edge,reach);
      }
    }
  }
  Graph newGraph=new Graph();
  int edgesRemoved=0;
  HashSet<Edge> edges=new HashSet<Edge>();
  for (  GraphVertex v : graph.getVertices()) {
    for (    EdgeWithReach edge : IterableLibrary.filter(v.getOutgoing(),EdgeWithReach.class)) {
      if (!edges.contains(edge)) {
        edgesRemoved+=processEdge(newGraph,edge,reachEstimateForEdge,transitStops);
        edges.add(edge);
      }
    }
    for (    EdgeWithReach edge : IterableLibrary.filter(v.getIncoming(),EdgeWithReach.class)) {
      if (!edges.contains(edge)) {
        edgesRemoved+=processEdge(newGraph,edge,reachEstimateForEdge,transitStops);
        edges.add(edge);
      }
    }
  }
  log.info("Removed " + edgesRemoved + " / "+ edges.size()+ " edges");
  return newGraph;
}
