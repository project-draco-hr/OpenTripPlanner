{
  EdgeNarrative narrative=traverseResult.getEdgeNarrative();
  Vertex tov=narrative.getToVertex();
  State fromState=from.state;
  StateData fromData=fromState.getData();
  double euclidianDistance=tov.distance(target);
  if (useTransit) {
    if (fromData.isAlightedLocal()) {
      return options.walkReluctance * euclidianDistance / options.speed;
    }
 else {
      int boardCost;
      if (edge instanceof OnBoardForwardEdge) {
        boardCost=options.boardCost;
      }
 else {
        boardCost=0;
      }
      if (euclidianDistance < target.getDistanceToNearestTransitStop()) {
        return options.walkReluctance * euclidianDistance / options.speed;
      }
 else {
        double mandatoryWalkDistance=target.getDistanceToNearestTransitStop() + tov.getDistanceToNearestTransitStop();
        double distance=(euclidianDistance - mandatoryWalkDistance) / maxSpeed + mandatoryWalkDistance * options.walkReluctance / options.speed + boardCost;
        return Math.min(distance,options.walkReluctance * euclidianDistance / options.speed);
      }
    }
  }
 else {
    return options.walkReluctance * euclidianDistance / maxSpeed;
  }
}
